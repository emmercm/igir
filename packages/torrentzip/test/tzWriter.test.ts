import fs from 'node:fs';
import path from 'node:path';

import { jest } from '@jest/globals';

import Logger from '../../../src/console/logger.js';
import { LogLevel } from '../../../src/console/logLevel.js';
import Defaults from '../../../src/globals/defaults.js';
import Temp from '../../../src/globals/temp.js';
import Igir from '../../../src/igir.js';
import FsPoly from '../../../src/polyfill/fsPoly.js';
import IOFile from '../../../src/polyfill/ioFile.js';
import FileChecksums, { ChecksumBitmask } from '../../../src/types/files/fileChecksums.js';
import Options from '../../../src/types/options.js';
import TZWriter from '../src/tzWriter.js';

jest.setTimeout(5 * 60 * 1000); // 5min

it('should write correct zip files', async () => {
  const tempDir = await FsPoly.mkdtemp(Temp.getTempDir());

  try {
    await new Igir(
      new Options({
        commands: ['copy', 'zip'],
        dat: [path.join('test', 'fixtures', 'dats', 'one.*')],
        input: [path.join('test', 'fixtures', 'roms')],
        output: tempDir,
        filterRegexExclude: 'Lorem Ipsum',
        excludeDisks: true,
        dirDatName: true,
        disableCache: true,
      }),
      new Logger(LogLevel.NEVER),
    ).main();

    const writtenFiles = (await FsPoly.walk(tempDir)).sort();
    const writtenFilesHashed = await Promise.all(
      writtenFiles.map(async (filePath) => {
        const checksums = await FileChecksums.hashFile(filePath, ChecksumBitmask.CRC32);
        return [filePath.replace(tempDir + path.sep, ''), checksums.crc32 as string];
      }),
    );

    expect(writtenFilesHashed).toEqual([
      // Generated by ROMVault v3.7.2
      [path.join('One', 'Fizzbuzz.zip'), '9dfd1d34'],
      [path.join('One', 'Foobar.zip'), '96d4b5fe'],
      [path.join('One', 'GameCube-240pSuite-1.19.zip'), '96e24c01'],
      [path.join('One', 'One Three.zip'), 'ab9a27f2'],
      [path.join('One', 'Optical Game (Disc 1).zip'), '7c60248b'],
      [path.join('One', 'Optical Game (Disc 2).zip'), '0a0641d3'],
      [path.join('One', 'Three Four Five.zip'), '1f83f597'],
      [path.join('One', 'UMD.zip'), '445d49b1'],
    ]);
  } finally {
    await FsPoly.rm(tempDir, {
      recursive: true,
      force: true,
    });
  }
});

test.each([
  // CP437
  ['café', '3afbc02191a7ee92df2a4c757b92668a'],
  ['☺☻', '41111c300b550951086d4a4267fdb22a'],
  ['♦♣♠♥', 'd3dc1e0c7714480fa26ccf924352c27c'],
  // UTF-8
  ['你好', '69c166dbd72a3689aee86bf22c37b384'],
  ['🌸✨🦊', '525584140748b56ef0e04891bd8baaea'],
  ['みんな', '2d600a970ff4ba5a023e184e6e7149e7'],
])(
  'should compress non-ASCII files correctly: %s',
  async (fileName: string, expectedZipMd5: string) => {
    const fileSize = 4096;
    const expectedRawMd5 = '620f0b67a91f7f74151bc5be745b7110';

    // Generate the file
    const tempFilePath = await FsPoly.mktemp(path.join(Temp.getTempDir(), fileName));
    const tempZipPath = await FsPoly.mktemp(path.join(Temp.getTempDir(), `${fileName}.zip`));
    try {
      // Create a file and fill it with zeroes
      const tempFileDir = path.dirname(tempFilePath);
      if (!(await FsPoly.exists(tempFileDir))) {
        await FsPoly.mkdir(tempFileDir, { recursive: true });
      }
      const tempFile = await IOFile.fileOfSize(tempFilePath, 'w', fileSize);
      const emptyBuffer = Buffer.alloc(Defaults.FILE_READING_CHUNK_SIZE);
      let position = 0;
      while (position < fileSize) {
        await tempFile.writeAt(
          emptyBuffer.subarray(0, Math.min(emptyBuffer.length, fileSize - position)),
          position,
        );
        position += emptyBuffer.length;
      }
      await tempFile.close();

      // Sanity check the temp file
      await expect(FsPoly.size(tempFilePath)).resolves.toEqual(fileSize);
      const tempFileMd5 = (await FileChecksums.hashFile(tempFilePath, ChecksumBitmask.MD5)).md5;
      expect(tempFileMd5).toEqual(expectedRawMd5);

      // Write the TorrentZip file
      const tempZip = await TZWriter.open(tempZipPath);
      await tempZip.addStream(fs.createReadStream(tempFilePath), fileName, fileSize);
      await tempZip.finalize();
      await tempZip.close();

      const tempZipMd5 = (await FileChecksums.hashFile(tempZipPath, ChecksumBitmask.MD5)).md5;
      expect(tempZipMd5).toEqual(expectedZipMd5);
    } finally {
      await FsPoly.rm(tempFilePath, { force: true });
      await FsPoly.rm(tempZipPath, { force: true });
    }
  },
);

// @ts-expect-error __coverage__ exists
if (globalThis.__coverage__) {
  test.each([
    // ~4,095MiB
    // Generated by ROMVault v3.7.2
    [0xff_ff_ff_ff - 1, '541249e3205af07b4a03f891185f64a0', '6774743f72258f5ac28d90a7de8c05fb'],
    [0xff_ff_ff_ff, 'c654ebc4b3472cfa01ade24bbbbc6d3e', 'd1ae563f29e137c71bb2f20a1d08972d'],
    [0xff_ff_ff_ff + 1, 'c9a5a6878d97b48cc965c1e41859f034', '7d3cbf0885c4ca2fea3dd55bb2394c10'],
  ])(
    'should compress large files correctly: %s',
    async (fileSize: number, expectedRawMd5: string, expectedZipMd5: string) => {
      // Generate the file
      const tempFilePath = await FsPoly.mktemp(path.join(Temp.getTempDir(), 'large'));
      const tempZipPath = await FsPoly.mktemp(path.join(Temp.getTempDir(), 'zip64.zip'));
      try {
        // Create a file and fill it with zeroes
        const tempFileDir = path.dirname(tempFilePath);
        if (!(await FsPoly.exists(tempFileDir))) {
          await FsPoly.mkdir(tempFileDir, { recursive: true });
        }
        const tempFile = await IOFile.fileOfSize(tempFilePath, 'w', fileSize);
        const emptyBuffer = Buffer.alloc(Defaults.FILE_READING_CHUNK_SIZE);
        let position = 0;
        while (position < fileSize) {
          await tempFile.writeAt(
            emptyBuffer.subarray(0, Math.min(emptyBuffer.length, fileSize - position)),
            position,
          );
          position += emptyBuffer.length;
        }
        await tempFile.close();

        // Sanity check the temp file
        await expect(FsPoly.size(tempFilePath)).resolves.toEqual(fileSize);
        const tempFileMd5 = (await FileChecksums.hashFile(tempFilePath, ChecksumBitmask.MD5)).md5;
        expect(tempFileMd5).toEqual(expectedRawMd5);

        // Write the TorrentZip file
        const tempZip = await TZWriter.open(tempZipPath);
        await tempZip.addStream(fs.createReadStream(tempFilePath), 'large', fileSize);
        await tempZip.finalize();
        await tempZip.close();

        const tempZipMd5 = (await FileChecksums.hashFile(tempZipPath, ChecksumBitmask.MD5)).md5;
        expect(tempZipMd5).toEqual(expectedZipMd5);
      } finally {
        await FsPoly.rm(tempFilePath, { force: true });
        await FsPoly.rm(tempZipPath, { force: true });
      }
    },
  );
}
