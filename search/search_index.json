{"config": {"lang": ["en"], "separator": "[\\s\\-]+", "pipeline": ["stopWordFilter"]}, "docs": [{"location": "", "title": "Index", "text": "<p>Pronounced \"eager,\" Igir is a zero-setup ROM collection manager that sorts, filters, extracts or archives, patches, and reports on collections of any size on any OS.</p> <p> </p> <p> </p> <p>See the project website for complete documentation, installation &amp; usage instructions, and examples!</p> <p></p>"}, {"location": "#what-does-igir-do", "title": "What does Igir do?", "text": "<p>A video of an example use case:</p> <p></p> <p>With Igir you can manage a ROM collection of any size:</p> <ul> <li>\ud83d\udd0d Scan for DATs, ROMs, and ROM patches\u2014including those in archives (see scanning &amp; archive docs)</li> <li>\ud83d\udcc2 Organize ROM files by console (see DAT docs)</li> <li>\ud83e\ude84 Name ROM files consistently, including the right extension (see DAT docs)</li> <li>\u2702\ufe0f Filter out duplicate ROMs, or ROMs in languages you don't understand (see filtering docs)</li> <li>\ud83d\udddc\ufe0f Extract or archive ROMs in mass (see archive docs)</li> <li>\ud83d\udd22 Create playlists for multi-disc games in mass (see playlist docs)</li> <li>\ud83e\ude79 Patch ROMs automatically in mass (see scanning &amp; patching docs)</li> <li>\ud83c\udfa9 Parse ROMs with headers and optionally remove them (see header docs)</li> <li>\u2194\ufe0f Build &amp; re-build (un-merge, split, or merge) MAME ROM sets (see arcade docs)</li> <li>\ud83d\udd2e Report on what ROMs are present or missing for each console and create fixdats for missing ROMs (see reporting &amp; DAT docs)</li> </ul>"}, {"location": "#how-do-i-run-igir", "title": "How do I run Igir?", "text": "<p>Either download the latest version for your OS from the releases page, or if you have Node.js installed you can use <code>npx</code> to always run the latest version from the command line:</p> <pre><code>npx igir@latest [commands..] [options]\n</code></pre> <p>Here is the full help message which shows all available options and a number of common use case examples:</p> <pre><code>$ igir --help\n\n   @@@@@@   @@@@@@     @@@@@@    @@@@@@@@\n @@      @@  @@      @@      @@         @@\n @@      @@  @@      @@      @@         @@   ROM collection manager\n   @@@@@@   @@         @@@@@@   @@@@@@@@@    https://igir.io/\n          @@@     @@@@        @@@\n     @@   @@        @@   @@   @@       @@    v4.1.2\n     @@   @@        @@   @@   @@       @@\n     @@   @@@@@@@@@@@@   @@   @@       @@\n\nUsage: igir [commands..] [options]\n\nCommands (can specify multiple):\n  igir copy      Copy ROM files from the input to output directory\n  igir move      Move ROM files from the input to output directory\n  igir link      Create links in the output directory to ROM files in the input directory\n  igir extract   Extract ROM files in archives when copying or moving\n  igir zip       Create zip archives of ROMs when copying or moving\n  igir playlist  Create playlist files for multi-disc games\n  igir test      Test ROMs for accuracy after writing them to the output directory\n  igir dir2dat   Generate a DAT from all input files\n  igir fixdat    Generate a fixdat of any missing games for every DAT processed (requires --da\n                 t)\n  igir clean     Recycle unknown files in the output directory\n  igir report    Generate a CSV report on the known &amp; unknown ROM files found in the input dir\n                 ectories (requires --dat)\n\nROM input options:\n  -i, --input                    Path(s) to ROM files or archives (supports globbing)  [array]\n  -I, --input-exclude            Path(s) to ROM files or archives to exclude from processing (\n                                 supports globbing)                                    [array]\n      --input-checksum-quick     Only read checksums from archive headers, don't decompress to\n                                  calculate                                          [boolean]\n      --input-checksum-min       The minimum checksum level to calculate and use for matching\n                                [choices: \"CRC32\", \"MD5\", \"SHA1\", \"SHA256\"] [default: \"CRC32\"]\n      --input-checksum-max       The maximum checksum level to calculate and use for matching\n                                                   [choices: \"CRC32\", \"MD5\", \"SHA1\", \"SHA256\"]\n      --input-checksum-archives  Calculate checksums of archive files themselves, allowing the\n                                 m to match files in DATs\n                                        [choices: \"never\", \"auto\", \"always\"] [default: \"auto\"]\n\nDAT input options:\n  -d, --dat                            Path(s) to DAT files or archives (supports globbing)\n                                                                                       [array]\n      --dat-exclude                    Path(s) to DAT files or archives to exclude from proces\n                                       sing (supports globbing)                        [array]\n      --dat-name-regex                 Regular expression of DAT names to process     [string]\n      --dat-name-regex-exclude         Regular expression of DAT names to exclude from process\n                                       ing                                            [string]\n      --dat-description-regex          Regular expression of DAT descriptions to process\n                                                                                      [string]\n      --dat-description-regex-exclude  Regular expression of DAT descriptions to exclude from\n                                       processing                                     [string]\n      --dat-combine                    Combine every game from every found &amp; filtered DAT into\n                                        one DAT                                      [boolean]\n      --dat-ignore-parent-clone        Ignore any parent/clone information found in DATs\n                                                                                     [boolean]\n\nPatch input options:\n  -p, --patch          Path(s) to ROM patch files or archives (supports globbing) (supported:\n                       .aps, .bps, .dps, .ebp, .ips, .ips32, .ppf, .rup, .ups, .vcdiff, .xdelt\n                       a)                                                              [array]\n  -P, --patch-exclude  Path(s) to ROM patch files or archives to exclude from processing (supp\n                       orts globbing)                                                  [array]\n\nROM output path options (processed in order):\n  -o, --output               Path to the ROM output directory (supports replaceable symbols, s\n                             ee below)                                                [string]\n      --dir-mirror           Use the input subdirectory structure for the output directory\n                                                                                     [boolean]\n      --dir-dat-mirror       Use the DAT subdirectory structure for the output directory\n                                                                                     [boolean]\n  -D, --dir-dat-name         Use the DAT name as the output subdirectory             [boolean]\n      --dir-dat-description  Use the DAT description as the output subdirectory      [boolean]\n      --dir-letter           Group games in an output subdirectory by the first --dir-letter-c\n                             ount letters in their name                              [boolean]\n      --dir-letter-count     How many game name letters to use for the subdirectory name\n                                                                         [number] [default: 1]\n      --dir-letter-limit     Limit the number of games in letter subdirectories, splitting int\n                             o multiple subdirectories if necessary                   [number]\n      --dir-letter-group     Group letter subdirectories into ranges, combining multiple lette\n                             rs together (requires --dir-letter-limit)               [boolean]\n      --dir-game-subdir      Append the name of the game as an output subdirectory depending o\n                             n its ROMs\n                                [choices: \"never\", \"multiple\", \"always\"] [default: \"multiple\"]\n\nROM writing options:\n      --fix-extension      Read files for known signatures and use the correct extension (also\n                            affects dir2dat)\n                                        [choices: \"never\", \"auto\", \"always\"] [default: \"auto\"]\n  -O, --overwrite          Overwrite any files in the output directory               [boolean]\n      --overwrite-invalid  Overwrite files in the output directory that are the wrong filesize\n                           , checksum, or zip contents                               [boolean]\n\nmove command options:\n      --move-delete-dirs  Delete empty subdirectories from the input directories after moving\n                          ROMs          [choices: \"never\", \"auto\", \"always\"] [default: \"auto\"]\n\nclean command options:\n  -C, --clean-exclude  Path(s) to files to exclude from cleaning (supports globbing)   [array]\n      --clean-backup   Directory to move cleaned files to (instead of being recycled) [string]\n      --clean-dry-run  Don't clean any files and instead only print what files would be cleane\n                       d                                                             [boolean]\n\nzip command options:\n      --zip-format    The structure format to use for written zip files\n                                     [choices: \"torrentzip\", \"rvzstd\"] [default: \"torrentzip\"]\n  -Z, --zip-exclude   Glob pattern of ROM filenames to exclude from zipping           [string]\n      --zip-dat-name  Group all ROMs from the same DAT into the same zip archive, if not exclu\n                      ded from zipping (enforces --dat-threads 1)                    [boolean]\n\nlink command options:\n      --link-mode         File linking mode\n                             [choices: \"hardlink\", \"symlink\", \"reflink\"] [default: \"hardlink\"]\n      --symlink-relative  Create symlinks as relative to the target path, as opposed to absolu\n                          te                                                         [boolean]\n\nROM header options:\n      --header          Glob pattern of input filenames to force header detection for [string]\n  -H, --remove-headers  Remove known headers from ROMs, optionally limited to a list of comma-\n                        separated file extensions (supported: .a78, .fds, .lnx, .nes, .smc)\n                                                                                      [string]\n\nTrimmed ROM options:\n      --trimmed-glob        Glob pattern of input filenames to force trimming detection for\n                                                                                      [string]\n      --trim-scan-archives  Detect trimming for files within archives (off by default)\n                                                                                     [boolean]\n\nROM set options (requires DATs):\n      --merge-roms             ROM merge/split mode (requires DATs with parent/clone informati\n                               on)\n         [choices: \"fullnonmerged\", \"nonmerged\", \"split\", \"merged\"] [default: \"fullnonmerged\"]\n      --merge-discs            Merge multi-disc games into one game                  [boolean]\n      --exclude-disks          Exclude CHD disks in DATs from processing &amp; writing   [boolean]\n      --allow-excess-sets      Allow writing archives that have excess files when not extracti\n                               ng or zipping                                         [boolean]\n      --allow-incomplete-sets  Allow writing games that don't have all of their ROMs [boolean]\n\nROM filtering options:\n  -x, --filter-regex           Regular expression of game names to filter to          [string]\n  -X, --filter-regex-exclude   Regular expression of game names to exclude            [string]\n  -L, --filter-language        List of comma-separated languages to filter to (supported: DA,\n                               DE, EL, EN, ES, FI, FR, IT, JA, KO, NL, NO, PT, RU, SV, ZH)\n                                                                                      [string]\n  -R, --filter-region          List of comma-separated regions to filter to (supported: ARG, A\n                               SI, AUS, BEL, BRA, CAN, CHN, DAN, EUR, FRA, FYN, GER, GRE, HK,\n                               HOL, ITA, JPN, KOR, MEX, NOR, NZ, POR, RUS, SPA, SWE, TAI, UK,\n                               UNK, USA, WORLD)                                       [string]\n      --filter-category-regex  Regular expression of categories to filter to          [string]\n      --no-bios                Filter out BIOS files, opposite of --only-bios        [boolean]\n      --no-device              Filter out MAME devies, opposite of --only-device     [boolean]\n      --no-unlicensed          Filter out unlicensed ROMs, opposite of --only-unlicensed\n                                                                                     [boolean]\n      --only-retail            Filter to only retail releases, enabling all the following \"no\"\n                                options                                              [boolean]\n      --no-debug               Filter out debug ROMs, opposite of --only-debug       [boolean]\n      --no-demo                Filter out demo ROMs, opposite of --only-demo         [boolean]\n      --no-beta                Filter out beta ROMs, opposite of --only-beta         [boolean]\n      --no-sample              Filter out sample ROMs, opposite of --only-sample     [boolean]\n      --no-prototype           Filter out prototype ROMs, opposite of --only-prototype\n                                                                                     [boolean]\n      --no-program             Filter out program application ROMs, opposite of --only-program\n                                                                                     [boolean]\n      --no-aftermarket         Filter out aftermarket ROMs, opposite of --only-aftermarket\n                                                                                     [boolean]\n      --no-homebrew            Filter out homebrew ROMs, opposite of --only-homebrew [boolean]\n      --no-unverified          Filter out unverified ROMs, opposite of --only-unverified\n                                                                                     [boolean]\n      --no-bad                 Filter out bad ROM dumps, opposite of --only-bad      [boolean]\n\nOne game, one ROM (1G1R) options:\n  -s, --single             Output only a single game per parent (1G1R) (required for all optio\n                           ns below, requires DATs with parent/clone information)    [boolean]\n      --prefer-game-regex  Regular expression of game names to prefer                 [string]\n      --prefer-rom-regex   Regular expression of ROM filenames to prefer              [string]\n      --prefer-verified    Prefer verified ROM dumps over unverified                 [boolean]\n      --prefer-good        Prefer good ROM dumps over bad                            [boolean]\n  -l, --prefer-language    List of comma-separated languages in priority order (supported: DA,\n                            DE, EL, EN, ES, FI, FR, IT, JA, KO, NL, NO, PT, RU, SV, ZH)\n                                                                                      [string]\n  -r, --prefer-region      List of comma-separated regions in priority order (supported: ARG,\n                           ASI, AUS, BEL, BRA, CAN, CHN, DAN, EUR, FRA, FYN, GER, GRE, HK, HOL\n                           , ITA, JPN, KOR, MEX, NOR, NZ, POR, RUS, SPA, SWE, TAI, UK, UNK, US\n                           A, WORLD)                                                  [string]\n      --prefer-revision    Prefer older or newer revisions, versions, or ring codes\n                                                                   [choices: \"older\", \"newer\"]\n      --prefer-retail      Prefer retail releases (see --only-retail)                [boolean]\n      --prefer-parent      Prefer parent ROMs over clones                            [boolean]\n\nplaylist command options:\n      --playlist-extensions  List of comma-separated file extensions to generate multi-disc pl\n                             aylists for             [string] [default: \".cue,.gdi,.mdf,.chd\"]\n\ndir2dat command options:\n      --dir2dat-output  dir2dat output directory                                      [string]\n\nfixdat command options:\n      --fixdat-output  Fixdat output directory                                        [string]\n\nreport command options:\n      --report-output  Report output file location (formatted with moment.js)\n                                    [string] [default: \"./igir_%YYYY-%MM-%DDT%HH:%mm:%ss.csv\"]\n\nHelp &amp; debug options:\n      --dat-threads     Number of DATs to process in parallel            [number] [default: 2]\n      --reader-threads  Maximum number of ROMs to read in parallel per disk\n                                                                         [number] [default: 8]\n      --writer-threads  Maximum number of ROMs to write in parallel      [number] [default: 4]\n      --write-retry     Number of additional retries to attempt when writing a file has failed\n                         (0 disables retries)                            [number] [default: 2]\n      --temp-dir        Path to a directory for temporary files                       [string]\n      --disable-cache   Disable loading or saving the cache file                     [boolean]\n      --cache-path      Location for the cache file                                   [string]\n  -v, --verbose         Enable verbose logging, can specify up to three times (-vvv)   [count]\n  -h, --help            Show help                                                    [boolean]\n\n----------------------------------------------------------------------------------------------\n\nAdvanced usage:\n\n  Tokens that are replaced when generating the output (--output) path of a ROM:\n    {datName}         The name of the DAT that contains the ROM (e.g. \"Nintendo - Game Boy\")\n    {datDescription}  The description of the DAT that contains the ROM\n    {region}          The region of the ROM release (e.g. \"USA\"), each ROM can have multiple\n    {language}        The language of the ROM release (e.g. \"En\"), each ROM can have multiple\n    {type}            The type of the game (e.g. \"Retail\", \"Demo\", \"Prototype\")\n    {category}        The DAT-defined category of the game (e.g. \"Games\", \"Demos\", \"Multimedia\n    \")\n    {genre}           The DAT-defined genre of the game\n\n    {inputDirname}    The input file's dirname\n    {outputBasename}  Equivalent to \"{outputName}.{outputExt}\"\n    {outputName}      The output file's filename without extension\n    {outputExt}       The output file's extension\n\n    {adam}      The ROM's emulator-specific /ROMS/* directory for the 'Adam' image (e.g. \"GB\")\n    {batocera}  The ROM's emulator-specific /roms/* directory for Batocera (e.g. \"gb\")\n    {es}        The ROM's emulator-specific /roms/* directory for the 'EmulationStation' image\n     (e.g. \"gb\")\n    {funkeyos}  The ROM's emulator-specific /* directory for FunKey OS (e.g. \"Game Boy\")\n    {jelos}     The ROM's emulator-specific /roms/* directory for JELOS (e.g. \"gb\")\n    {minui}     The ROM's emulator-specific /Roms/* directory for MinUI (e.g. \"Game Boy (GB)\")\n    {mister}    The ROM's core-specific /games/* directory for the MiSTer FPGA (e.g. \"Gameboy\"\n    )\n    {miyoocfw}  The ROM's emulator-specific /roms/* directory for MiyooCFW (e.g. \"GB\")\n    {onion}     The ROM's emulator-specific /Roms/* directory for OnionOS/GarlicOS (e.g. \"GB\")\n    {pocket}    The ROM's core-specific /Assets/* directory for the Analogue Pocket (e.g. \"gb\"\n    )\n    {retrodeck} The ROM's emulator-specific /roms/* directory for the 'RetroDECK' image (e.g.\n    \"gb\")\n    {romm}      The ROM's manager-specific /roms/* directory for 'RomM' (e.g. \"gb\")\n    {twmenu}    The ROM's emulator-specific /roms/* directory for TWiLightMenu++ on the DSi/3D\n    S (e.g. \"gb\")\n\nExample use cases:\n\n  Merge new ROMs into an existing ROM collection and delete any unrecognized files:\n    igir copy clean --dat \"*.dat\" --input New-ROMs/ --input ROMs/ --output ROMs/\n\n  Organize and zip an existing ROM collection:\n    igir move zip --dat \"*.dat\" --input ROMs/ --output ROMs/\n\n  Generate a report on an existing ROM collection, without copying or moving ROMs (read only):\n    igir report --dat \"*.dat\" --input ROMs/\n\n  Produce a 1G1R set per console, preferring English ROMs from USA&gt;WORLD&gt;EUR&gt;JPN:\n    igir copy --dat \"*.dat\" --input \"**/*.zip\" --output 1G1R/ --dir-dat-name --single --prefer\n    -language EN --prefer-region USA,WORLD,EUR,JPN\n\n  Copy all Mario, Metroid, and Zelda games to one directory:\n    igir copy --input ROMs/ --output Nintendo/ --filter-regex \"/(Mario|Metroid|Zelda)/i\"\n\n  Copy all BIOS files into one directory, extracting if necessary:\n    igir copy extract --dat \"*.dat\" --input \"**/*.zip\" --output BIOS/ --only-bios\n\n  Create playlist files for all multi-disc games in an existing collection:\n    igir playlist --input ROMs/\n\n  Create patched copies of ROMs in an existing collection, not overwriting existing files:\n    igir copy extract --input ROMs/ --patch Patches/ --output ROMs/\n\n  Re-build a MAME ROM set for a specific version of MAME:\n    igir copy zip --dat \"MAME 0.258.dat\" --input MAME/ --output MAME-0.258/ --merge-roms split\n\n  Copy ROMs to an Analogue Pocket and test they were written correctly:\n    igir copy extract test --dat \"*.dat\" --input ROMs/ --output /Assets/{pocket}/common/ --dir\n    -letter\n</code></pre>"}, {"location": "#feature-requests-bug-reports-and-contributing", "title": "Feature requests, bug reports, and contributing", "text": "<p>Feedback is a gift! Your feature requests and bug reports help improve the project for everyone. Feel free to submit an issue on GitHub using one of the templates.</p> <p>Even better, if you feel comfortable writing code, please feel free to submit a pull request against the project! Please see the full contribution guidelines for rules to follow.</p> <p></p> <p> </p> <p> </p>"}, {"location": "alternatives/", "title": "Alternative Managers", "text": "<p>There are a few different popular ROM managers that have similar features:</p> Feature igir RomVault clrmamepro RomCenter App: in active development \u2705 \u2705 \u2705 \u2753 App: OS compatibility \u2705 anything Node.js supports \u26a0\ufe0f Windows, macOS &amp; Linux via Mono \u26a0\ufe0f Windows, macOS &amp; Linux via Wine \u274c Windows only App: GUI or CLI CLI only by design Primarily GUI, with a separate CLI GUI only GUI only App: required setup steps \u2705 no setup required \u26a0\ufe0f if specifying DAT &amp; ROM dirs \u274c requires \"profile\" setup per DAT \u274c requires per-DAT DB setup App: open source \u2705 GPL v3 \u274c \u274c \u274c DATs: supported formats Logiqx XML, MAME ListXML, MAME Software List, CMPro, HTGD SMDB (DATs docs) Logiqx XML, MAME ListXML, CMPro, RomCenter, HTGD SMDB, Total DOS Logiqx XML, MAME ListXML, MAME Software List, CMPro Logiqx XML, CMPro, RomCenter DATs: process multiple at once \u2705 \u2705 \u26a0\ufe0f via the batcher \u274c DATs: infer parent/clone info \u2705 \u274c \u274c \u274c DATs: built-in download manager \u274c \u26a0\ufe0f via DatVault \u274c \u274c DATs: supports URLs to DATs \u2705 \u274c \u274c \u274c DATs: create from files (dir2dat) \u2705 dir2dat docs \u2753 \u2705 \u274c DATs: fixdat creation \u2705 fixdat docs \u2705 \u2705 \u274c DATs: combine multiple \u2705 \u2705 \u274c \u274c ROM Scanning: parallel scanning \u2705 \u274c \u2753 \u2753 ROM Scanning: scanning exclusions \u2705 \u274c \u2753 \u2753 ROM Scanning: quick scanning \u2705 matching docs \u2705 (scanning level 1) \u26a0\ufe0f by default \u2753 ROM Scanning: scan/checksum caching \u2705 \u2705 \u274c \u2705 ROMs: checksum matching strategies \u2705 CRC32+size, MD5, SHA1, SHA256 \u26a0\ufe0f CRC32+size, MD5, SHA1 \u26a0\ufe0f CRC32+size, MD5, SHA1 \u2753 ROMs: header detection \u2705 \u2705 \u26a0\ufe0f via supplemental XMLs \u26a0\ufe0f via plugins ROMs: header removal \u2705 automatic and forced \u26a0\ufe0f if configured \u274c \u274c ROMs: trimming detection &amp; matching \u2705 trimming docs \u274c \u274c \u274c ROMs: automatic extension correction \u2705 output writing docs \u274c \u274c \u274c ROMs: patching support \u2705 many formats (patching docs) \u274c \u274c \u274c Arcade: supported merge types \u2705 full non-merged, non-merged, split, merged (arcade docs) \u26a0\ufe0f full non-merged, split, merged \u2705 full non-merged, non-merged, split, merged \u26a0\ufe0f full non-merged, split, merged Arcade: CHD disk inclusion \u2705 by default, can be turned off (arcade docs) \u2705 by default, can be turned off \u2753 \u2753 Arcade: sample inclusion \u274c \u274c \u2705 \u2753 Archives: common formats support \u2705 <code>.zip</code> (incl. zstd), <code>.7z</code> (via <code>7za</code>), <code>.gz</code>, <code>.rar</code>, <code>.tar</code>, and more (docs) \u26a0\ufe0f <code>.zip</code> (incl. zstd), <code>.7z</code> (natively) \u26a0\ufe0f <code>.zip</code>, <code>.7z</code> (via <code>7z</code>), <code>.rar</code> (via <code>rar</code>) \u26a0\ufe0f <code>.zip</code>, <code>.7z</code> Archives: <code>.chd</code> support \u26a0\ufe0f via <code>chdman</code><sup>1</sup> (bundled) \u2705 v1-5 natively \u26a0\ufe0f via <code>chdman</code><sup>1</sup> \u26a0\ufe0f v1-4 natively Archives: <code>.cso</code> &amp; <code>.zso</code> support \u26a0\ufe0f via <code>maxcso</code> (bundled) \u274c \u274c \u274c Archives: <code>.gcz</code>, <code>.rvz</code>, &amp; <code>.wia</code> support \u26a0\ufe0f via <code>dolphin-tool</code> (bundled) \u274c \u274c \u274c Archives: <code>.nkit.iso</code> support \u26a0\ufe0f matching but no extraction/inflation (GameCube docs) \u274c \u274c \u274c Archives: creation formats \u274c <code>.zip</code> (TorrentZip, RVZSTD) only by design (writing archives docs) \u2705 <code>.zip</code> (TorrentZip, RVZSTD, Total DOS), <code>.7z</code> (LZMA, zstd) \u26a0\ufe0f <code>.zip</code> (TorrentZip), <code>.7z</code>, <code>.rar</code> \u26a0\ufe0f <code>.zip</code>, <code>.7z</code> Archives: contents checksums \u2705 when needed (reading archives docs) \u26a0\ufe0f requires \"files only\" mode or directory \u26a0\ufe0f if DAT has forcepacking=unzip \u2753 Archives: automatic extension correction \u2705 \u274c \u274c \u274c Filtering: region, language, type, etc. \u2705 many options \u274c \u274c only 1G1R options \u26a0\ufe0f only at DB setup Filtering: 1G1R support \u2705 many options \u274c \u26a0\ufe0f region &amp; language only \u26a0\ufe0f only at DB setup Playlists: creation support \u2705 playlists docs \u274c \u274c \u274c Reports: report-only mode \u2705 \u2705 \u2705 \u2705 Reports: machine parseable \u2705 CSV \u26a0\ufe0f newline-separated \"full\" &amp; \"fix\" reports \u26a0\ufe0f newline-separated \"have\" &amp; \"miss\" lists \u26a0\ufe0f newline-separated \"have\" &amp; \"miss\" lists Output: file link support \u2705 hard links, symlinks, and reflinks \u274c \u274c \u274c Output: separate input &amp; output dirs \u2705 \u26a0\ufe0f yes but files are always moved \u274c \u274c Output: subdirectory customization \u2705 many options \u26a0\ufe0f depends on DAT organization \u274c \u274c Output: create single archive for DAT \u2705 \u2705 \u274c \u274c <p> <sup>1</sup> may require you to install SDL2 manually, see the chdman-js README. </p> <p>Note</p> <p>Just like Igir, other ROM managers that are in active development are likely to release new features often. The above table is not guaranteed to be perfectly up-to-date, it is just a best effort.</p> <p>There are some other managers omitted from the table above because they focus more on visual presentation and in-browser/app emulation than they do organization:</p> <ul> <li>RomM</li> <li>Retrom</li> <li>Gaseous</li> </ul> <p>Lists of other ROM managers can be found in a number of other wikis, such as:</p> <ul> <li>Emulation General Wiki</li> <li>Pleasuredome's \"Retro Arcade Guides\"</li> <li>Recalbox</li> <li>RetroPie</li> </ul>"}, {"location": "alternatives/#migrating-from-romvault", "title": "Migrating from RomVault", "text": "<p>The majority of RomVault's functionality also exists in Igir. Here is how users of RomVault can achieve the same default behavior in Igir.</p> <p>Given a typical RomVault directory structure that looks something like:</p> <pre><code>ROMVault_V3.7.4/\n\u251c\u2500\u2500 DatRoot\n\u2502   \u251c\u2500\u2500 No-Intro Love Pack (PC) (2025-05-09)\n\u2502   \u2502   \u251c\u2500\u2500 No-Intro\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Sega - Game Gear (Parent-Clone) (20241203-185356).dat\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Sega - Master System - Mark III (Parent-Clone) (20241225-050512).dat\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Sega - Mega Drive - Genesis (Parent-Clone) (20250210-102212).dat\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 ...\n\u2502   \u2502   \u2514\u2500\u2500 Non-Redump\n\u2502   \u2502       \u251c\u2500\u2500 Non-Redump - Nintendo - Nintendo GameCube (Parent-Clone) (20250118-063947).dat\n\u2502   \u2502       \u251c\u2500\u2500 Non-Redump - Nintendo - Wii (Parent-Clone) (20241203-105832).dat\n\u2502   \u2502       \u251c\u2500\u2500 Non-Redump - Nintendo - Wii U (Parent-Clone) (20231229-065143).dat\n\u2502   \u2502       \u2514\u2500\u2500 ...\n\u2502   \u2514\u2500\u2500 Redump (2025-05-09)\n\u2502       \u251c\u2500\u2500 Sony - PlayStation - Datfile (10853) (2025-05-09 17-16-34).dat\n\u2502       \u251c\u2500\u2500 Sony - PlayStation 2 - Datfile (11623) (2025-05-09 15-01-56).dat\n\u2502       \u251c\u2500\u2500 Sony - PlayStation - Datfile (10853) (2025-05-09 17-16-34).dat\n\u2502       \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 RomRoot\n\u2502   \u251c\u2500\u2500 No-Intro Love Pack (PC) (2025-05-09)\n\u2502   \u2502   \u251c\u2500\u2500 No-Intro\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 ...\n\u2502   \u2502   \u2514\u2500\u2500 Non-Redump\n\u2502   \u2502       \u2514\u2500\u2500 ...\n\u2502   \u2514\u2500\u2500 Redump (2025-05-09)\n\u2502       \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 ROMVault37.exe\n\u2514\u2500\u2500 ToSort\n    \u2514\u2500\u2500 ...\n</code></pre> <p>here is how you can perform each RomVault action in Igir:</p> <ol> <li> <p>Update DATs</p> <p>The equivalent action in Igir is to scan for DATs using the <code>--dat &lt;path&gt;</code> option when performing some command.</p> <p>Igir does not cache parsed DATs like RomVault does, which requires fewer setup actions, but at the expense of needing to parse DAT files during every run.</p> </li> <li> <p>Scan ROMs</p> <p>The equivalent action in Igir is to scan for ROMs using the <code>--input &lt;path&gt;</code> option when performing some command. You will need to provide both the unsorted (\"ToSort\") and sorted (\"RomRoot\") directories as inputs.</p> <p>RomVault's default \"level 2\" scan level can be achieved with the <code>--input-checksum-min SHA1</code> option (not recommended).</p> </li> <li> <p>Find fixes</p> <p>This is done when writing ROMs or generating some kind of report (below).</p> </li> <li> <p>Fix ROMs</p> <p>The equivalent Igir action is to move missing ROMs from an input directory (<code>--input &lt;path&gt;</code> option) to the output directory (<code>--output &lt;path&gt;</code> option) using the <code>igir move</code> command.</p> <p>RomVault writes TorrentZip archives by default, and it will overwrite files that are not in the TorrentZip structure. This can be achieved with a combination of the <code>igir zip</code> command, the <code>--zip-format torrentzip</code> option (default), and the <code>--overwrite-invalid</code> option. Igir does not offer a way to create 7zip archives like RomVault does.</p> <p>By default, RomVault writes \"incomplete\" sets of ROMs. It will write archives when at least one ROM for a game is present, even if not every ROM is found. Igir does not do this by default as incomplete sets are unlikely to be playable. However, you can enable this behavior with the <code>--allow-incomplete-sets</code> option.</p> <p>RomVault respects the directory structure of DATs and \"mirrors\" it in the sorted directory (\"RomRoot\"). This can be achieved with a combination of the <code>--dir-dat-mirror</code> and <code>--dir-dat-name</code> options.</p> <p>During writing, RomVault will move unmatched files in the sorted directory (\"RomRoot\") to the unsorted directory (\"ToSort\"). This can be achieved with a combination of the <code>igir clean</code> command and the <code>--clean-backup &lt;path&gt;</code> option.</p> </li> <li> <p>Generate reports</p> <p>The equivalent Igir action is the <code>igir report</code> command.</p> </li> </ol> <p>Tying it all together, the Igir command to achieve the same behavior as RomVault's defaults is:</p>  Windows macOS Linux <pre><code>igir move zip clean ^\n  --input \"ToSort\\\" ^\n  --input \"RomRoot\\\" ^\n  --input-checksum-min SHA1 ^\n  --dat \"DatRoot\\\" ^\n  --output \"RomRoot\\\" ^\n  --dir-dat-mirror ^\n  --dir-dat-name ^\n  --overwrite-invalid ^\n  --clean-backup \"ToSort\\\" ^\n  --zip-format torrentzip ^\n  --merge-roms fullnonmerged ^\n  --allow-incomplete-sets ^\n  -v\n</code></pre> <pre><code>igir move zip clean \\\n  --input \"ToSort/\" \\\n  --input \"RomRoot/\" \\\n  --input-checksum-min SHA1 \\\n  --dat \"DatRoot/\" \\\n  --output \"RomRoot/\" \\\n  --dir-dat-mirror \\\n  --dir-dat-name \\\n  --overwrite-invalid \\\n  --clean-backup \"ToSort/\" \\\n  --zip-format torrentzip \\\n  --merge-roms fullnonmerged \\\n  --allow-incomplete-sets \\\n  -v\n</code></pre> <pre><code>igir move zip clean \\\n  --input \"ToSort/\" \\\n  --input \"RomRoot/\" \\\n  --input-checksum-min SHA1 \\\n  --dat \"DatRoot/\" \\\n  --output \"RomRoot/\" \\\n  --dir-dat-mirror \\\n  --dir-dat-name \\\n  --overwrite-invalid \\\n  --clean-backup \"ToSort/\" \\\n  --zip-format torrentzip \\\n  --merge-roms fullnonmerged \\\n  --allow-incomplete-sets \\\n  -v\n</code></pre> <p>Note</p> <p>Writing and rewriting ROMs with Igir or RomVault is likely to invalidate the file cache of the other tool.</p> <p>Note</p> <p>Igir does not currently offer an alternative to RomVault's subscription-based DATVault DAT downloader.</p>"}, {"location": "cli/", "title": "CLI Overview", "text": "<p>Igir uses a series of live-updating progress bars to indicate what it is currently working on and how much processing is left to do.</p> <p>See the internal operations page for more information on every processing that Igir might do.</p>"}, {"location": "cli/#progress-bar-icons", "title": "Progress bar icons", "text": "<p>ASCII symbols are used to indicate what processing is happening. Here is a table of those symbols, in order:</p> Symbol (magenta) Scanning operation \u21bb (circle arrow) Files (DATs, ROMs, patches, etc.) are being found/enumerated \u2193 (down arrow) DATs are being downloaded \u03a3 (sigma) DATs are being parsed # (hash) ROMs are having checksums calculated for matching ^ (hat) ROMs are being checked for headers Symbol (cyan) Per-DAT processing operation \u2229 (intersection) DATs are having parent/clone information inferred \u2194 (left/right arrows) DATs are having merge/split rules applied \u2206 (delta) DAT is being filtered \u21c5 (up/down arrows) ROM 1G1R rules are being applied \u03a3 (sigma) ROMs are being matched to the DAT . (period) ROM matches are having their extension corrected \u225f (question equal) ROM matches are being checked for issues \u222a (union) ROM matches are being combined into one zip Symbol (yellow) Per-DAT writing operation # (hash) Archives are having checksums calculated to test after writing \u225f (question equal) Output files are being checked before being overwritten, no writing has started yet \u270e (pencil) Output files are or have been written Symbol Deleting operation \u267b (recycle) Output directory cleaned files are being recycled \u2715 (x) Moved ROM matches are being deleted, output directory cleaned files are being deleted"}, {"location": "commands/", "title": "Commands", "text": "<p>Igir takes actions based on commands you specify. Each command has a clear input and output, and Igir will never take surprise actions you did not specify. Multiple commands can (and will likely) be specified at once.</p> <p>Tip</p> <p>See the <code>igir --help</code> message for the list of all commands and options, as well as some examples.</p>"}, {"location": "commands/#rom-writing", "title": "ROM writing", "text": "<p>Igir has three writing commands. Only one writing command can be specified at a time, and all require the <code>--output &lt;path&gt;</code> option.</p>"}, {"location": "commands/#copy", "title": "<code>copy</code>", "text": "<p>Copy files from an input directory to the output directory.</p> <p>Files in the input directories will be left alone, they will not be modified or deleted.</p>"}, {"location": "commands/#move", "title": "<code>move</code>", "text": "<p>Move files from an input directory to the output directory. The same directory can be specified for both input &amp; output, resulting in ROMs being renamed as their names change in DATs.</p> <p>Files that match to multiple ROMs in DATs will be copied as needed.</p>"}, {"location": "commands/#link", "title": "<code>link</code>", "text": "<p>Create a link in the output directory to a file in the input directory.</p> <p>Three different types of links can be created:</p> Link mode Description What happens when the source file is deleted Hard link<code>--link-mode hardlink</code> (default) The link file and source file are the exact same file on disk. If either file is changed then all other hard linked files will also reflect those changes.Supported by most filesystems other than FAT, FAT16, FAT32, and exFAT. \u2705 The linked file isn't changed in any way. Symbolic link (\"symlink\")<code>--link-mode symlink</code> The link file is a shortcut to the source file. Symlinks generally require administrator privileges on Windows.Supported by most filesystems other than FAT, FAT16, FAT32, and exFAT. \u274c The linked file's shortcut is broken, which will cause issues with reading or writing. Reflink (copy-on-write)<code>--link-mode reflink</code> The link file and source file will be the same file on disk, until any data is changed, at which point the source file is copied to the link location.Supported by APFS (macOS) and some Linux filesystems. \u2705 The linked file isn't changed in any way."}, {"location": "commands/#rom-extracting-zipping", "title": "ROM extracting &amp; zipping", "text": "<p>Igir has two ROM archive commands. Archive commands require either the <code>copy</code> or <code>move</code> write command. Only one archive command can be specified at a time.</p> <p>If no archive command is specified, files will be left as-is. If they are already extracted, then they will stay extracted. If they are already archived (including non-<code>.zip</code> archives), then they will stay archived in their original format.</p> <p>Note</p> <p>See the archives page for more information on supported archive types.</p>"}, {"location": "commands/#extract", "title": "<code>extract</code>", "text": "<p>ROMs will be extracted from archives as they are being copied or moved. ROMs from the same game will be placed into a subdirectory together.</p> <p>Input ROMs that are not archived will be copied as-is.</p>"}, {"location": "commands/#zip", "title": "<code>zip</code>", "text": "<p>ROMs will be archived into a <code>.zip</code> file as they are being copied or moved. ROMs from the same game will be put into the same <code>.zip</code> file.</p> <p>ROMs that are already in an archive will be re-archived.</p> <p>Note</p> <p>You can use the <code>--dat-combine</code> option to cause every ROM in a DAT to be zipped together.</p>"}, {"location": "commands/#playlist", "title": "<code>playlist</code>", "text": "<p>Create <code>.m3u</code> playlist files for multi-disc games. See the playlists page for more information.</p>"}, {"location": "commands/#rom-verification", "title": "ROM verification", "text": ""}, {"location": "commands/#test", "title": "<code>test</code>", "text": "<p>When writing ROMs (above commands), verify that each file was written correctly.</p> <ul> <li><code>extract test</code> tests that each ROM file written has the correct size and checksum</li> <li><code>zip test</code> tests that the <code>.zip</code> file has all the correct archive entry sizes &amp; checksums, and contains no excess entries</li> </ul> <p>When not writing ROMs, verify that each input file is valid.</p>"}, {"location": "commands/#dat-writing", "title": "DAT writing", "text": ""}, {"location": "commands/#dir2dat", "title": "<code>dir2dat</code>", "text": "<p>Creates a DAT from scanned ROM files. See the dir2dat page for more information.</p>"}, {"location": "commands/#fixdat", "title": "<code>fixdat</code>", "text": "<p>Creates a DAT from missing ROM files. See the fixdat page for more information.</p>"}, {"location": "commands/#file-manipulation", "title": "File manipulation", "text": ""}, {"location": "commands/#clean", "title": "<code>clean</code>", "text": "<p>Files in the output directory that do not match any ROM in any DAT will be deleted.</p> <p>See the output cleaning page for more information.</p>"}, {"location": "commands/#rom-reporting", "title": "ROM reporting", "text": ""}, {"location": "commands/#report", "title": "<code>report</code>", "text": "<p>A report will be generated of what input files were matched by what DAT, and what games in what DATs have missing ROMs.</p> <p>See the reporting page for more information.</p>"}, {"location": "contributing/", "title": "Contribution Guidelines", "text": "<p>Welcome! If you're viewing this, it means that you're likely interested in contributing to the project. That's fantastic!</p> <p>The following is a set of guidelines for contributing to Igir. These guidelines are published to clarify expectations and reduce potential conflict of opinions.</p>"}, {"location": "contributing/#feature-requests-bug-reports", "title": "\ud83d\udca1 Feature requests &amp; bug reports", "text": "<p>Feedback is a gift! Your feature requests and bug reports help improve the project for everyone.</p> <p>If you have an idea for a new feature, please search for if an active issue already exists. If an existing issue doesn't already exist, please submit a detailed feature request in GitHub. If you're not sure if your idea is ready for a full request, feel free to start a discussion in GitHub for feedback instead - it can always be turned into a feature request later!</p> <p>If you are experiencing an issues, please submit a detailed bug report in GitHub.</p>"}, {"location": "contributing/#discussions", "title": "\ud83d\udcac Discussions", "text": "<p>GitHub discussions are a great tool for a number of topics:</p> <ul> <li>Getting help with Igir CLI syntax or usage</li> <li>Clarifying support for specific features or scenarios</li> <li>Brainstorming new feature requests</li> <li>...and more!</li> </ul> <p>Discussions are intended to be low-pressure spaces for questions and collaboration, please feel free to use them openly!</p>"}, {"location": "contributing/#coding-standards", "title": "\ud83d\udcd0 Coding standards", "text": "<p>Igir is written in TypeScript. Why TypeScript and not something compiled? Mainly because of the maintainer's familiarity, JavaScript's popularity, and JavaScript's ecosystem of available libraries. Much of the more CPU-intensive operations such as calculating checksums is handled by low-level libraries anyway.</p> <p>TypeScript can have a lot of flaws, though, so here are the tenets that Igir abides by:</p> <ul> <li>Version: the TypeScript version is kept up to date automatically.</li> <li><code>target</code> and <code>module</code>: is set to the newest version that the minimum Node.js version supports.</li> <li>Typing: the use of <code>any</code> is disallowed and <code>unknown</code> is only used where necessary. There is little point in using TypeScript if you don't require strict typing everywhere.</li> <li>Erasable syntax: the TypeScript config is set to allow erasable syntax only with the hope that future Node.js versions will support TypeScript without the need for transpiling.</li> </ul> <p>Igir also abides by these Node.js tenets:</p> <ul> <li>Current version: is kept up to date automatically with whatever major LTS version is in active support.</li> <li>Minimum version: automated tests will guarantee support with the oldest major LTS version still in security support.</li> </ul>"}, {"location": "contributing/#code-style", "title": "Code style", "text": "<p>Igir uses ESLint as its linter and Prettier as its style enforcer. Rules have been specifically chosen to increase code consistency, safety, readability, and maintainability.</p> <p>All code changes must pass the existing ESLint rules. Discussions on adding, removing, and changing ESLint rules should happen outside of pull requests that contain code changes, in their own dedicated pull request or discussion thread (above).</p>"}, {"location": "contributing/#code-contributions", "title": "\ud83e\udef4 Code contributions", "text": ""}, {"location": "contributing/#environment-setup", "title": "Environment setup", "text": "<p>First, you will want to check out Igir's source code from GitHub:</p> <pre><code>git clone --recurse-submodules https://github.com/emmercm/igir.git\n</code></pre> <p>Igir is written in TypeScript for the Node.js runtime. The current version of Node.js that Igir uses is defined under the <code>\"volta\"</code> object in the <code>package.json</code> file. After installing, Volta will make sure you're always using the correct Node.js version.</p> <p>Third-party dependencies are managed and easily installed with npm:</p> <pre><code>npm install\n</code></pre> <p>Scripts are defined for common npm commands:</p> <pre><code>npm start -- [arguments..]\nnpm test\nnpm pack\n</code></pre>"}, {"location": "contributing/#running-code", "title": "Running code", "text": "<p>A script has been defined for the <code>npm start</code> command to easily run Igir:</p> <pre><code>npm start -- [commands..] [options]\n</code></pre> <p>for example:</p> <pre><code>npm start -- report --dat *.dat --input ROMs/\n</code></pre>"}, {"location": "contributing/#automated-tests", "title": "Automated tests", "text": "<p>Igir uses Jest as its testing framework, and it uses Codecov to ensure a minimum amount of test coverage.</p> <p>All code changes must come with appropriate automated tests to prove correctness and to protect against future regressions.</p>"}, {"location": "contributing/#docs", "title": "Docs", "text": "<p>Igir uses MkDocs to turn Markdown files into a documentation website.</p> <p>Appropriate updates must be made to all relevant documentation pages if functionality is added, removed, or changed.</p>"}, {"location": "contributing/#git-commit-messages", "title": "Git commit messages", "text": "<p>Igir is configured to squash-merge all pull requests, such that only the pull request title ends up in the commit history of the main branch. This means that individual commit messages are less important, and it puts more emphasis on quality pull request titles &amp; descriptions.</p> <p>That said, quality commit messages help future maintainers understand past intentions. Please use your best judgement on descriptive, clear, and concise commit messages.</p>"}, {"location": "contributing/#pull-request-checklist", "title": "Pull request checklist", "text": "<p>Here are steps that should be completed before submitting a pull request:</p> <ul> <li> Validate your change works as expected locally by running Igir (not just the unit tests)</li> <li> Unit tests have been added to cover your change</li> <li> <code>npm test</code> has been run locally for your change, to validate:<ul> <li>Your added and changed tests are passing</li> <li>Your added and changed code adheres to the linter settings</li> </ul> </li> <li> Appropriate docs have been added or changed for your change</li> <li> Your branch has no conflicts with the main (destination) branch</li> </ul>"}, {"location": "contributing/#pull-requests", "title": "Pull requests", "text": "<p>To contribute code changes, you will need to:</p> <ol> <li>Fork the repository</li> <li>Create a new branch in your copy of the repository</li> <li>Make any intended changes</li> <li>Complete the above pull request checklist</li> <li>Create a pull request, complete with a meaningful title and description</li> <li>Ensure that all GitHub status checks are passing, otherwise address the related issue(s)<ol> <li>Running tests in GitHub may require maintainer approval</li> </ol> </li> </ol>"}, {"location": "contributing/#license", "title": "\u2696\ufe0f License", "text": "<p>Igir is licensed under GNU General Public License v3.0.</p> <p>\u2705 That means that Igir can be used for free commercially, can be modified, can be distributed, and can be used for private use.</p> <p>\u26a0\ufe0f But it also means that distribution of closed-source versions is not allowed.</p>"}, {"location": "installation/", "title": "Installation", "text": "<p>Igir is supported on  Windows,  macOS,  Linux, and every other operating system that Node.js supports.</p> <p>There are a few different installation options offered for Igir with varying levels of technical complexity. Every option will require some baseline understanding of command-line interfaces (CLIs).</p>"}, {"location": "installation/#via-nodejs", "title": "Via Node.js", "text": "<p>The best way to ensure that you are always running the most up-to-date version of Igir is to run it via <code>npx</code> which comes installed with Node.js:</p> <pre><code>npx igir@latest [commands..] [options]\n</code></pre> <p>for example:</p> <pre><code>npx igir@latest copy extract --dat *.dat --input ROMs/ --output ROMs-Sorted/ --dir-dat-name\n</code></pre> <p>Tip</p> <p>You can alias the Igir <code>npx</code> command in your macOS or Linux dotfiles like this:</p>  macOS Linux <pre><code>alias igir=\"npx igir@latest\"\n</code></pre> <pre><code>alias igir=\"npx igir@latest\"\n</code></pre> <p>Note</p> <p>If you want to help beta test Igir, you can run the most bleeding-edge version with the command:</p> <pre><code>npm exec --yes -- \"github:emmercm/igir#main\" [commands..] [options]\n</code></pre>"}, {"location": "installation/#via-homebrew-macos", "title": "Via Homebrew (macOS)", "text": "<p>Homebrew is a third-party package manager for macOS. You can install Igir with these simple commands:</p> <pre><code>brew tap emmercm/igir\nbrew install igir\n</code></pre> <p>and then run Igir as if it were any other executable:</p> <pre><code>igir copy extract --dat *.dat --input ROMs/ --output ROMs-Sorted/ --dir-dat-name\n</code></pre> <p>Igir can then be updated with either of these commands</p> <pre><code># Update every Homebrew package\nbrew update\n\n# Update only igir\nbrew upgrade igir\n</code></pre>"}, {"location": "installation/#via-downloaded-executable", "title": "Via downloaded executable", "text": "<p>If you don't want to download Node.js, you can download executables for various OSes from the GitHub releases page.</p>"}, {"location": "introduction/", "title": "Introduction", "text": ""}, {"location": "introduction/#what-is-a-rom", "title": "What is a ROM?", "text": "<p>From Wikipedia:</p> <p>A ROM image, or ROM file, is a computer file which contains a copy of the data from a read-only memory chip, often from a video game cartridge, or used to contain a computer's firmware, or from an arcade game's main board. The term is frequently used in the context of emulation, whereby older games or firmware are copied to ROM files on modern computers and can, using a piece of software known as an emulator, be run on a different device than which they were designed for.</p> <p>ROMs are complete copies of game data stored on ROM chips (in cartridges or in arcade cabinets) or on discs.</p> <p>A game may consist of multiple ROMs. For example, arcade cabinets frequently contain multiple chips, and disc-based games that have multiple tracks on the disc.</p>"}, {"location": "introduction/#what-is-a-rom-manager", "title": "What is a ROM manager?", "text": "<p>ROM managers are applications that serve two main purposes:</p> <ol> <li>Help you organize your video game ROM collection</li> <li>Help you understand what video game ROMs are missing from your collection</li> </ol> <p>all additional features help serve these two purposes.</p> <p>Most ROM managers can automatically read &amp; write many different ROM types, including those in archives and those with headers so that you don't have to do much pre-work.</p> <p>Most ROM managers rely on DATs, files that catalog every known ROM that exists per game system. DATs are published by release groups dedicated to keeping these catalogs accurate and up to date. DATs help ROM collectors name their ROMs consistently as well as understand what ROMs may be missing from their collection.</p>"}, {"location": "introduction/#what-is-igir", "title": "What is Igir?", "text": "<p>Igir is a ROM manager for the modern age.</p> <p>Most ROM managers are only built for Windows, though some offer workarounds for running on macOS and Linux. Most of these managers have confusing GUIs that make batch-able, repeatable actions difficult. Igir is a command line tool that works on any OS.</p> <p>In addition, Igir has features that aren't found in any other ROM managers, such as ROM patching, multi-disc playlist creation, and ROM extension correction.</p> <p>Info</p> <p>See the alternative managers page for a feature comparison between Igir and other ROM managers.</p>"}, {"location": "introduction/#next-steps", "title": "Next steps", "text": "<p>See the installation page for instructions on getting Igir installed.</p>"}, {"location": "license/", "title": "License", "text": "<pre><code>                GNU GENERAL PUBLIC LICENSE\n                   Version 3, 29 June 2007\n</code></pre> <p>Copyright (C) 2007 Free Software Foundation, Inc. https://fsf.org/  Everyone is permitted to copy and distribute verbatim copies  of this license document, but changing it is not allowed.</p> <pre><code>                        Preamble\n</code></pre> <p>The GNU General Public License is a free, copyleft license for software and other kinds of works.</p> <p>The licenses for most software and other practical works are designed to take away your freedom to share and change the works.  By contrast, the GNU General Public License is intended to guarantee your freedom to share and change all versions of a program--to make sure it remains free software for all its users.  We, the Free Software Foundation, use the GNU General Public License for most of our software; it applies also to any other work released this way by its authors.  You can apply it to your programs, too.</p> <p>When we speak of free software, we are referring to freedom, not price.  Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for them if you wish), that you receive source code or can get it if you want it, that you can change the software or use pieces of it in new free programs, and that you know you can do these things.</p> <p>To protect your rights, we need to prevent others from denying you these rights or asking you to surrender the rights.  Therefore, you have certain responsibilities if you distribute copies of the software, or if you modify it: responsibilities to respect the freedom of others.</p> <p>For example, if you distribute copies of such a program, whether gratis or for a fee, you must pass on to the recipients the same freedoms that you received.  You must make sure that they, too, receive or can get the source code.  And you must show them these terms so they know their rights.</p> <p>Developers that use the GNU GPL protect your rights with two steps: (1) assert copyright on the software, and (2) offer you this License giving you legal permission to copy, distribute and/or modify it.</p> <p>For the developers' and authors' protection, the GPL clearly explains that there is no warranty for this free software.  For both users' and authors' sake, the GPL requires that modified versions be marked as changed, so that their problems will not be attributed erroneously to authors of previous versions.</p> <p>Some devices are designed to deny users access to install or run modified versions of the software inside them, although the manufacturer can do so.  This is fundamentally incompatible with the aim of protecting users' freedom to change the software.  The systematic pattern of such abuse occurs in the area of products for individuals to use, which is precisely where it is most unacceptable.  Therefore, we have designed this version of the GPL to prohibit the practice for those products.  If such problems arise substantially in other domains, we stand ready to extend this provision to those domains in future versions of the GPL, as needed to protect the freedom of users.</p> <p>Finally, every program is threatened constantly by software patents. States should not allow patents to restrict development and use of software on general-purpose computers, but in those that do, we wish to avoid the special danger that patents applied to a free program could make it effectively proprietary.  To prevent this, the GPL assures that patents cannot be used to render the program non-free.</p> <p>The precise terms and conditions for copying, distribution and modification follow.</p> <pre><code>                   TERMS AND CONDITIONS\n</code></pre> <p>0. Definitions.</p> <p>\"This License\" refers to version 3 of the GNU General Public License.</p> <p>\"Copyright\" also means copyright-like laws that apply to other kinds of works, such as semiconductor masks.</p> <p>\"The Program\" refers to any copyrightable work licensed under this License.  Each licensee is addressed as \"you\".  \"Licensees\" and \"recipients\" may be individuals or organizations.</p> <p>To \"modify\" a work means to copy from or adapt all or part of the work in a fashion requiring copyright permission, other than the making of an exact copy.  The resulting work is called a \"modified version\" of the earlier work or a work \"based on\" the earlier work.</p> <p>A \"covered work\" means either the unmodified Program or a work based on the Program.</p> <p>To \"propagate\" a work means to do anything with it that, without permission, would make you directly or secondarily liable for infringement under applicable copyright law, except executing it on a computer or modifying a private copy.  Propagation includes copying, distribution (with or without modification), making available to the public, and in some countries other activities as well.</p> <p>To \"convey\" a work means any kind of propagation that enables other parties to make or receive copies.  Mere interaction with a user through a computer network, with no transfer of a copy, is not conveying.</p> <p>An interactive user interface displays \"Appropriate Legal Notices\" to the extent that it includes a convenient and prominently visible feature that (1) displays an appropriate copyright notice, and (2) tells the user that there is no warranty for the work (except to the extent that warranties are provided), that licensees may convey the work under this License, and how to view a copy of this License.  If the interface presents a list of user commands or options, such as a menu, a prominent item in the list meets this criterion.</p> <p>1. Source Code.</p> <p>The \"source code\" for a work means the preferred form of the work for making modifications to it.  \"Object code\" means any non-source form of a work.</p> <p>A \"Standard Interface\" means an interface that either is an official standard defined by a recognized standards body, or, in the case of interfaces specified for a particular programming language, one that is widely used among developers working in that language.</p> <p>The \"System Libraries\" of an executable work include anything, other than the work as a whole, that (a) is included in the normal form of packaging a Major Component, but which is not part of that Major Component, and (b) serves only to enable use of the work with that Major Component, or to implement a Standard Interface for which an implementation is available to the public in source code form.  A \"Major Component\", in this context, means a major essential component (kernel, window system, and so on) of the specific operating system (if any) on which the executable work runs, or a compiler used to produce the work, or an object code interpreter used to run it.</p> <p>The \"Corresponding Source\" for a work in object code form means all the source code needed to generate, install, and (for an executable work) run the object code and to modify the work, including scripts to control those activities.  However, it does not include the work's System Libraries, or general-purpose tools or generally available free programs which are used unmodified in performing those activities but which are not part of the work.  For example, Corresponding Source includes interface definition files associated with source files for the work, and the source code for shared libraries and dynamically linked subprograms that the work is specifically designed to require, such as by intimate data communication or control flow between those subprograms and other parts of the work.</p> <p>The Corresponding Source need not include anything that users can regenerate automatically from other parts of the Corresponding Source.</p> <p>The Corresponding Source for a work in source code form is that same work.</p> <p>2. Basic Permissions.</p> <p>All rights granted under this License are granted for the term of copyright on the Program, and are irrevocable provided the stated conditions are met.  This License explicitly affirms your unlimited permission to run the unmodified Program.  The output from running a covered work is covered by this License only if the output, given its content, constitutes a covered work.  This License acknowledges your rights of fair use or other equivalent, as provided by copyright law.</p> <p>You may make, run and propagate covered works that you do not convey, without conditions so long as your license otherwise remains in force.  You may convey covered works to others for the sole purpose of having them make modifications exclusively for you, or provide you with facilities for running those works, provided that you comply with the terms of this License in conveying all material for which you do not control copyright.  Those thus making or running the covered works for you must do so exclusively on your behalf, under your direction and control, on terms that prohibit them from making any copies of your copyrighted material outside their relationship with you.</p> <p>Conveying under any other circumstances is permitted solely under the conditions stated below.  Sublicensing is not allowed; section 10 makes it unnecessary.</p> <p>3. Protecting Users' Legal Rights From Anti-Circumvention Law.</p> <p>No covered work shall be deemed part of an effective technological measure under any applicable law fulfilling obligations under article 11 of the WIPO copyright treaty adopted on 20 December 1996, or similar laws prohibiting or restricting circumvention of such measures.</p> <p>When you convey a covered work, you waive any legal power to forbid circumvention of technological measures to the extent such circumvention is effected by exercising rights under this License with respect to the covered work, and you disclaim any intention to limit operation or modification of the work as a means of enforcing, against the work's users, your or third parties' legal rights to forbid circumvention of technological measures.</p> <p>4. Conveying Verbatim Copies.</p> <p>You may convey verbatim copies of the Program's source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice; keep intact all notices stating that this License and any non-permissive terms added in accord with section 7 apply to the code; keep intact all notices of the absence of any warranty; and give all recipients a copy of this License along with the Program.</p> <p>You may charge any price or no price for each copy that you convey, and you may offer support or warranty protection for a fee.</p> <p>5. Conveying Modified Source Versions.</p> <p>You may convey a work based on the Program, or the modifications to produce it from the Program, in the form of source code under the terms of section 4, provided that you also meet all of these conditions:</p> <pre><code>a) The work must carry prominent notices stating that you modified\nit, and giving a relevant date.\n\nb) The work must carry prominent notices stating that it is\nreleased under this License and any conditions added under section\n7.  This requirement modifies the requirement in section 4 to\n\"keep intact all notices\".\n\nc) You must license the entire work, as a whole, under this\nLicense to anyone who comes into possession of a copy.  This\nLicense will therefore apply, along with any applicable section 7\nadditional terms, to the whole of the work, and all its parts,\nregardless of how they are packaged.  This License gives no\npermission to license the work in any other way, but it does not\ninvalidate such permission if you have separately received it.\n\nd) If the work has interactive user interfaces, each must display\nAppropriate Legal Notices; however, if the Program has interactive\ninterfaces that do not display Appropriate Legal Notices, your\nwork need not make them do so.\n</code></pre> <p>A compilation of a covered work with other separate and independent works, which are not by their nature extensions of the covered work, and which are not combined with it such as to form a larger program, in or on a volume of a storage or distribution medium, is called an \"aggregate\" if the compilation and its resulting copyright are not used to limit the access or legal rights of the compilation's users beyond what the individual works permit.  Inclusion of a covered work in an aggregate does not cause this License to apply to the other parts of the aggregate.</p> <p>6. Conveying Non-Source Forms.</p> <p>You may convey a covered work in object code form under the terms of sections 4 and 5, provided that you also convey the machine-readable Corresponding Source under the terms of this License, in one of these ways:</p> <pre><code>a) Convey the object code in, or embodied in, a physical product\n(including a physical distribution medium), accompanied by the\nCorresponding Source fixed on a durable physical medium\ncustomarily used for software interchange.\n\nb) Convey the object code in, or embodied in, a physical product\n(including a physical distribution medium), accompanied by a\nwritten offer, valid for at least three years and valid for as\nlong as you offer spare parts or customer support for that product\nmodel, to give anyone who possesses the object code either (1) a\ncopy of the Corresponding Source for all the software in the\nproduct that is covered by this License, on a durable physical\nmedium customarily used for software interchange, for a price no\nmore than your reasonable cost of physically performing this\nconveying of source, or (2) access to copy the\nCorresponding Source from a network server at no charge.\n\nc) Convey individual copies of the object code with a copy of the\nwritten offer to provide the Corresponding Source.  This\nalternative is allowed only occasionally and noncommercially, and\nonly if you received the object code with such an offer, in accord\nwith subsection 6b.\n\nd) Convey the object code by offering access from a designated\nplace (gratis or for a charge), and offer equivalent access to the\nCorresponding Source in the same way through the same place at no\nfurther charge.  You need not require recipients to copy the\nCorresponding Source along with the object code.  If the place to\ncopy the object code is a network server, the Corresponding Source\nmay be on a different server (operated by you or a third party)\nthat supports equivalent copying facilities, provided you maintain\nclear directions next to the object code saying where to find the\nCorresponding Source.  Regardless of what server hosts the\nCorresponding Source, you remain obligated to ensure that it is\navailable for as long as needed to satisfy these requirements.\n\ne) Convey the object code using peer-to-peer transmission, provided\nyou inform other peers where the object code and Corresponding\nSource of the work are being offered to the general public at no\ncharge under subsection 6d.\n</code></pre> <p>A separable portion of the object code, whose source code is excluded from the Corresponding Source as a System Library, need not be included in conveying the object code work.</p> <p>A \"User Product\" is either (1) a \"consumer product\", which means any tangible personal property which is normally used for personal, family, or household purposes, or (2) anything designed or sold for incorporation into a dwelling.  In determining whether a product is a consumer product, doubtful cases shall be resolved in favor of coverage.  For a particular product received by a particular user, \"normally used\" refers to a typical or common use of that class of product, regardless of the status of the particular user or of the way in which the particular user actually uses, or expects or is expected to use, the product.  A product is a consumer product regardless of whether the product has substantial commercial, industrial or non-consumer uses, unless such uses represent the only significant mode of use of the product.</p> <p>\"Installation Information\" for a User Product means any methods, procedures, authorization keys, or other information required to install and execute modified versions of a covered work in that User Product from a modified version of its Corresponding Source.  The information must suffice to ensure that the continued functioning of the modified object code is in no case prevented or interfered with solely because modification has been made.</p> <p>If you convey an object code work under this section in, or with, or specifically for use in, a User Product, and the conveying occurs as part of a transaction in which the right of possession and use of the User Product is transferred to the recipient in perpetuity or for a fixed term (regardless of how the transaction is characterized), the Corresponding Source conveyed under this section must be accompanied by the Installation Information.  But this requirement does not apply if neither you nor any third party retains the ability to install modified object code on the User Product (for example, the work has been installed in ROM).</p> <p>The requirement to provide Installation Information does not include a requirement to continue to provide support service, warranty, or updates for a work that has been modified or installed by the recipient, or for the User Product in which it has been modified or installed.  Access to a network may be denied when the modification itself materially and adversely affects the operation of the network or violates the rules and protocols for communication across the network.</p> <p>Corresponding Source conveyed, and Installation Information provided, in accord with this section must be in a format that is publicly documented (and with an implementation available to the public in source code form), and must require no special password or key for unpacking, reading or copying.</p> <p>7. Additional Terms.</p> <p>\"Additional permissions\" are terms that supplement the terms of this License by making exceptions from one or more of its conditions. Additional permissions that are applicable to the entire Program shall be treated as though they were included in this License, to the extent that they are valid under applicable law.  If additional permissions apply only to part of the Program, that part may be used separately under those permissions, but the entire Program remains governed by this License without regard to the additional permissions.</p> <p>When you convey a copy of a covered work, you may at your option remove any additional permissions from that copy, or from any part of it.  (Additional permissions may be written to require their own removal in certain cases when you modify the work.)  You may place additional permissions on material, added by you to a covered work, for which you have or can give appropriate copyright permission.</p> <p>Notwithstanding any other provision of this License, for material you add to a covered work, you may (if authorized by the copyright holders of that material) supplement the terms of this License with terms:</p> <pre><code>a) Disclaiming warranty or limiting liability differently from the\nterms of sections 15 and 16 of this License; or\n\nb) Requiring preservation of specified reasonable legal notices or\nauthor attributions in that material or in the Appropriate Legal\nNotices displayed by works containing it; or\n\nc) Prohibiting misrepresentation of the origin of that material, or\nrequiring that modified versions of such material be marked in\nreasonable ways as different from the original version; or\n\nd) Limiting the use for publicity purposes of names of licensors or\nauthors of the material; or\n\ne) Declining to grant rights under trademark law for use of some\ntrade names, trademarks, or service marks; or\n\nf) Requiring indemnification of licensors and authors of that\nmaterial by anyone who conveys the material (or modified versions of\nit) with contractual assumptions of liability to the recipient, for\nany liability that these contractual assumptions directly impose on\nthose licensors and authors.\n</code></pre> <p>All other non-permissive additional terms are considered \"further restrictions\" within the meaning of section 10.  If the Program as you received it, or any part of it, contains a notice stating that it is governed by this License along with a term that is a further restriction, you may remove that term.  If a license document contains a further restriction but permits relicensing or conveying under this License, you may add to a covered work material governed by the terms of that license document, provided that the further restriction does not survive such relicensing or conveying.</p> <p>If you add terms to a covered work in accord with this section, you must place, in the relevant source files, a statement of the additional terms that apply to those files, or a notice indicating where to find the applicable terms.</p> <p>Additional terms, permissive or non-permissive, may be stated in the form of a separately written license, or stated as exceptions; the above requirements apply either way.</p> <p>8. Termination.</p> <p>You may not propagate or modify a covered work except as expressly provided under this License.  Any attempt otherwise to propagate or modify it is void, and will automatically terminate your rights under this License (including any patent licenses granted under the third paragraph of section 11).</p> <p>However, if you cease all violation of this License, then your license from a particular copyright holder is reinstated (a) provisionally, unless and until the copyright holder explicitly and finally terminates your license, and (b) permanently, if the copyright holder fails to notify you of the violation by some reasonable means prior to 60 days after the cessation.</p> <p>Moreover, your license from a particular copyright holder is reinstated permanently if the copyright holder notifies you of the violation by some reasonable means, this is the first time you have received notice of violation of this License (for any work) from that copyright holder, and you cure the violation prior to 30 days after your receipt of the notice.</p> <p>Termination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License.  If your rights have been terminated and not permanently reinstated, you do not qualify to receive new licenses for the same material under section 10.</p> <p>9. Acceptance Not Required for Having Copies.</p> <p>You are not required to accept this License in order to receive or run a copy of the Program.  Ancillary propagation of a covered work occurring solely as a consequence of using peer-to-peer transmission to receive a copy likewise does not require acceptance.  However, nothing other than this License grants you permission to propagate or modify any covered work.  These actions infringe copyright if you do not accept this License.  Therefore, by modifying or propagating a covered work, you indicate your acceptance of this License to do so.</p> <p>10. Automatic Licensing of Downstream Recipients.</p> <p>Each time you convey a covered work, the recipient automatically receives a license from the original licensors, to run, modify and propagate that work, subject to this License.  You are not responsible for enforcing compliance by third parties with this License.</p> <p>An \"entity transaction\" is a transaction transferring control of an organization, or substantially all assets of one, or subdividing an organization, or merging organizations.  If propagation of a covered work results from an entity transaction, each party to that transaction who receives a copy of the work also receives whatever licenses to the work the party's predecessor in interest had or could give under the previous paragraph, plus a right to possession of the Corresponding Source of the work from the predecessor in interest, if the predecessor has it or can get it with reasonable efforts.</p> <p>You may not impose any further restrictions on the exercise of the rights granted or affirmed under this License.  For example, you may not impose a license fee, royalty, or other charge for exercise of rights granted under this License, and you may not initiate litigation (including a cross-claim or counterclaim in a lawsuit) alleging that any patent claim is infringed by making, using, selling, offering for sale, or importing the Program or any portion of it.</p> <p>11. Patents.</p> <p>A \"contributor\" is a copyright holder who authorizes use under this License of the Program or a work on which the Program is based.  The work thus licensed is called the contributor's \"contributor version\".</p> <p>A contributor's \"essential patent claims\" are all patent claims owned or controlled by the contributor, whether already acquired or hereafter acquired, that would be infringed by some manner, permitted by this License, of making, using, or selling its contributor version, but do not include claims that would be infringed only as a consequence of further modification of the contributor version.  For purposes of this definition, \"control\" includes the right to grant patent sublicenses in a manner consistent with the requirements of this License.</p> <p>Each contributor grants you a non-exclusive, worldwide, royalty-free patent license under the contributor's essential patent claims, to make, use, sell, offer for sale, import and otherwise run, modify and propagate the contents of its contributor version.</p> <p>In the following three paragraphs, a \"patent license\" is any express agreement or commitment, however denominated, not to enforce a patent (such as an express permission to practice a patent or covenant not to sue for patent infringement).  To \"grant\" such a patent license to a party means to make such an agreement or commitment not to enforce a patent against the party.</p> <p>If you convey a covered work, knowingly relying on a patent license, and the Corresponding Source of the work is not available for anyone to copy, free of charge and under the terms of this License, through a publicly available network server or other readily accessible means, then you must either (1) cause the Corresponding Source to be so available, or (2) arrange to deprive yourself of the benefit of the patent license for this particular work, or (3) arrange, in a manner consistent with the requirements of this License, to extend the patent license to downstream recipients.  \"Knowingly relying\" means you have actual knowledge that, but for the patent license, your conveying the covered work in a country, or your recipient's use of the covered work in a country, would infringe one or more identifiable patents in that country that you have reason to believe are valid.</p> <p>If, pursuant to or in connection with a single transaction or arrangement, you convey, or propagate by procuring conveyance of, a covered work, and grant a patent license to some of the parties receiving the covered work authorizing them to use, propagate, modify or convey a specific copy of the covered work, then the patent license you grant is automatically extended to all recipients of the covered work and works based on it.</p> <p>A patent license is \"discriminatory\" if it does not include within the scope of its coverage, prohibits the exercise of, or is conditioned on the non-exercise of one or more of the rights that are specifically granted under this License.  You may not convey a covered work if you are a party to an arrangement with a third party that is in the business of distributing software, under which you make payment to the third party based on the extent of your activity of conveying the work, and under which the third party grants, to any of the parties who would receive the covered work from you, a discriminatory patent license (a) in connection with copies of the covered work conveyed by you (or copies made from those copies), or (b) primarily for and in connection with specific products or compilations that contain the covered work, unless you entered into that arrangement, or that patent license was granted, prior to 28 March 2007.</p> <p>Nothing in this License shall be construed as excluding or limiting any implied license or other defenses to infringement that may otherwise be available to you under applicable patent law.</p> <p>12. No Surrender of Others' Freedom.</p> <p>If conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not excuse you from the conditions of this License.  If you cannot convey a covered work so as to satisfy simultaneously your obligations under this License and any other pertinent obligations, then as a consequence you may not convey it at all.  For example, if you agree to terms that obligate you to collect a royalty for further conveying from those to whom you convey the Program, the only way you could satisfy both those terms and this License would be to refrain entirely from conveying the Program.</p> <p>13. Use with the GNU Affero General Public License.</p> <p>Notwithstanding any other provision of this License, you have permission to link or combine any covered work with a work licensed under version 3 of the GNU Affero General Public License into a single combined work, and to convey the resulting work.  The terms of this License will continue to apply to the part which is the covered work, but the special requirements of the GNU Affero General Public License, section 13, concerning interaction through a network will apply to the combination as such.</p> <p>14. Revised Versions of this License.</p> <p>The Free Software Foundation may publish revised and/or new versions of the GNU General Public License from time to time.  Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns.</p> <p>Each version is given a distinguishing version number.  If the Program specifies that a certain numbered version of the GNU General Public License \"or any later version\" applies to it, you have the option of following the terms and conditions either of that numbered version or of any later version published by the Free Software Foundation.  If the Program does not specify a version number of the GNU General Public License, you may choose any version ever published by the Free Software Foundation.</p> <p>If the Program specifies that a proxy can decide which future versions of the GNU General Public License can be used, that proxy's public statement of acceptance of a version permanently authorizes you to choose that version for the Program.</p> <p>Later license versions may give you additional or different permissions.  However, no additional obligations are imposed on any author or copyright holder as a result of your choosing to follow a later version.</p> <p>15. Disclaimer of Warranty.</p> <p>THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.</p> <p>16. Limitation of Liability.</p> <p>IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.</p> <p>17. Interpretation of Sections 15 and 16.</p> <p>If the disclaimer of warranty and limitation of liability provided above cannot be given local legal effect according to their terms, reviewing courts shall apply local law that most closely approximates an absolute waiver of all civil liability in connection with the Program, unless a warranty or assumption of liability accompanies a copy of the Program in return for a fee.</p> <pre><code>                 END OF TERMS AND CONDITIONS\n\n        How to Apply These Terms to Your New Programs\n</code></pre> <p>If you develop a new program, and you want it to be of the greatest possible use to the public, the best way to achieve this is to make it free software which everyone can redistribute and change under these terms.</p> <p>To do so, attach the following notices to the program.  It is safest to attach them to the start of each source file to most effectively state the exclusion of warranty; and each file should have at least the \"copyright\" line and a pointer to where the full notice is found.</p> <pre><code>&lt;one line to give the program's name and a brief idea of what it does.&gt;\nCopyright (C) &lt;year&gt;  &lt;name of author&gt;\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n</code></pre> <p>Also add information on how to contact you by electronic and paper mail.</p> <p>If the program does terminal interaction, make it output a short notice like this when it starts in an interactive mode:</p> <pre><code>&lt;program&gt;  Copyright (C) &lt;year&gt;  &lt;name of author&gt;\nThis program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\nThis is free software, and you are welcome to redistribute it\nunder certain conditions; type `show c' for details.\n</code></pre> <p>The hypothetical commands <code>show w' and</code>show c' should show the appropriate parts of the General Public License.  Of course, your program's commands might be different; for a GUI interface, you would use an \"about box\".</p> <p>You should also get your employer (if you work as a programmer) or school, if any, to sign a \"copyright disclaimer\" for the program, if necessary. For more information on this, and how to apply and follow the GNU GPL, see https://www.gnu.org/licenses/.</p> <p>The GNU General Public License does not permit incorporating your program into proprietary programs.  If your program is a subroutine library, you may consider it more useful to permit linking proprietary applications with the library.  If this is what you want to do, use the GNU Lesser General Public License instead of this License.  But first, please read https://www.gnu.org/licenses/why-not-lgpl.html.</p>"}, {"location": "advanced/internals/", "title": "Internal Operations", "text": "<p>Information about the inner workings of Igir.</p>"}, {"location": "advanced/internals/#order-of-operations", "title": "Order of operations", "text": "<p>Igir runs these steps in the following order:</p> <ol> <li>Scan each DAT input path for every file and parse them, if provided (<code>--dat &lt;path&gt;</code>)</li> <li>Scan each ROM input path for every file (<code>--input &lt;path&gt;</code>)<ul> <li>Detect headers in those files, if applicable (see header docs)</li> <li>Detect trimming of those files, if applicable (see trimming docs)</li> </ul> </li> <li>Scan each patch input path for every file (<code>--patch &lt;path&gt;</code>) (see patching docs)</li> <li>Then for each DAT:<ul> <li>Parent/clone information is inferred if the DAT has none (see DATs docs)</li> <li>Parent/clone ROMs sets are merged or split (<code>--merge-roms &lt;type&gt;</code>) (see arcade docs)</li> <li>Multi-disc games are merged (<code>--merge-discs</code>) (see ROM set docs)</li> <li>ROMs in the DAT are filtered to only those desired (<code>--filter-*</code> options) (see filtering &amp; preference docs)</li> <li>ROMs in the DAT are filtered to the preferred clone (<code>--single</code>, see filtering &amp; preference docs)</li> <li>Input files are matched to ROMs in the DAT (see matching docs)</li> <li>Patch files are matched to ROMs found (see patching docs)</li> <li>ROMs without a potentially bad extension have their extension corrected using its file signature</li> <li>ROM archives that aren't being extracted have their checksums calculated</li> <li>ROMs are combined (<code>--zip-dat-name</code>)</li> <li>ROMs are written to the output directory, if specified (<code>copy</code>, <code>move</code>, <code>link</code>)<ul> <li>Written ROMs are tested for accuracy, if specified (<code>test</code>)</li> </ul> </li> <li>A \"dir2dat\" DAT is created, if specified (<code>dir2dat</code>) (see dir2dat docs)</li> <li>A \"fixdat\" is created, if specified (<code>fixdat</code>) (see fixdats docs)</li> </ul> </li> <li>Leftover \"moved\" input ROMs are deleted (<code>move</code>)</li> <li>Unknown files are recycled from the output directory, if specified (<code>clean</code>, see cleaning docs)</li> <li>An output report is written to the output directory, if specified (<code>report</code>, see reporting docs)</li> </ol>"}, {"location": "advanced/logging/", "title": "Logging", "text": "<p>By default, Igir will print the following log levels:</p> <ul> <li><code>ERROR</code>: an unexpected error has prevented an intended command</li> <li><code>WARN</code>: a preventable error has prevented an intended command</li> </ul> <p>There are additional levels of verbosity that can be enabled with the <code>-v</code> flag:</p> <ul> <li> <p><code>INFO</code> (<code>-v</code>): print information about actions taken.</p> <p>This includes:</p> <ul> <li>Files being copied, zipped, and linked</li> <li>dir2dat files being created</li> <li>Fixdat files being created</li> <li>Leftover input files deleted after being moved</li> <li>Output files being cleaned (including files skipped due to <code>--clean-dry-run</code>)</li> <li>Report files being created</li> </ul> <p>Usage:</p> <pre><code>igir [commands..] [options] -v\n</code></pre> <p>This level is helpful to turn on if you want to know every action that is resulting in a file being created, modified, or deleted.</p> </li> </ul> <ul> <li> <p><code>DEBUG</code> (<code>-vv</code>): print information about actions taken and skipped.</p> <p>This includes:</p> <ul> <li>Everything from the <code>INFO</code> level above</li> <li>Files skipped from being copied, zipped, or linked because the output file exists and an <code>--overwrite</code> option wasn't provided</li> <li>Fixdat files skipped from being created because all games were found</li> </ul> <p>Usage:</p> <pre><code>igir [commands..] [options] -vv\n</code></pre> <p>This level is helpful to turn on if you want to debug why an action didn't take place.</p> </li> </ul> <ul> <li> <p><code>TRACE</code> (<code>-vvv</code>): print information about actions taken, skipped, and additional information that can be helpful to debug issues.</p> <p>Usage:</p> <pre><code>igir [commands..] [options] -vvv\n</code></pre> <p>Note</p> <p>Trace logs are required when submitting bug reports as they include information that can help diagnose your unique situation!</p> </li> </ul>"}, {"location": "advanced/temp-dir/", "title": "Temp Directory", "text": "<p>Igir needs to write some temporary files to disk for a few reasons:</p> <ul> <li>Downloading DAT URLs to disk before parsing</li> <li>Extracting some archives to disk during scanning, and when reading when extracting or zipping</li> </ul> <p>Temporary files are ones that are deleted as soon as Igir no longer needs them for processing. Igir will also delete any leftover temporary files on exit.</p> <p>Igir will use your operating system's temporary directory for these files by default.  The option <code>--temp-dir &lt;path&gt;</code> is provided to let you change the directory, and you may want to do this for a few reasons:</p> <ul> <li>Your operating system drive has minimal space available</li> <li>You want to protect your operating system drive from excess wear and tear</li> <li>You want to use a \"RAM disk\" instead of a real drive</li> </ul>"}, {"location": "advanced/temp-dir/#ram-disks", "title": "RAM disks", "text": ""}, {"location": "advanced/temp-dir/#windows", "title": "Windows", "text": "<p>There are no tools built-in to Windows that can create a RAM disk. The open source ImDisk Toolkit is a popular option.</p>"}, {"location": "advanced/temp-dir/#macos", "title": "macOS", "text": "<p>The built-in <code>diskutil</code> and <code>hdiutil</code> tools can be used to create and mount a RAM disk. Alex T has some instructions in a GitHub gist.</p>"}, {"location": "advanced/temp-dir/#linux", "title": "Linux", "text": "<p><code>tmpfs</code> is a tool that comes with most Linux distributions that is used for creating RAM disks. Oracle has a guide on the tool.</p>"}, {"location": "advanced/troubleshooting/", "title": "Troubleshooting", "text": "<p>See the sibling page about logging for more information to help troubleshoot issues.</p>"}, {"location": "advanced/troubleshooting/#fatal-crashes", "title": "Fatal crashes", "text": ""}, {"location": "advanced/troubleshooting/#heap-space-out-of-memory", "title": "Heap space out-of-memory", "text": "<p>These types of crashes will print something similar to this to the console:</p> <pre><code>&lt;--- Last few GCs ---&gt;\n\n[5789:0x3f6eca0]    79353 ms: Scavenge 2020.1 (2075.5) -&gt; 2016.5 (2076.5) MB, 9.57 / 0.00 ms  (average mu = 0.566, current mu = 0.422) allocation failure;\n[5789:0x3f6eca0]    79403 ms: Scavenge 2021.2 (2076.5) -&gt; 2018.3 (2079.5) MB, 11.10 / 0.00 ms  (average mu = 0.566, current mu = 0.422) allocation failure;\n[5789:0x3f6eca0]    80721 ms: Scavenge 2024.0 (2079.5) -&gt; 2020.6 (2097.0) MB, 1280.87 / 0.00 ms  (average mu = 0.566, current mu = 0.422) allocation failure;\n\n\n&lt;--- JS stacktrace ---&gt;\n\nFATAL ERROR: Reached heap limit Allocation failed - JavaScript heap out of memory\n----- Native stack trace -----\n\n 1: 0xbd3a28 node::Abort() [/nix/store/d6lkbndr98lcn8spbqxfq52f2ldvqhks-nodejs-20.11.0/bin/node]\n 2: 0xaa1af8  [/nix/store/d6lkbndr98lcn8spbqxfq52f2ldvqhks-nodejs-20.11.0/bin/node]\n 3: 0xdfa1a0 v8::Utils::ReportOOMFailure(v8::internal::Isolate*, char const*, v8::OOMDetails const&amp;) [/nix/store/d6lkbndr98lcn8spbqxfq52f2ldvqhks-nodejs-20.11.0/bin/node]\n 4: 0xdfa574 v8::internal::V8::FatalProcessOutOfMemory(v8::internal::Isolate*, char const*, v8::OOMDetails const&amp;) [/nix/store/d6lkbndr98lcn8spbqxfq52f2ldvqhks-nodejs-20.11.0/bin/node]\n 5: 0x10197b7  [/nix/store/d6lkbndr98lcn8spbqxfq52f2ldvqhks-nodejs-20.11.0/bin/node]\n 6: 0x1031839 v8::internal::Heap::CollectGarbage(v8::internal::AllocationSpace, v8::internal::GarbageCollectionReason, v8::GCCallbackFlags) [/nix/store/d6lkbndr98lcn8spbqxfq52f2ldvqhks-nodejs-20.11.0/bin/node]\n 7: 0x100b547 v8::internal::HeapAllocator::AllocateRawWithLightRetrySlowPath(int, v8::internal::AllocationType, v8::internal::AllocationOrigin, v8::internal::AllocationAlignment) [/nix/store/d6lkbndr98lcn8spbqxfq52f2ldvqhks-nodejs-20.11.0/bin/node]\n 8: 0x100c184 v8::internal::HeapAllocator::AllocateRawWithRetryOrFailSlowPath(int, v8::internal::AllocationType, v8::internal::AllocationOrigin, v8::internal::AllocationAlignment) [/nix/store/d6lkbndr98lcn8spbqxfq52f2ldvqhks-nodejs-20.11.0/bin/node]\n 9: 0xfec37e v8::internal::Factory::NewFillerObject(int, v8::internal::AllocationAlignment, v8::internal::AllocationType, v8::internal::AllocationOrigin) [/nix/store/d6lkbndr98lcn8spbqxfq52f2ldvqhks-nodejs-20.11.0/bin/node]\n10: 0x143b35c v8::internal::Runtime_AllocateInYoungGeneration(int, unsigned long*, v8::internal::Isolate*) [/nix/store/d6lkbndr98lcn8spbqxfq52f2ldvqhks-nodejs-20.11.0/bin/node]\n11: 0x7fe14fed9ef6\n</code></pre> <p>The issue is that Igir ran out of memory likely due to low system limits, large DAT packs, or large ROM collections.</p> <p>You likely need to process your ROM collection in batches, just be careful when using the <code>igir clean</code> command. If you don't need every DAT from a pack, you can try reducing the number of DATs being processed with the <code>--dat-*-regex &lt;pattern|filename&gt;</code> and <code>--dat-*-regex-exclude &lt;pattern|filename&gt;</code> options like this:</p> <pre><code>igir [commands..] --dat \"*.dat\" --dat-name-regex \"/nintendo/i\"\n</code></pre> <p>You can also try increasing V8's \"old memory\" limit above Node.js' default (version dependent) to ~75% of your system's available RAM in megabytes like this:</p> <pre><code>npx --node-options='--max-old-space-size=6144' igir@latest [commands..] [options]\n</code></pre>"}, {"location": "dats/dir2dat/", "title": "Writing dir2dats", "text": "<p>\"dir2dat\" refers to DATs that have been automatically created based on files in an input directory. DATs generated this way are not typically useful as-is, they usually require some hand editing after creation.</p> <p>The <code>dir2dat</code> command creates a Logiqx XML DAT for every <code>--input &lt;path&gt;</code> provided. dir2dats will be written to the first matching directory in this list:</p> <ol> <li>If provided: the <code>--dir2dat-output &lt;path&gt;</code> directory</li> <li>When writing ROMs (one of the <code>copy</code>, <code>move</code>, or <code>link</code> commands): the <code>--output &lt;path&gt;</code> directory</li> <li>Otherwise: the CLI working directory</li> </ol> <p>Example usage:</p> <pre><code>igir dir2dat --input &lt;path&gt; [--input &lt;path&gt;..]\n</code></pre>"}, {"location": "dats/dir2dat/#dir2dat-rules", "title": "dir2dat rules", "text": "<p>Igir uses the following rules when creating dir2dat DAT files:</p> <ul> <li> <p>A DAT file will be created for every <code>--input &lt;path&gt;</code>.</p> <p>If multiple input paths overlap, such as:</p>  Windows macOS Linux <pre><code>igir dir2dat ^\n  --input \"C:\\ROMs\" ^\n  --input \"C:\\ROMs\\NES\"\n</code></pre> <pre><code>igir dir2dat \\\n  --input ~/ROMs/ \\\n  --input ~/ROMs/NES\n</code></pre> <pre><code>igir dir2dat \\\n  --input ~/ROMs/ \\\n  --input ~/ROMs/NES\n</code></pre> <p>then ROMs can appear in multiple resulting dir2dat files.</p> <p>Note</p> <p>You can use the <code>--dat-combine</code> option to create only one DAT even when multiple input paths are provided.</p> </li> </ul> <ul> <li>Each input path's basename will be used for the DAT's name.<p>Here are some examples:</p> Input path DAT name <code>--input \"ROMs\"</code> <code>ROMs</code> <code>--input \"ROMs/NES\"</code> <code>NES</code> <code>--input \"ROMs/SNES/*\"</code> <code>SNES</code> <code>--input \"ROMs/SNES/**/*\"</code> <code>SNES</code> </li> </ul> <ul> <li>Archive files will be treated as a single game, with every archive entry being a separate ROM file.<p>This is consistent with how the <code>igir zip</code> command works, and with what MAME expects.</p> </li> </ul> <ul> <li> <p>The input file's basename (without extension) will be used for the game name.</p> <p>Warning</p> <p>This will cause input files with the same basename to be grouped together!</p> </li> </ul>"}, {"location": "dats/dir2dat/#combining-with-other-options", "title": "Combining with other options", "text": "<p>Once DATs have been generated from input files, they are processed the same as any other DAT file. That means:</p> <ul> <li>Parent/clone information may be inferred from game names.<p>If your input files are in some kind of standard naming convention (e.g. No-Intro, Redump, TOSEC, or GoodTools), then parent/clone information can be inferred for 1G1R preferences.</p> <p>Parent/clone information also allows for merging &amp; splitting of ROM sets.</p> </li> </ul> <ul> <li> <p>ROM filter &amp; preference options can be applied.</p> <p>If your input files are in some kind of standard naming convention (e.g. No-Intro, Redump, TOSEC, or GoodTools) that contains region, language, or other tags, then ROM filter &amp; preference options can be applied.</p> </li> </ul> <ul> <li>Filename extensions will be corrected by default.<p>See ROM Output Options for more information.</p> </li> </ul>"}, {"location": "dats/dir2dat/#alternative-tools", "title": "Alternative tools", "text": "<p>It is unlikely that any ROM tool, including Igir, will ever meet every person's exact DAT creation needs.</p> <p>SabreTools is a great tool for DAT management that offers many complex options for DAT creation, filtering, merging, and splitting.</p>"}, {"location": "dats/fixdats/", "title": "Writing Fixdats", "text": "<p>\"Fixdats\" are DATs that contain only ROMs that are missing from your collection. Fixdats are derived from some other DAT (see the DATs introduction docs for how to obtain DATs), containing only a subset of its ROMs. Fixdats are specific to the state of each person's ROM collection, so they aren't necessarily meaningful to other people.</p> <p>Fixdats help you find files missing from your collection, and they can be used to generate a collection of those files once you've found them. This sub-collection of files can then be merged back into your main collection.</p> <p>The <code>fixdat</code> command creates a Logiqx XML DAT for every input DAT (the <code>--dat &lt;path&gt;</code> option) that is missing ROMs. Fixdats will be written to the first matching directory in this list:</p> <ol> <li>If provided: the <code>--fixdat-output &lt;path&gt;</code> directory</li> <li>When writing ROMs (one of the <code>copy</code>, <code>move</code>, or <code>link</code> commands): the <code>--output &lt;path&gt;</code> directory</li> <li>Otherwise: the CLI working directory</li> </ol> <p>Example usage:</p>  Windows macOS Linux <pre><code>igir copy zip fixdat ^\n  --dat \"Nintendo - Game Boy.dat\" ^\n  --dat \"Nintendo - Game Boy Advance.dat\" ^\n  --dat \"Nintendo - Game Boy Color.dat\" ^\n  --input ROMs\\ ^\n  --output ROMs-Sorted\\ ^\n  --fixdat\n</code></pre> <pre><code>igir copy zip fixdat \\\n  --dat \"Nintendo - Game Boy.dat\" \\\n  --dat \"Nintendo - Game Boy Advance.dat\" \\\n  --dat \"Nintendo - Game Boy Color.dat\" \\\n  --input ROMs/ \\\n  --output ROMs-Sorted/\n</code></pre> <pre><code>igir copy zip fixdat \\\n  --dat \"Nintendo - Game Boy.dat\" \\\n  --dat \"Nintendo - Game Boy Advance.dat\" \\\n  --dat \"Nintendo - Game Boy Color.dat\" \\\n  --input ROMs/ \\\n  --output ROMs-Sorted/\n</code></pre> <p>This command will produce a fixdat file in the <code>ROMs-Sorted/</code> directory for each of the three input DATs that have at least one ROM that wasn't found in the <code>ROMs/</code> input directory:</p> <pre><code>ROMs-Sorted/\n\u251c\u2500\u2500 Nintendo - Game Boy (20230414-173400) fixdat.dat\n\u251c\u2500\u2500 Nintendo - Game Boy Advance (20230414-173400) fixdat.dat\n\u2514\u2500\u2500 Nintendo - Game Boy Color (20230414-173400) fixdat.dat\n</code></pre> <p>Info</p> <p>Fixdats are affected by filter &amp; preference (1G1R) options. This is because those options are applied to all DATs before ROM matching happens.</p>"}, {"location": "dats/introduction/", "title": "Introduction to DATs", "text": "<p>From the RetroPie docs:</p> <p>Once you begin working with software tools to help validate, rebuild, or filter your ROM collection, you will quickly encounter the need for \"DAT\" files, so named because they usually (but not always!) have the file extension <code>.dat</code>.</p> <p>DATs describe the ROM contents including filenames, file sizes, and checksums to verify contents are not incorrect or corrupt. DATs are usually maintained either by emulator developers (such as with MAME or FinalBurn Neo) or digital preservation organizations like TOSEC and No-Intro.</p> <p>DATs are catalog files of every known ROM that exists per game system, complete with enough information to identify each file.</p> <p>These DAT files (\"DATs\") help Igir distinguish known ROM files in input directories from other files. Because DATs typically contain the complete catalog for a console, Igir also uses them to generate reports for you on what ROMs were found and which are missing.</p> <p>The location to your DAT files are specified with the <code>--dat &lt;path&gt;</code> option:</p> <pre><code>igir [commands..] --dat \"dats/*.dat\" --input &lt;input&gt;\n</code></pre> <p>you can even specify archives that can contain multiple DATs (such as No-Intro's daily download):</p> <pre><code>igir [commands..] --dat \"No-Intro*.zip\" --input &lt;input&gt;\n</code></pre> <p>See the DAT processing page for information on how Igir scans for and processes DATs.</p>"}, {"location": "dats/introduction/#dat-release-groups", "title": "DAT release groups", "text": "<p>A number of different release groups maintain sets of DATs, the most popular are:</p> <ul> <li>No-Intro (cartridge-based consoles)</li> <li>Redump (optical media-based consoles)</li> <li>MAME (official \"full driver\" MAME ListXML)</li> </ul> <p>And some less popular release groups are:</p> <ul> <li>TOSEC</li> <li>GoodTools (home computers, gen 1-5 consoles)</li> <li>EmulationArchive (trurip)</li> <li>libretro (RetroArch):<ul> <li>Custom DATs (specific games, some optical media-based consoles)</li> <li>Mirrored DATs (No-Intro and Redump/trurip/TOSEC DATs)</li> <li>FinalBurn NEO (arcade, gen 1-4 consoles)</li> </ul> </li> <li>ADVANsCEne (GBA, DS, 3DS, PSP, PS Vita)</li> <li>Arcade:<ul> <li>progetto-SNAPS (MAME ListXMLs with some unnecessary metadata removed, e.g. inputs, DIP switches, and ports)</li> <li>pleasuredome (MAME merged, non-merged, and split sets without parent/clone information)</li> <li>TeknoParrot (modern arcade)</li> </ul> </li> </ul>"}, {"location": "dats/introduction/#parentclone-pc-dats", "title": "Parent/clone (P/C) DATs", "text": "<p>DATs that include \"parent\" and \"clone\" information help Igir understand what game releases are actually the same game (are \"clones\" of each other). Frequently, a game will be released in many regions or with different revisions, usually with only language translations and minor bug fixes. For example, No-Intro has 6+ \"clones\" of Pok\u00e9mon Blue cataloged.</p> <p>Being able to know that many releases are actually the same game gives Igir the ability to produce \"one game, one ROM\" (1G1R) sets with the <code>--single</code> option. 1G1R sets include only one of these \"clone\" releases, usually filtered to a language and region, because many people don't care about ROMs they can't understand.</p> <p>Note</p> <p>If you have the option to download \"parent/clone\" or \"P/C\" versions of DATs, you should always choose those as they contain the most amount of game information.</p>"}, {"location": "dats/introduction/#arcade-dats", "title": "Arcade DATs", "text": "<p>Building a ROM set that works with your exact version of MAME or FinalBurn Alpha / Neo is necessarily complicated. Arcade machines vary wildly in hardware, they contain many more ROM chips than cartridge-based consoles, their ROM dumps are sometimes imperfect, and arcade emulators prefer \"mostly working\" emulation over perfect emulation.</p> <p>The rule-of-thumb with DATs and arcade emulation is: your emulator probably has a companion DAT that describes the exact ROM files it needs and the exact way you have to organize those ROMs. That means:</p> <ul> <li>ROMs organized with a MAME v0.258 DAT will likely not work with MAME 2003 (v0.78)</li> <li>ROMs organized with a MAME v0.258 DAT will likely not work with MAME 2016 (v0.174)</li> <li>ROMs organized with a MAME v0.258 DAT will likely not work with FinalBurn</li> <li>ROMs organized with a FinalBurn Neo v1.0.0.2 DAT will likely not work with FinalBurn Neo v1.0.0.0</li> <li>ROMs organized with a FinalBurn Neo v1.0.0.2 DAT will likely not work with FinalBurn Alpha v0.2.97.29</li> <li>ROMs organized with a FinalBurn Alpha v0.2.97.29 DAT will likely not work with FinalBurn Alpha v0.2.96.71</li> </ul> <p>If you are using a desktop frontend such as RetroArch, it may come with multiple versions of the same emulator, and it is unlikely that any of them is the most recent version. Follow the frontend's documentation to location or download the correct DAT to use with each emulator.</p> <p>See the arcade usage page for more information on building &amp; re-building arcade ROM sets.</p>"}, {"location": "dats/introduction/#next-steps", "title": "Next steps", "text": "<p>See the DAT processing page for information on how Igir scans for and processes DATs.</p>"}, {"location": "dats/processing/", "title": "DAT Processing", "text": "<p>Igir has a number of ways it can process DATs, and it processes them in the following order.</p>"}, {"location": "dats/processing/#just-tell-me-what-to-do", "title": "Just tell me what to do", "text": "<p>DATs can get fairly complicated, and there are many release groups, each with their own focus areas and naming patterns. If all you want to do is organize your ROMs with Igir in some consistent way, follow these instructions:</p> <ol> <li>Go to the No-Intro DAT-o-MATIC daily download page</li> <li>Select the \"P/C XML\" radio option (as opposed to \"standard DAT\") and download the <code>.zip</code> to wherever you store your ROMs</li> <li> <p>Every time you run Igir, specify the <code>.zip</code> file you downloaded with the <code>--dat &lt;path&gt;</code> option:</p> <pre><code>igir [commands..] --dat \"No-Intro*.zip\" --input &lt;input&gt;\n</code></pre> </li> </ol>"}, {"location": "dats/processing/#scanning-for-dats", "title": "Scanning for DATs", "text": "<p>The <code>--dat &lt;path&gt;</code> option supports files, archives, directories, and globs like any of the other file options. See the file scanning page for more information.</p> <p>Igir also supports URLs to DAT files and archives. This is helpful to make sure you're always using the most up-to-date version of a DAT hosted on sites such as GitHub. For example:</p>  Windows macOS Linux <pre><code>igir copy ^\n  --dat \"https://raw.githubusercontent.com/libretro/libretro-database/master/dat/DOOM.dat\" ^\n  --input ROMs\\ ^\n  --output ROMs-Sorted\\\n</code></pre> <pre><code>igir copy \\\n  --dat \"https://raw.githubusercontent.com/libretro/libretro-database/master/dat/DOOM.dat\" \\\n  --input ROMs/ \\\n  --output ROMs-Sorted/\n</code></pre> <pre><code>igir copy \\\n  --dat \"https://raw.githubusercontent.com/libretro/libretro-database/master/dat/DOOM.dat\" \\\n  --input ROMs/ \\\n  --output ROMs-Sorted/\n</code></pre> <p>Note</p> <p>Because of the way DAT-o-MATIC prepares &amp; serves downloads, you can't use this method for official No-Intro DATs.</p>"}, {"location": "dats/processing/#supported-dat-formats", "title": "Supported DAT formats", "text": "<p>There have been a few DAT-like formats developed over the years. Igir supports the following:</p> <ul> <li>Logiqx XML (most common) (No-Intro, Redump, TOSEC, and more)</li> <li> <p>MAME ListXML (XML exported by the <code>mame -listxml</code> command)</p> <p>Tip</p> <p>Instead of exporting the ListXML to a file yourself, you can also specify a MAME executable for the DAT path and then Igir is smart enough to parse it:</p>  Windows macOS Linux <p>Windows is fairly easy, MAME is officially compiled for Windows and downloads can be found on many mirror sites.</p> <pre><code>igir [commands..] --dat \"mame0258b_64bit.exe\" --input &lt;input&gt;\n</code></pre> <p>MAME isn't officially compiled for macOS, you will have to use a third-party release such as SDL MAME.</p> <pre><code>igir [commands..] --dat \"mame0258-x86/mame\" --input &lt;input&gt;\n</code></pre> <p>Most distros (Ubuntu, Debian, Fedora, etc.) have MAME in their package repositories, but some will require you to compile MAME yourself. If the <code>mame</code> executable is in your <code>$PATH</code>, you can specify its path like this:</p> <pre><code>igir [commands..] --dat \"$(which \"mame\")\" --input &lt;input&gt;\n</code></pre> </li> </ul> <ul> <li>MAME software lists (XML exported by the <code>mame -getsoftlist</code> command)</li> <li>ClrMamePro (libretro, DOSCenter, and more)</li> <li>Hardware Target Game Database SMDBs</li> </ul> <p>Tip</p> <p>In case you come across a DAT in a format that Igir doesn't support, SabreTools supports reading a number of obscure formats and converting them to more standard formats such as Logiqx XML.</p>"}, {"location": "dats/processing/#dat-filtering", "title": "DAT filtering", "text": "<p>To be able to process only the DATs you want in downloaded archives, Igir has a few filtering options.</p>"}, {"location": "dats/processing/#dat-name-regex-filtering", "title": "DAT name regex filtering", "text": "<pre><code>--dat-name-regex &lt;pattern|filename&gt;, --dat-name-regex-exclude &lt;pattern|filename&gt;\n</code></pre> <p>These options limit which DATs are processed. The regex is applied to the DAT's name found within its file contents, not its filename.</p> <p>Regex flags can be optionally provided in the form <code>/&lt;pattern&gt;/&lt;flags&gt;</code>, for example:</p> <pre><code>Headerless|Encrypted\n/headerless|encrypted/i\n</code></pre> <p>Tip</p> <p><code>--dat-name-regex-exclude &lt;pattern|filename&gt;</code> is particularly helpful for excluding some No-Intro DATs versions such as \"encrypted\" and \"headerless\".</p>"}, {"location": "dats/processing/#dat-description-regex-filtering", "title": "DAT description regex filtering", "text": "<pre><code>--dat-description-regex &lt;pattern|filename&gt;, --dat-description-regex-exclude &lt;pattern|filename&gt;\n</code></pre> <p>These options limit which DATs are processed. The regex is applied to the DAT's description found within its file contents.</p>"}, {"location": "dats/processing/#dat-combining", "title": "DAT combining", "text": "<p>The <code>--dat-combine</code> option lets you combine every game from every parsed DAT into one file.</p> <p>This may be desirable when creating a dir2dat, a fixdat, or other complicated situations.</p> <p>Note</p> <p>Using this option with the <code>igir zip</code> command will result in all ROMs in a DAT being archived into one file. This can work great for archiving older, cartridge-based consoles with smaller ROM sizes, but will likely not work well with larger ROMs.</p> <p>To keep files organized in a human-readable way, it is not recommended to use the <code>--dir-game-subdir never</code> option combined with <code>--dat-combine</code>.</p>"}, {"location": "dats/processing/#parentclone-inference", "title": "Parent/clone inference", "text": "<p>One feature that sets Igir apart from other ROM managers is its ability to infer parent/clone information when DATs don't provide it. For example, Redump DATs don't provide parent/clone information, which makes it much more difficult to create 1G1R sets.</p> <p>For example, all of these Super Smash Bros. Melee releases should be considered the same game, even if a DAT doesn't provide proper information. If the releases are all considered the same game, then the <code>--single</code> option can be used in combination with ROM preferences to make a 1G1R set. Igir is smart enough to understand that the only differences between these releases are the regions, languages, and revisions.</p> <pre><code>Super Smash Bros. Melee (Europe) (En,Fr,De,Es,It)\nSuper Smash Bros. Melee (Korea) (En,Ja)\nSuper Smash Bros. Melee (USA) (En,Ja)\nSuper Smash Bros. Melee (USA) (En,Ja) (Rev 1)\nSuper Smash Bros. Melee (USA) (En,Ja) (Rev 2)\n</code></pre> <p>Note</p> <p>If a DAT has any parent/clone information then Igir will use that and skip inference. If you want to ignore this information, you can provide the <code>--dat-ignore-parent-clone</code> option.</p> <p>Note</p> <p>It is unlikely that Igir will ever be perfect with inferring parent/clone information. If you find an instance where Igir made the wrong choice, please create a GitHub issue.</p> <p>Tip</p> <p>Retool (no longer maintained) is a DAT manipulation tool that has a set of hand-maintained parent/clone lists to supplement common DAT groups such as No-Intro and Redump. This helps cover situations such as release titles in different languages that would be hard to group together automatically.</p> <p>1G1R DATs made by Retool can be used seamlessly with Igir. You won't need to supply the <code>--single</code> option or any ROM preferences for Igir, as you would have already applied these preferences in Retool, but you can still supply ROM filtering options if desired.</p>"}, {"location": "input/file-scanning/", "title": "File Scanning", "text": "<p>Igir has a few options to specify input files, as well as files to exclude:</p> <ul> <li>ROMs: <code>--input &lt;path&gt;</code>, <code>--input-exclude &lt;path&gt;</code></li> <li>DATs: <code>--dat &lt;path&gt;</code>, <code>--dat-exclude &lt;path&gt;</code></li> <li>ROM patches: <code>--patch &lt;path&gt;</code>, <code>--patch-exclude &lt;path&gt;</code></li> </ul>"}, {"location": "input/file-scanning/#archive-files", "title": "Archive files", "text": "<p>Igir can scan archives for DATs, ROMs, and patches. See the archives page for more information on supported formats.</p>"}, {"location": "input/file-scanning/#glob-patterns", "title": "Glob patterns", "text": "<p>All input options support glob patterns. These patterns help you specify file paths using simple wildcards (e.g. <code>ROMs/*.rom</code>) as well as more complex patterns (e.g. <code>ROMs/!(GBA)/**/*.rom</code>).</p> <p>Tip</p> <p>globster.xyz is a great website to test various glob patterns.</p>"}, {"location": "input/file-scanning/#examples", "title": "Examples", "text": "<p>Given this file tree, here are some glob pattern examples:</p> <pre><code>.\n\u251c\u2500\u2500 gb\n\u2502   \u251c\u2500\u2500 Bomberman GB (USA, Europe) (SGB Enhanced).gb\n\u2502   \u2514\u2500\u2500 [BIOS] Nintendo Game Boy Boot ROM (World) (Rev 1).gb\n\u251c\u2500\u2500 gba\n\u2502   \u2514\u2500\u2500 misc\n\u2502       \u251c\u2500\u2500 Dragon Ball Z - The Legacy of Goku II International (Japan).gba\n\u2502       \u2514\u2500\u2500 [BIOS] Game Boy Advance (World).gba\n\u2514\u2500\u2500 gbc\n    \u251c\u2500\u2500 Legend of Zelda, The - Link's Awakening DX (USA, Europe) (Rev 2) (SGB Enhanced) (GB Compatible).gbc\n    \u2514\u2500\u2500 [BIOS] Nintendo Game Boy Color Boot ROM (World) (Rev 1).gbc\n</code></pre> <p>Only process USA ROMs:</p> <pre><code>--input \"**/*USA*\"\n</code></pre> <p>Only process BIOS ROMs:</p> <pre><code>--input \"**/\\[BIOS\\]*\"\n</code></pre> <p>Only process ROMs one level deep:</p> <pre><code>--input \"*/*\"\n</code></pre> <p>Process non-GBC ROMs:</p> <pre><code>--input \"!(gbc)/**\"\n</code></pre> <p>Try some of these patterns for yourself on globster.xyz!</p>"}, {"location": "input/reading-archives/", "title": "Reading Archives", "text": "<p>Igir supports scanning the contents of archives for ROMs, DATs, and ROM patches.</p>"}, {"location": "input/reading-archives/#supported-types-for-reading", "title": "Supported types for reading", "text": "<p>Igir supports most common archive formats:</p> Extension Contains file CRC32s Igir can extract without a third-party binary Igir can checksum without temporary files <code>.7z</code> \u2705 \u274c Uses bundled <code>7za</code> \u274c <code>.chd</code> \u274c SHA1 \u274c Uses bundled <code>chdman</code><sup>1</sup> \u26a0\ufe0f SHA1 only for hard drive images <code>.cso</code>, <code>.zso</code>, <code>.dax</code> \u274c \u274c Uses bundled <code>maxcso</code> \u26a0\ufe0f CRC32 only <code>.gcz</code> \u274c \u274c Uses bundled <code>dolphin-tool</code> \u26a0\ufe0f CRC32, MD5, and SHA1 only <code>.gz</code>, <code>.gzip</code> \u274c CRC16 \u274c Uses bundled <code>7za</code> \u274c <code>.nkit.iso</code> (GameCube docs) \u2705 \u274c no extraction support \u2705 <code>.rar</code> \u2705 \u2705 \u274c <code>.rvz</code>, <code>.wia</code> \u274c \u274c Uses bundled <code>dolphin-tool</code> \u26a0\ufe0f CRC32, MD5, and SHA1 only <code>.tar</code> \u274c \u2705 \u2705 <code>.tar.gz</code>, <code>.tgz</code> \u274c \u2705 \u2705 <code>.z01</code> \u2705 \u274c Uses bundled <code>7za</code> \u274c <code>.zip</code>/<code>.zip64</code> (uncompressed, DEFLATE, and Zstandard) \u2705 \u2705 \u2705 <code>.zip.001</code> \u2705 \u274c Uses bundled <code>7za</code> \u274c <code>.zipx</code> \u2705 \u274c Uses bundled <code>7za</code> \u274c <p> <sup>1</sup> may require you to install SDL2 manually, see the chdman-js README. </p> <p>You should prefer archive formats that have CRC32 checksum information for each file.</p> <p>By default, Igir uses CRC32 information to match ROMs to DAT entries. If an archive already contains CRC32 information for each file, then Igir doesn't need to extract any file to compute its CRC32. This can save a lot of time on large archives.</p> <p>This is why you should use the <code>igir zip</code> command when organizing your primary ROM collection. It is much faster for Igir to scan archives with CRC32 information, speeding up actions such as merging new ROMs into an existing collection.</p> <p>You should prefer archive formats that Igir can extract natively.</p> <p>Somewhat proprietary archive formats such as <code>.7z</code> and <code>.rar</code> require Igir to use an external tool to enumerate and extract files. This can greatly slow down processing speed.</p> <p>This is why Igir uses <code>.zip</code> as its output archive of choice, <code>.zip</code> files are easy and fast to read, even if they can't offer as high of compression as other formats.</p>"}, {"location": "input/reading-archives/#exact-archive-matching", "title": "Exact archive matching", "text": "<p>Some DAT files such as the libretro BIOS System.dat catalog archives such as zip files, rather than the contents of those archives. By default, Igir will try to detect DATs like these and calculate checksums for all archive files, in addition to the files they contain.</p> <p>This adds a potentially non-trivial amount of processing time during ROM scanning, so this behavior can be turned off with the option:</p> <pre><code>--input-checksum-archives never\n</code></pre> <p>If for some reason Igir isn't identifying an input file correctly as an archive, this additional processing can be forced with the option:</p> <pre><code>--input-checksum-archives always\n</code></pre>"}, {"location": "input/reading-archives/#checksum-cache", "title": "Checksum cache", "text": "<p>It can be expensive to calculate checksums of files within archives, especially MD5, SHA1, and SHA256. If Igir needs to calculate a checksum not easily read from the archive (see above), it will cache the result in a file named <code>igir.cache</code>. This cached result will then be used as long as the input file's size and modified timestamp remain the same.</p> <p>The location of this cache file can be controlled with the <code>--cache-path &lt;path&gt;</code> option, or caching can be disabled entirely with the <code>--disable-cache</code> option. You can safely delete <code>igir.cache</code> when Igir isn't running if the file becomes too large for you.</p>"}, {"location": "misc/rom-dumping/", "title": "ROM Dumping", "text": "<p>Danger</p> <p>An obligatory warning about downloading ROMs:</p> <p>Emulators are generally legal, as long as they don't include copyrighted software such as a console BIOS. Downloading ROM files that you do not own is piracy which is illegal in many countries.</p> <p>Info</p> <p>Dumping.Guide and Emulation General Wiki are some of the best resources for legally creating ROM files from games you own.</p> <p>Here is a condensed version that isn't guaranteed to be up to date.</p>", "boost": 0.5}, {"location": "misc/rom-dumping/#generation-1-5-cartridge-based-consoles", "title": "Generation 1-5 cartridge-based consoles", "text": "Dumpable with special hardware Open Source Cartridge Reader(Save the Hero Builders) INLretro Dumper Retrode Other hardware Nintendo - GB, GBC, GBA \u2705 \u2705 \u2705 (w/ adapter) GB Operator Nintendo - NES/Famicom \u2705 (V3 w/ adapter) \u2705 \u274c Nintendo - Nintendo 64 \u2705 including controller pak saves (V3 w/ addon for EEPROM saves) \u2705 \u2705 including controller park saves (w/ adapter) Nintendo - SNES/SFC \u2705 (V3 w/ addon for some) \u2705 \u2705 Sega - Game Gear \u2705 (w/ Retrode Master System adapter) \u274c \u2705 (w/ Master System adapter) Sega - Genesis/MD \u2705 \u2705 \u2705 Sega - Master System \u2705 (V3 w/ adapter) \u274c \u2705 (w/ adapter)", "boost": 0.5}, {"location": "misc/rom-dumping/#generation-6-and-disk-based-consoles", "title": "Generation 6+ and disk-based consoles", "text": "Dumpable with software Software for native hardware Other hardware Nintendo - 3DS GodMode9 Nintendo - DS, DSi GodMode9 (w/ 3DS), GodMode9i (w/ DSi), wooddumper (w/ DS) Nintendo - Famicom Disk FDSStick Nintendo - Switch nxdumptool Mig Flash Dumper Sony - PSP UMD Image Creator, PSP Filer Sony - PlayStation Vita psvgamesd", "boost": 0.5}, {"location": "misc/rom-dumping/#optical-based-consoles", "title": "Optical-based consoles", "text": "Optical-based consoles Media Preservation Frontend (MPF) (w/ PC) Software for native hardware Microsoft - Xbox, 360, One \u2705 Nintendo - Gamecube \u26a0\ufe0f with specific drives and workarounds CleanRip (w/ Wii) Nintendo - Wii \u26a0\ufe0f with specific drives and workarounds CleanRip Nintendo - Wii U \u274c wudump Sega - Dreamcast \u26a0\ufe0f with specific drives and workarounds SD Rip Sega - Saturn \u2705 Sony - PlayStation 1, 2 \u2705 Sony - PlayStation 3 \u274c ManaGunZ, multiMAN", "boost": 0.5}, {"location": "misc/torrentzip/", "title": "TorrentZip Specification", "text": "<p>Note</p> <p>You do not need to understand the technical details of TorrentZip to use Igir. Igir creates TorrentZip archives by default with the <code>igir zip</code> command. If you wish to use the more highly compressed but less supported Zstandard algorithm, see the <code>--zip-format rvzstd</code> option.</p> <p>Warning</p> <p>The original TorrentZip source code is on SourceForge, but nearly no documentation is provided. A mirror of the README included in published archives (but not available through CVS) is available on GitHub.</p> <p>The information contained here is pieced together from the official README, RomVault's documentation, Uwe Deportivo's Go implementation, and clean-room reverse engineering the behavior of various other ROM managers. It is not guaranteed to be 100% accurate, and it may require updates over time.</p> <p>TorrentZip is a set of rules for creating deterministic zip archives. That means that the same input files will produce the exact same zip archive every time, with any tool, on any OS.</p>", "boost": 0.5}, {"location": "misc/torrentzip/#history", "title": "History", "text": "<p>From a mirror of the official README:</p> <p>TorrentZip (TZ) is a replacement for MAMEZip. It creates byte-for-byte exact zip files on any machine. This allows people to join a torrent (after they have converted their zip files with TZ) with a partial romset, thus preventing them from having to download the entire set again. Because of the way it creates identical zips, the file hashes will always match those in the original torrent. It has been written in ANSI and POSIX compliant C such that it can be built and run cross-platform (Windows, Linux, OS-X etc) and has been tested on 32bit, 64bit, Little-Endian and Big-Endian architectures.</p> <p>Tip</p> <p>Igir supports \"rebuilding\" or \"fixing\" MAME sets between different emulator versions. This may cause some incomplete ROM sets, which is one reason a person would join a torrent with existing files.</p> <p>SourceForge indicates that TorrentZip was created in 2005, and it was released under GPL v2.0.</p>", "boost": 0.5}, {"location": "misc/torrentzip/#rvzstd", "title": "RVZSTD", "text": "<p>In June 2020, v6.3.7 of the <code>APPNOTE.TXT</code> zip file format specification added support for Zstandard compression, an algorithm developed by Facebook. Zstandard can compress files more efficiently, and compress &amp; decompress them faster than other Zip-supported compression algorithms such as DEFLATE, BZIP2, LZMA, and PPMd+.</p> <p>In January 2024, MAME v0.262 added support for Zstandard compression in zip archives and CHD files.</p> <p>In April 2024, RomVault v3.7.0 defined a derivative of the TorrentZip specification called \"RVZSTD\" that uses Zstandard compression instead of DEFLATE. Igir can create RVZSTD archives if specified with the <code>--zip-format &lt;format&gt;</code> option.</p>", "boost": 0.5}, {"location": "misc/torrentzip/#achieving-deterministic-archives", "title": "Achieving deterministic archives", "text": "<p>For TorrentZip archives to be deterministic (compress the same every time), they must follow these rules:</p> <p>File order:</p> <ul> <li>Files must be sorted by their lowercase filename.</li> </ul> <p>Filenames:</p> <ul> <li>Must use the forward slash (<code>/</code>) as the path separator when inside a subdirectory (note that <code>/</code> is the only legal path separator in zip files, but it doesn't stop some programs from using <code>\\</code> anyway).</li> <li>Filenames that can't be CP437-encoded should be UTF-8-encoded and have the associated general purpose bit flag 11 set in both the local file header and central directory file header.</li> </ul> <p>File properties:</p> <ul> <li>The last modified timestamp for files must all be set to a fixed value (described below), which differs between TorrentZip and RVZSTD.</li> </ul> <p>Directories:</p> <ul> <li> <p>Directory entries are permitted (entries with a <code>/</code> at the end of the filename, an uncompressed size of 0, and an uncompressed CRC-32 of <code>00000000</code>), but should only be included when its existence can't be inferred from another file entry.</p> <p>For example, <code>b/</code> is a legal directory entry here because it has no files inside of it:</p> <pre><code>a/a1.rom\nb/\n</code></pre> <p>but <code>a/</code> is not a legal directory here as its existence can be inferred from the file <code>a/a1.rom</code>:</p> <pre><code>a/\na/a1.rom\n</code></pre> </li> </ul> <p>File data compression:</p> <p>Files must be compressed with an exact library version and settings. Changes to either of these may produce differences in compressed files.</p> <p>TorrentZip:</p> <ul> <li>DEFLATE compression with zlib v1.1.3 (July 9, 1998)</li> <li>Compression level 9 (<code>Z_BEST_COMPRESSION</code>)</li> <li>Window size of -15 (<code>-MAX_WBITS</code>), which omits the header and trailing checksum</li> </ul> <p>RVZSTD:</p> <ul> <li>Zstandard v1.5.5 (April 2023)<ul> <li>Compiled with <code>-DZSTD_MULTITHREAD</code></li> </ul> </li> <li>Compression level 19 (<code>ZSTD_CLEVEL_MAX</code>), which has the compression parameters:<ul> <li><code>ZSTD_c_windowLog</code>: 23 (2^23 bytes == 8 MiB)</li> <li><code>ZSTD_c_chainLog</code>: 24 (2^24 == 16,777,216 entries)</li> <li><code>ZSTD_c_hashLog</code>: 22 (2^22 == 4,194,304 entries)</li> <li><code>ZSTD_c_searchLog</code>: 7 (2^7 == 128 comparisons)</li> <li><code>ZSTD_c_minMatch</code>: 3 (bytes)</li> <li><code>ZSTD_c_targetLength</code>: 256 (bytes)</li> <li><code>ZSTD_c_strategy</code>: <code>ZSTD_btultra2</code></li> </ul> </li> <li>Using streaming compression (<code>ZSTD_compressStream2()</code>), with <code>ZSTD_c_nbWorkers</code> &gt;0<ul> <li>Except if the uncompressed file is empty (is of size 0), in which case <code>ZSTD_compress()</code> should be used (no streaming and no workers/threads)</li> </ul> </li> <li>With no other options set (the defaults are used), such as:<ul> <li>Long-distance matching (<code>ZSTD_c_enableLongDistanceMatching</code> default OFF, <code>ZSTD_c_ldm*</code> options)</li> <li>Frame checksums (<code>ZSTD_c_checksumFlag</code> default OFF)</li> <li>Multi-threading options (<code>ZSTD_c_jobSize</code>, <code>ZSTD_c_overlapLog</code>)</li> </ul> </li> </ul> <p>Archive comment:</p> <p>TorrentZip archives make use of a checksum in the archive comment to quickly verify the validity of the file. It is fast to read this checksum because the archive comment is always the last data in a zip archive.</p> <p>The checksum is calculated by taking the CRC-32 of the full bytes of every central directory file header, concatenated together in the order they appear in the archive (in other words, all the bytes between the \"start of central directory\" and \"end of central directory\"). This means that any change to a file's name, size, checksum, or other properties will change the archive checksum.</p> <p>This checksum is then converted to hexadecimal uppercase, with the start padded to a length of 8 with the character <code>0</code>. The comment is then prefixed with a string depending on the format:</p> <ul> <li>TorrentZip: <code>TORRENTZIPPED-ABCD1234</code> (always a length of 22 characters/bytes)</li> <li>RVZSTD: <code>RVZSTD-0987FEDC</code> (always a length of 15 characters/bytes)</li> </ul> <p>The comment is written as-is (does not have its byte order reversed) even though numeric values are all written in little-endian byte order.</p>", "boost": 0.5}, {"location": "misc/torrentzip/#zip-features-used", "title": "Zip features used", "text": "<p>TorrentZip archives are valid zip files that adhere to PKWARE's <code>APPNOTE.TXT</code> zip file format specification. This includes using little-endian (reverse) byte order.</p> <p>TorrentZip makes use of these zip features:</p> <ul> <li>UTF-8 filename encoding via the general purpose bit flag 11 when necessary</li> <li>Zip64 extended information extra fields, an end of central directory record, and an end of central directory record locator when necessary</li> </ul> <p>TorrentZip does not use these less common features:</p> <ul> <li>Encryption of any kind, including:<ul> <li>Local file encryption headers</li> <li>Archive decryption header</li> <li>General purpose bit flag 6 for strong encryption</li> <li>General purpose bit flag 13 for local file value masking</li> </ul> </li> <li>Extensible data fields other than Zip64 (0x0001)</li> <li>Local file data descriptors<ul> <li>Therefore, the general purpose bit flag 3 is also not used</li> </ul> </li> <li>Archive extra data record</li> </ul>", "boost": 0.5}, {"location": "misc/torrentzip/#file-layout", "title": "File layout", "text": "<p>Here is a visual representation of a TorrentZip archive, with details about every zip feature &amp; field used. The descriptions used match the <code>APPNOTE.TXT</code> zip file format specification language.</p> <pre><code>+----------------------------------------------------------------------------------------------------------+\n|                                                                                                          |\n|                                            Local file headers                                            |\n|                                                                                                          |\n+------------+----------------------------+---------+---------+-------------------------+------------------+\n| Local      |         Description        |  Offset |   Size  |        TorrentZip       |      RVZSTD      |\n| file       |                            | (bytes) | (bytes) |                         |                  |\n| header 1   +----------------------------+---------+---------+-------------------------+------------------+\n|            | Local file header          | 0       | 4       | 0x04034b50 (\"PK\u2665\u2666\")                        |\n|            | signature                  |         |         |                                            |\n|            +----------------------------+---------+---------+-------------------------+------------------+\n|            | Version needed             | 4       | 2       | 45 if a Zip64 extra     | 63               |\n|            | to extract                 |         |         | data record is          |                  |\n|            |                            |         |         | required, otherwise 20  |                  |\n|            +----------------------------+---------+---------+-------------------------+------------------+\n|            | General purpose bit flag   | 6       | 2       | 0x02 (max compression) if the file name    |\n|            |                            |         |         | is CP437-encodable; 0x02|0x800=0x802 if    |\n|            |                            |         |         | the file name requires UTF-8 encoding      |\n|            +----------------------------+---------+---------+-------------------------+------------------+\n|            | Compression method         | 8       | 2       | 8 (for DEFLATE)         | 93 (for Zstd)    |\n|            +----------------------------+---------+---------+-------------------------+------------------+\n|            | Last mod file time         | 10      | 2       | 48128 (11:32:00 PM)     | 0 (00:00:00 AM)  |\n|            +----------------------------+---------+---------+-------------------------+------------------+\n|            | Last mod file date         | 12      | 2       | 8600 (Dec 24, 1996)     | 0 (Jan 1, 1980)  |\n|            +----------------------------+---------+---------+-------------------------+------------------+\n|            | CRC-32                     | 14      | 4       | The uncompressed file's CRC-32 checksum    |\n|            +----------------------------+---------+---------+--------------------------------------------+\n|            | Compressed size            | 18      | 4       | 0xFFFFFFFF if the compressed OR            |\n|            |                            |         |         | uncompressed size &gt;=0xFFFFFFFF,            |\n|            |                            |         |         | otherwise the compressed size              |\n|            +----------------------------+---------+---------+--------------------------------------------+\n|            | Uncompressed size          | 22      | 4       | 0xFFFFFFFF if the compressed OR            |\n|            |                            |         |         | uncompressed size &gt;=0xFFFFFFFF,            |\n|            |                            |         |         | otherwise the uncompressed size            |\n|            +----------------------------+---------+---------+--------------------------------------------+\n|            | File name length (n)       | 26      | 2       | The length in bytes of the                 |\n|            |                            |         |         | encoded filename                           |\n|            +----------------------------+---------+---------+--------------------------------------------+\n|            | Extra field length (m)     | 28      | 2       | 0 if the uncompressed size is              |\n|            |                            |         |         | &lt;0xFFFFFFFF, otherwise 20 bytes            |\n|            |                            |         |         | +8 more bytes if this local file           |\n|            |                            |         |         | header's byte offset is &gt;=0xFFFFFFFF       |\n|            +----------------------------+---------+---------+--------------------------------------------+\n|            | File name                  | 30      | n       | The CP437 or UTF-8 encoded filename        |\n|            +----------+-----------------+---------+---------+--------------------------------------------+\n|            | Extra    | Extra data      | 30+n    | 2       | 0x0001 (Zip64 extended information         |\n|            | field    | record 1:       |         |         | extra field)                               |\n|            | (present | header ID       |         |         |                                            |\n|            | if extra +-----------------+---------+---------+--------------------------------------------+\n|            | field    | Extra data      | 30+n+2  | 2       | (same as the extra field length above      |\n|            | length   | record 1:       |         |         | -4 bytes for the header ID &amp; data          |\n|            | &gt;0)      | record size     |         |         | size fields)                               |\n|            |          +-----------------+---------+---------+--------------------------------------------+\n|            |          | Zip64:          | 30+n+4  | 8       | The uncompressed file's size               |\n|            |          | uncompressed    |         |         | (always present)                           |\n|            |          | file size       |         |         |                                            |\n|            |          +-----------------+---------+---------+--------------------------------------------+\n|            |          | Zip64: size of  | 30+n+12 | 8       | The compressed file's size                 |\n|            |          | compressed data |         |         | (always present)                           |\n|            |          +-----------------+---------+---------+--------------------------------------------+\n|            |          | Zip64: offset   | 30+n+20 | 0 or 8  | Present if this local file header's byte   |\n|            |          | of local header |         |         | offset is &gt;=0xFFFFFFFF, otherwise omitted  |\n|            |          +-----------------+---------+---------+--------------------------------------------+\n|            |          | Zip64: number   | 30+n+28 | 0       | (not used / omitted)                       |\n|            |          | of the disk on  |         |         |                                            |\n|            |          | which this      |         |         |                                            |\n|            |          | file starts     |         |         |                                            |\n|            |          +-----------------+---------+---------+--------------------------------------------+\n|            |          | (no other extra data records are used)                                           |\n+------------+----------+---------------------------+---------+--------------------------------------------+\n| Encryption header 1                               | 0       | (not used / omitted)                       |\n+---------------------------------------------------+---------+-------------------------+------------------+\n| File data 1                                       | *       | File's contents         | File's contents  |\n|                                                   |         | compressed by zlib      | compressed by    |\n|                                                   |         | v1.1.3 (Jul 9, 1998)    | zstd v1.5.5      |\n|                                                   |         | at compression          | (Apr 2023)       |\n|                                                   |         | level 9 (max)           | at compression   |\n|                                                   |         |                         | level 19         |\n+---------------------------------------------------+---------+-------------------------+------------------+\n| Data descriptor 1                                 | 0       | (not used / omitted)                       |\n+---------------------------------------------------+---------+--------------------------------------------+\n| Local file header 2                               | *       | (same format as above)                     |\n+---------------------------------------------------+---------+--------------------------------------------+\n| File data 2                                       | *       | (same compression methodology as above)    |\n+---------------------------------------------------+---------+--------------------------------------------+\n| Data descriptor 2                                 | 0       | (not used / omitted)                       |\n+---------------------------------------------------+---------+--------------------------------------------+\n| ...                                                                                                      |\n+---------------------------------------------------+---------+--------------------------------------------+\n| Local file header N                               | *       | (same format as above)                     |\n+---------------------------------------------------+---------+--------------------------------------------+\n| File data N                                       | *       | (same compression methodology as above)    |\n+---------------------------------------------------+---------+--------------------------------------------+\n| Data descriptor N                                 | 0       | (not used / omitted)                       |\n+---------------------------------------------------+---------+--------------------------------------------+\n| Archive decryption header                         | 0       | (not used / omitted)                       |\n+---------------------------------------------------+---------+--------------------------------------------+\n| Archive extra data record                         | 0       | (not used / omitted)                       |\n+---------------------------------------------------+---------+--------------------------------------------+\n|                                                                                                          |\n|                                    Start of central directory (\"SOCD\")                                   |\n|                                                                                                          |\n+------------+----------------------------+---------+---------+-------------------------+------------------+\n| Central    |         Description        |  Offset |   Size  |        TorrentZip       |      RVZSTD      |\n| directory  |                            | (bytes) | (bytes) |                         |                  |\n| file       +----------------------------+---------+---------+-------------------------+------------------+\n| header     | Central file               | 0       | 4       | 0x02014b50 (\"PK\u263a\ufe0e\u263b\")                        |\n| (\"CDFH\") 1 | header signature           |         |         |                                            |\n|            +----------------------------+---------+---------+--------------------------------------------+\n|            | Version made by            | 4       | 2       | 0                                          |\n|            +----------------------------+---------+---------+--------------------------------------------+\n|            | Version needed to extract  | 6       | 2       | (same as local file header)                |\n|            +----------------------------+---------+---------+--------------------------------------------+\n|            | General purpose bit flag   | 8       | 2       | (same as local file header)                |\n|            +----------------------------+---------+---------+--------------------------------------------+\n|            | Compression method         | 10      | 2       | (same as local file header)                |\n|            +----------------------------+---------+---------+--------------------------------------------+\n|            | Last mod file time         | 12      | 2       | (same as local file header)                |\n|            +----------------------------+---------+---------+--------------------------------------------+\n|            | Last mod file date         | 14      | 2       | (same as local file header)                |\n|            +----------------------------+---------+---------+--------------------------------------------+\n|            | CRC-32                     | 16      | 4       | (same as local file header)                |\n|            +----------------------------+---------+---------+--------------------------------------------+\n|            | Compressed size            | 20      | 4       | (same as local file header)                |\n|            +----------------------------+---------+---------+--------------------------------------------+\n|            | Uncompressed size          | 24      | 4       | (same as local file header)                |\n|            +----------------------------+---------+---------+--------------------------------------------+\n|            | File name length (n)       | 28      | 2       | (same as local file header)                |\n|            +----------------------------+---------+---------+--------------------------------------------+\n|            | Extra field length (m)     | 30      | 2       | 0 if the uncompressed size, compressed     |\n|            |                            |         |         | size, and local file header byte offset    |\n|            |                            |         |         | are all &lt;0xFFFFFFFF; otherwise 4 +8 bytes  |\n|            |                            |         |         | for each field that is &gt;=0xFFFFFFFF        |\n|            |                            |         |         | (for a maximum of 28 bytes)                |\n|            +----------------------------+---------+---------+--------------------------------------------+\n|            | File comment length (k)    | 32      | 2       | 0                                          |\n|            +----------------------------+---------+---------+--------------------------------------------+\n|            | Disk number start          | 34      | 2       | 0                                          |\n|            +----------------------------+---------+---------+--------------------------------------------+\n|            | Internal file attributes   | 36      | 2       | 0                                          |\n|            +----------------------------+---------+---------+--------------------------------------------+\n|            | External file attributes   | 38      | 4       | 0                                          |\n|            +----------------------------+---------+---------+--------------------------------------------+\n|            | Relative offset of         | 42      | 4       | min(the local file header's byte offset,   |\n|            | local header               |         |         | 0xFFFFFFFF)                                |\n|            +----------------------------+---------+---------+--------------------------------------------+\n|            | File name                  | 46      | n       | (same as local file header)                |\n|            +----------+-----------------+---------+---------+--------------------------------------------+\n|            | Extra    | Extra data      | 46+n    | 2       | 0x0001 (Zip64 extended information         |\n|            | field    | record 1:       |         |         | extra field)                               |\n|            | (present | header ID       |         |         |                                            |\n|            | if extra +-----------------+---------+---------+--------------------------------------------+\n|            | field    | Extra data      | 46+n+2  | 2       | (same as the extra field length above      |\n|            | length   | record 1:       |         |         | -4 bytes for the header ID &amp; data          |\n|            | &gt;0)      | size            |         |         | size fields)                               |\n|            |          +-----------------+---------+---------+--------------------------------------------+\n|            |          | Zip64:          | 46+n+10 | 0 or 8  | Present if uncompressed size               |\n|            |          | uncompressed    |         |         | is &gt;=0xFFFFFFFF                            |\n|            |          | file size       |         |         |                                            |\n|            |          +-----------------+---------+---------+--------------------------------------------+\n|            |          | Zip64: size of  | *       | 0 or 8  | Present if compressed size                 |\n|            |          | compressed data |         |         | is &gt;=0xFFFFFFFF                            |\n|            |          +-----------------+---------+---------+--------------------------------------------+\n|            |          | Zip64: offset   | *       | 0 or 8  | Present if the local file header's         |\n|            |          | of local        |         |         | byte offset is &gt;=0xFFFFFFFF                |\n|            |          | header          |         |         |                                            |\n|            |          +-----------------+---------+---------+--------------------------------------------+\n|            |          | Zip64: number   | *       | 0       | (not used / omitted)                       |\n|            |          | of the disk on  |         |         |                                            |\n|            |          | which this      |         |         |                                            |\n|            |          | file starts     |         |         |                                            |\n|            |          +-----------------+---------+---------+--------------------------------------------+\n|            |          | (no other extra data records are used)                                           |\n|            +----------+-----------------+---------+---------+--------------------------------------------+\n|            | File comment               | 46+n+m  | k (0)   | (not used / omitted)                       |\n+------------+----------------------------+---------+---------+--------------------------------------------+\n| Central directory file header 2                   | *       | (same format as above)                     |\n+---------------------------------------------------+---------+--------------------------------------------+\n| ...                                                                                                      |\n+---------------------------------------------------+---------+--------------------------------------------+\n| Central directory file header N                   | *       | (same format as above)                     |\n+---------------------------------------------------+---------+--------------------------------------------+\n|                                                                                                          |\n|                                     End of central directory (\"EOCD\")                                    |\n|                                                                                                          |\n+------------+----------------------------+---------+---------+-------------------------+------------------+\n| Zip64 end  |         Description        |  Offset |   Size  |        TorrentZip       |      RVZSTD      |\n| of central |                            | (bytes) | (bytes) |                         |                  |\n| directory  +----------------------------+---------+---------+-------------------------+------------------+\n| record     | Zip64 end of central       | 0       | 4       | 0x06064b50 (\"PK\u2660\ufe0e\u2660\ufe0e\")                        |\n| (\"EOCD64\") | dir signature              |         |         |                                            |\n|            +----------------------------+---------+---------+--------------------------------------------+\n| Present if | Size of Zip64 end of       | 4       | 8       | 44                                         |\n| any true:  | central directory          |         |         |                                            |\n|            | record                     |         |         |                                            |\n| - Length   +----------------------------+---------+---------+--------------------------------------------+\n|   of all   | Version made by            | 12      | 2       | 45                                         |\n|   CDFH     +----------------------------+---------+---------+--------------------------------------------+\n|   together | Version needed to extract  | 14      | 2       | 45                                         |\n|   &gt;=       +----------------------------+---------+---------+--------------------------------------------+\n| 0xFFFFFFFF | Number of this disk        | 16      | 4       | 0                                          |\n|            +----------------------------+---------+---------+--------------------------------------------+\n| - SOCD     | Number of the disk         | 20      | 4       | 0                                          |\n|   offset   | with the start of          |         |         |                                            |\n|   &gt;=       | the central directory      |         |         |                                            |\n| 0xFFFFFFFF +----------------------------+---------+---------+--------------------------------------------+\n|            | Total number of entries    | 24      | 8       | The number of files in the archive         |\n| - Local    | in the central directory   |         |         |                                            |\n|   file     | on this disk               |         |         |                                            |\n|   headers  +----------------------------+---------+---------+--------------------------------------------+\n|   count    | Total number of entries    | 32      | 8       | The number of files in the archive         |\n|   &gt;=0xFFFF | in the central directory   |         |         |                                            |\n|            +----------------------------+---------+---------+--------------------------------------------+\n|            | Size of the                | 40      | 8       | The sum of every central file directory    |\n|            | central directory          |         |         | header's length                            |\n|            +----------------------------+---------+---------+--------------------------------------------+\n|            | Offset of start of         | 48      | 8       | The byte offset to the start of the        |\n|            | central directory          |         |         | central directory (the first central       |\n|            | with respect to            |         |         | directory file header)                     |\n|            | the starting disk number   |         |         |                                            |\n|            +----------------------------+---------+---------+--------------------------------------------+\n|            | Zip64 extensible           | 56      | *       | (not used / omitted)                       |\n|            | data sector                |         |         |                                            |\n+------------+----------------------------+---------+---------+-------------------------+------------------+\n| Zip64 end  |         Description        |  Offset |   Size  |        TorrentZip       |      RVZSTD      |\n| of central |                            | (bytes) | (bytes) |                         |                  |\n| directory  +----------------------------+---------+---------+-------------------------+------------------+\n| locator    | Zip64 end of central dir   | 0       | 4       | 0x07064b50 (\"PK\u2660\ufe0e\u2022\")                        |\n| (present   | locator signature          |         |         |                                            |\n| if Zip64   +----------------------------+---------+---------+--------------------------------------------+\n| EOCD is    | Number of the disk with    | 4       | 4       | 0                                          |\n| present)   | the start of the Zip64     |         |         |                                            |\n|            | end of central             |         |         |                                            |\n|            | directory                  |         |         |                                            |\n|            +----------------------------+---------+---------+--------------------------------------------+\n|            | Relative offset of the     | 8       | 8       | The byte offset to the Zip64 end of        |\n|            | Zip64 end of central       |         |         | central directory                          |\n|            | directory record           |         |         |                                            |\n|            +----------------------------+---------+---------+--------------------------------------------+\n|            | Total number of disks      | 16      | 4       | 1                                          |\n+------------+----------------------------+---------+---------+-------------------------+------------------+\n| End of     |         Description        |  Offset |   Size  |        TorrentZip       |      RVZSTD      |\n| central    |                            | (bytes) | (bytes) |                         |                  |\n| directory  +----------------------------+---------+---------+-------------------------+------------------+\n| record     | End of central dir         | 0       | 4       | 0x06054b50 (\"PK\u2663\ufe0e\u2660\ufe0e\")                        |\n|            | signature                  |         |         |                                            |\n|            +----------------------------+---------+---------+--------------------------------------------+\n|            | Number of this disk        | 4       | 2       | 0                                          |\n|            +----------------------------+---------+---------+--------------------------------------------+\n|            | Number of the disk with    | 6       | 2       | 0                                          |\n|            | the start of the           |         |         |                                            |\n|            | central directory          |         |         |                                            |\n|            +----------------------------+---------+---------+--------------------------------------------+\n|            | Total number of entries    | 8       | 2       | min(the number of files in the archive,    |\n|            | in the central directory   |         |         | 0xFFFF)                                    |\n|            | on this disk               |         |         |                                            |\n|            +----------------------------+---------+---------+--------------------------------------------+\n|            | Total number of entries    | 10      | 2       | min(the number of files in the archive,    |\n|            | in the central directory   |         |         | 0xFFFF)                                    |\n|            +----------------------------+---------+---------+--------------------------------------------+\n|            | Size of the                | 12      | 4       | min(the sum of every central file          |\n|            | central directory          |         |         | directory header's length, 0xFFFFFFFF)     |\n|            +----------------------------+---------+---------+--------------------------------------------+\n|            | Offset of start of         | 16      | 4       | min(the byte offset to the start of the    |\n|            | central directory          |         |         | central directory, 0xFFFFFFFF)             |\n|            | with respect to            |         |         |                                            |\n|            | the starting disk number   |         |         |                                            |\n|            +----------------------------+---------+---------+-------------------------+------------------+\n|            | Zip file comment           | 20      | 2       | 22                      | 15               |\n|            | length (n)                 |         |         |                         |                  |\n|            +----------------------------+---------+---------+-------------------------+------------------+\n|            | Zip file comment           | 22      | n       | \"TORRENTZIPPED-{CRC32}\" | \"RVZSTD-{CRC32}\" |\n+------------+----------------------------+---------+---------+-------------------------+------------------+\n</code></pre>", "boost": 0.5}, {"location": "output/cleaning/", "title": "Output Directory Cleaning", "text": "<p>The <code>igir clean</code> command can be used when writing (<code>igir copy</code>, <code>igir move</code>, and <code>igir link</code>) to delete files from the <code>--output &lt;path&gt;</code> directory that were not considered for writing.</p> <p>Note</p> <p>The term \"considered\" is used here because output files that already exist won't be overwritten by default. These output file paths were considered for writing, but then Igir chose not to write them.</p> <p>Only files from <code>--input &lt;path&gt;</code> directories can be used when writing to the <code>--output &lt;path&gt;</code> directory. Therefore, the output files that will be cleaned (because they weren't considered for writing) are files that:</p> <ul> <li>(When using DATs) Don't match any ROM in any DAT</li> <li>Were filtered out by filter options</li> <li>Were filtered out by 1G1R preferences</li> </ul> <p>Warning</p> <p>Because only input files will be considered for writing to the output directory, you will want your input files to be a superset of your output files. In other words, if a file isn't in your input files, it will be cleaned from your output directory.</p> <p>It is a best practice to include your output directory as an input directory when cleaning files. This will ensure any previously written valid files won't be cleaned.</p>"}, {"location": "output/cleaning/#the-golden-rule", "title": "The golden rule", "text": "<p>The golden rule of the <code>igir clean</code> command is it will not delete files in any directory tree that it did not write to.</p> <p>In practical terms, this means:</p> <ol> <li>If no file was written (i.e. no input file matched any ROM in any DAT), then <code>igir clean</code> will not delete any files.</li> <li> <p>If tokens are used with the <code>--output &lt;path&gt;</code> option, only subdirectories that are written to will be considered for cleaning.</p> <p>Warning</p> <p>This behavior is different for <code>--dir-*</code> options. For example, if:</p> <ul> <li>Your input directory only includes Game Boy (<code>.gb</code>) ROMs<ul> <li>And you specify the <code>--dir-dat-name</code> option such that these ROMs will be written to <code>&lt;output&gt;/Nintendo - Game Boy/*.gb</code></li> </ul> </li> <li>And your output directory already has NES ROMs at <code>&lt;output&gt;/Nintendo - Nintendo Etertainment System/*.nes</code></li> <li>And you specify the <code>igir clean</code> command</li> </ul> <p>Then those NES ROMs will be deleted. This is because the entire <code>--output &lt;path&gt;</code> will be considered for cleaning, and no tokens were provided.</p> <p>When in doubt, you can provide the <code>--clean-dry-run</code> option to see what files would be deleted without actually deleting them.</p> </li> </ol> <p>For example, if the output directory is specified as <code>--output \"games/{mister}\"</code>, and only Game Boy Color games are found in <code>--input &lt;path&gt;</code>, then only the <code>games/Gameboy/</code> directory would be considered for cleaning. Other directories that may already exist such as <code>games/GBA/</code> and <code>games/NES/</code> would not be considered for cleaning, as Igir did not write there.</p> <p>In other words, <code>games/{mister}</code> is not equivalent to <code>games/*</code>. Igir will not indiscriminately delete files in <code>games/</code>.</p> <p>If you want to clean every directory in <code>games/</code>, you could specify it as both the <code>--input &lt;path&gt;</code> and <code>--output &lt;path&gt;</code>:</p>  Windows macOS Linux <pre><code>igir move clean --dat \"*.dat\" --input \"games\\\" --output \"games\\{mister}\\\"\n</code></pre> <pre><code>igir move clean --dat \"*.dat\" --input \"games/\" --output \"games/{mister}/\"\n</code></pre> <pre><code>igir move clean --dat \"*.dat\" --input \"games/\" --output \"games/{mister}/\"\n</code></pre>"}, {"location": "output/cleaning/#exclusions", "title": "Exclusions", "text": "<p>The <code>--clean-exclude &lt;path&gt;</code> option exists so that one or more paths (with support for globbing) can be excluded from deletion.</p> <p>See the Analogue Pocket page for a practical example.</p>"}, {"location": "output/cleaning/#backing-up-cleaned-files", "title": "Backing up cleaned files", "text": "<p>By default, Igir will recycle cleaned files, and if recycle fails, then it will delete them. This is potentially destructive, so a <code>--clean-backup &lt;path&gt;</code> option is provided to instead move files to a backup directory.</p> <p>The input directory structure is not maintained, no subdirectories will be created in the backup directory. Files of conflicting names will have a number appended to their name, e.g. <code>File (1).rom</code>.</p>"}, {"location": "output/cleaning/#dry-run", "title": "Dry run", "text": "<p>The <code>--clean-dry-run</code> option exists to see what paths <code>igir clean</code> would delete, without actually deleting them.</p> <p>Note</p> <p>You will want to set the log level to at least DEBUG (<code>-vv</code>) in order to see actions that were skipped, such as cleaning.</p> <p>Usage:</p>  Windows macOS Linux <pre><code>igir [commands..] clean [options] --clean-dry-run -vv\n</code></pre> <pre><code>igir [commands..] clean [options] --clean-dry-run -vv\n</code></pre> <pre><code>igir [commands..] clean [options] --clean-dry-run -vv\n</code></pre>"}, {"location": "output/options/", "title": "ROM Writing Options", "text": ""}, {"location": "output/options/#overwriting-files", "title": "Overwriting files", "text": "<p>By default, Igir will not overwrite or delete any files already in the output directory.</p> <p>To change this behavior, the <code>--overwrite</code> option will force overwriting files in the output directory as necessary. Be careful with this option as it can cause unnecessary wear and tear on your hard drives.</p> <p>The <code>--overwrite-invalid</code> option can also overwrite files in the output directory, but only if those files don't match the expected size and checksum. This uses the same logic as the <code>igir test</code> command. Combining this option with the <code>igir clean</code> command will result in your output directory being a perfect subset of files contained in your DATs.</p>"}, {"location": "output/options/#fixing-rom-extensions", "title": "Fixing ROM extensions", "text": "<p>ROM dumpers don't always do a good job of using the generally accepted filename extension when writing files. In situations where DATs aren't provided, or information in DATs is incomplete, Igir has some ability to find the correct extension that filenames should have. This is done using file signatures, pieces of data that are common to every file of a certain format.</p> <p>Here are some examples of common mistakes:</p> Incorrect extensions Correct extension <code>.fc</code> Nintendo Family Computer<code>.nez</code> Nintendo Entertainment System<code>.unh</code> Nintendo Entertainment System (Unheadered/Headerless) <code>.nes</code> Nintendo Entertainment System <code>.sgb</code> Nintendo Super Game Boy <code>.gb</code> Nintendo Game Boy <code>.bin</code> Sega Mega Drive / Genesis<code>.gen</code> Sega Genesis <code>.md</code> Sega Mega Drive <p>This correction behavior can be controlled with the following option:</p> Mode Description <code>--fix-extension always</code> Always try to correct filename extensions, ignoring the information provided by DATs. You likely don't want this option. <code>--fix-extension auto</code> (default) When not using DATs (no <code>--dat &lt;path&gt;</code> option was provided), or when a DAT doesn't specify the filename for a ROM, then try to correct the filename extension. <code>--fix-extension never</code> Don't correct any ROM filename extensions. If a DAT doesn't provide a ROM filename, a default name of <code>&lt;game name&gt;.rom</code> will be used. <p>See the <code>igir --help</code> message for the list of all known file types.</p>"}, {"location": "output/options/#deleting-empty-directories-when-moving", "title": "Deleting empty directories when moving", "text": "<p>When moving files with the <code>igir move</code> command, by default Igir will delete any subdirectories that are left empty after the move. This behavior can be changed with the <code>--move-delete-dirs &lt;mode&gt;</code> option:</p> Mode Description <code>--move-delete-dirs always</code> Delete every empty subdirectory in every input path, regardless of whether a file was moved out of it or not. <code>--move-delete-dirs auto</code> (default) Delete subdirectories in every input path that had a file moved out of it. <code>--move-delete-dirs never</code> Never delete any input directories."}, {"location": "output/path-options/", "title": "Output Path Options", "text": "<p>Igir offer many options to control how ROMs are sorted in the specified output directory.</p> <p>All <code>--dir-*</code> options append subdirectories to whatever is specified in the <code>--output &lt;path&gt;</code> option. Many <code>--dir-*</code> options have an output path token equivalent, which also controls how ROMs are sorted.</p> <p>Multiple options can be combined, and they will be appended to the output directory in the following order:</p>"}, {"location": "output/path-options/#mirror-the-input-subdirectory", "title": "Mirror the input subdirectory", "text": "<pre><code>--dir-mirror\n</code></pre> <p>This option mirrors the subdirectory structure of where ROMs were found in one of the input directories.</p> <p>For example, if this is the input directory structure:</p> <pre><code>ROMs-Input/\n\u2514\u2500\u2500 gb\n    \u251c\u2500\u2500 mario\n    \u2502   \u251c\u2500\u2500 mario land 2.gb\n    \u2502   \u2514\u2500\u2500 mario land.gb\n    \u2514\u2500\u2500 pokemon\n        \u251c\u2500\u2500 pokemon blue.gb\n        \u251c\u2500\u2500 pokemon red.gb\n        \u2514\u2500\u2500 pokemon yellow.gb\n</code></pre> <p>when combined with a DAT, the ROMs will be written with a standardized name, but the output subdirectory structure will match the input:</p>  Windows macOS Linux <pre><code>igir copy ^\n  --dat \"No-Intro*.zip\" ^\n  --input \"ROMs-Input\" ^\n  --output \"ROMs-Output\" ^\n  --dir-mirror\n</code></pre> <pre><code>igir copy \\\n  --dat \"No-Intro*.zip\" \\\n  --input \"ROMs-Input/\" \\\n  --output \"ROMs-Output/\" \\\n  --dir-mirror\n</code></pre> <pre><code>igir copy \\\n  --dat \"No-Intro*.zip\" \\\n  --input \"ROMs-Input/\" \\\n  --output \"ROMs-Output/\" \\\n  --dir-mirror\n</code></pre> <pre><code>ROMs-Output/\n\u2514\u2500\u2500 gb\n    \u251c\u2500\u2500 mario\n    \u2502   \u251c\u2500\u2500 Super Mario Land (World) (Rev 1).gb\n    \u2502   \u2514\u2500\u2500 Super Mario Land 2 - 6 Golden Coins (USA, Europe) (Rev 2).gb\n    \u2514\u2500\u2500 pokemon\n        \u251c\u2500\u2500 Pokemon - Blue Version (USA, Europe) (SGB Enhanced).gb\n        \u251c\u2500\u2500 Pokemon - Red Version (USA, Europe) (SGB Enhanced).gb\n        \u2514\u2500\u2500 Pokemon - Yellow Version - Special Pikachu Edition (USA, Europe) (CGB+SGB Enhanced).gb\n</code></pre> <p>Tip</p> <p>This option is best used to preserve some sort of manual sorting, otherwise you will probably want to combine some of the below options instead.</p>"}, {"location": "output/path-options/#mirror-the-dat-subdirectory", "title": "Mirror the DAT subdirectory", "text": "<pre><code>--dir-dat-mirror\n</code></pre> <p>This option mirrors the subdirectory structure of where DATs were found in one of the DAT directories.</p> <p>For example, if this is the DAT directory structure:</p> <pre><code>DATs/\n\u251c\u2500\u2500 No-Intro Love Pack (PC) (2025-05-09)\n\u2502   \u2514\u2500\u2500 No-Intro\n\u2502      \u251c\u2500\u2500 Sega - Game Gear (Parent-Clone) (20241203-185356).dat\n\u2502      \u251c\u2500\u2500 Sega - Master System - Mark III (Parent-Clone) (20241225-050512).dat\n\u2502      \u251c\u2500\u2500 Sega - Mega Drive - Genesis (Parent-Clone) (20250210-102212).dat\n\u2502      \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 Redump (2025-05-09)\n    \u251c\u2500\u2500 Sony - PlayStation - Datfile (10853) (2025-05-09 17-16-34).dat\n    \u251c\u2500\u2500 Sony - PlayStation 2 - Datfile (11623) (2025-05-09 15-01-56).dat\n    \u251c\u2500\u2500 Sony - PlayStation - Datfile (10853) (2025-05-09 17-16-34).dat\n    \u2514\u2500\u2500 ...\n</code></pre> <p>ROMs that are matched to one of those DATs will use the DAT's relative dirname in the output directory.</p> <p>For example, given a command such as:</p>  Windows macOS Linux <pre><code>igir copy ^\n  --dat \"DATs\\\" ^\n  --input \"ROMs-Input\" ^\n  --output \"ROMs-Output\" ^\n  --dir-mirror\n</code></pre> <pre><code>igir copy \\\n  --dat \"DATs/\" \\\n  --input \"ROMs-Input/\" \\\n  --output \"ROMs-Output/\" \\\n  --dir-mirror\n</code></pre> <pre><code>igir copy \\\n  --dat \"DATs/\" \\\n  --input \"ROMs-Input/\" \\\n  --output \"ROMs-Output/\" \\\n  --dir-mirror\n</code></pre> <p>you would get a result similar to:</p> <pre><code>ROMs-Output/\n\u251c\u2500\u2500 No-Intro Love Pack (PC) (2025-05-09)\n\u2502   \u2514\u2500\u2500 No-Intro\n\u2502       \u251c\u2500\u2500 Alex Kidd in Miracle World (USA, Europe, Brazil) (En) (Rev 1).sms\n\u2502       \u251c\u2500\u2500 Earthworm Jim 2 (USA).md\n\u2502       \u251c\u2500\u2500 Psycho Fox (USA, Europe, Brazil) (En) (Beta).sms\n\u2502       \u251c\u2500\u2500 Shinobi II - The Silent Fury (World).gg\n\u2502       \u251c\u2500\u2500 Rocket Knight Adventures (USA).md\n\u2502       \u2514\u2500\u2500 Sonic Drift 2 (World).gg\n\u2514\u2500\u2500 Redump (2025-05-09)\n    \u251c\u2500\u2500 Devil May Cry (USA).iso\n    \u251c\u2500\u2500 Spyro - Year of the Dragon (USA)\n    \u2502   \u251c\u2500\u2500 Spyro - Year of the Dragon (USA).bin\n    \u2502   \u2514\u2500\u2500 Spyro - Year of the Dragon (USA).cue\n    \u251c\u2500\u2500 Tony Hawk's Pro Skater 2 (USA)\n    \u2502   \u251c\u2500\u2500 Tony Hawk's Pro Skater 2 (USA).bin\n    \u2502   \u2514\u2500\u2500 Tony Hawk's Pro Skater 2 (USA).cue\n    \u2514\u2500\u2500 SSX on Tour (USA).iso\n</code></pre> <p>Tip</p> <p>You probably want to combine this option with the <code>--dir-dat-name</code> or <code>--dir-dat-description</code> options to avoid mixing ROMs from different consoles into the same subdirectory.</p>"}, {"location": "output/path-options/#append-dat-name", "title": "Append DAT name", "text": "<pre><code>--dir-dat-name\n</code></pre> <p>This option appends the matching DAT's name (not its filename) to each file, causing ROMs to be grouped by their console.</p> <p>For example, here are some ROMs from multiple consoles combined in one input directory:</p> <pre><code>ROMs-Input/\n\u251c\u2500\u2500 Pokemon - Blue Version (USA, Europe) (SGB Enhanced).gb\n\u251c\u2500\u2500 Pokemon - Crystal Version (USA, Europe) (Rev 1).gbc\n\u251c\u2500\u2500 Pokemon - Emerald Version (USA, Europe).gba\n\u251c\u2500\u2500 Pokemon - Gold Version (USA, Europe) (SGB Enhanced) (GB Compatible).gbc\n\u251c\u2500\u2500 Pokemon - Red Version (USA, Europe) (SGB Enhanced).gb\n\u251c\u2500\u2500 Pokemon - Ruby Version (USA, Europe) (Rev 2).gba\n\u251c\u2500\u2500 Pokemon - Sapphire Version (USA, Europe) (Rev 2).gba\n\u251c\u2500\u2500 Pokemon - Silver Version (USA, Europe) (SGB Enhanced) (GB Compatible).gbc\n\u2514\u2500\u2500 Pokemon - Yellow Version - Special Pikachu Edition (USA, Europe) (CGB+SGB Enhanced).gb\n</code></pre> <p>The ROMs will be grouped by their DAT name in the output directory:</p>  Windows macOS Linux <pre><code>igir copy ^\n  --dat \"No-Intro*.zip\" ^\n  --input \"ROMs-Input\" ^\n  --output \"ROMs-Output\" ^\n  --dir-dat-name\n</code></pre> <pre><code>igir copy \\\n  --dat \"No-Intro*.zip\" \\\n  --input \"ROMs-Input/\" \\\n  --output \"ROMs-Output/\" \\\n  --dir-dat-name\n</code></pre> <pre><code>igir copy \\\n  --dat \"No-Intro*.zip\" \\\n  --input \"ROMs-Input/\" \\\n  --output \"ROMs-Output/\" \\\n  --dir-dat-name\n</code></pre> <pre><code>ROMs-Output/\n\u251c\u2500\u2500 Game Boy\n\u2502   \u251c\u2500\u2500 Pokemon - Blue Version (USA, Europe) (SGB Enhanced).gb\n\u2502   \u251c\u2500\u2500 Pokemon - Red Version (USA, Europe) (SGB Enhanced).gb\n\u2502   \u2514\u2500\u2500 Pokemon - Yellow Version - Special Pikachu Edition (USA, Europe) (CGB+SGB Enhanced).gb\n\u251c\u2500\u2500 Game Boy Advance\n\u2502   \u251c\u2500\u2500 Pokemon - Emerald Version (USA, Europe).gba\n\u2502   \u251c\u2500\u2500 Pokemon - Ruby Version (USA, Europe) (Rev 2).gba\n\u2502   \u2514\u2500\u2500 Pokemon - Sapphire Version (USA, Europe) (Rev 2).gba\n\u2514\u2500\u2500 Game Boy Color\n    \u251c\u2500\u2500 Pokemon - Crystal Version (USA, Europe) (Rev 1).gbc\n    \u251c\u2500\u2500 Pokemon - Gold Version (USA, Europe) (SGB Enhanced) (GB Compatible).gbc\n    \u2514\u2500\u2500 Pokemon - Silver Version (USA, Europe) (SGB Enhanced) (GB Compatible).gbc\n</code></pre> <p>Tip</p> <p>You will probably want to use this option or <code>--dir-dat-description</code> any time you're processing multiple DAT files.</p>"}, {"location": "output/path-options/#append-dat-description", "title": "Append DAT description", "text": "<pre><code>--dir-dat-description\n</code></pre> <p>Similar to <code>--dir-dat-name</code>, this option will append the matching DAT's description to each file.</p>  Windows macOS Linux <pre><code>igir copy ^\n  --dat \"No-Intro*.zip\" ^\n  --input \"ROMs-Input\" ^\n  --output \"ROMs-Output\" ^\n  --dir-dat-description\n</code></pre> <pre><code>igir copy \\\n  --dat \"No-Intro*.zip\" \\\n  --input \"ROMs-Input/\" \\\n  --output \"ROMs-Output/\" \\\n  --dir-dat-description\n</code></pre> <pre><code>igir copy \\\n  --dat \"No-Intro*.zip\" \\\n  --input \"ROMs-Input/\" \\\n  --output \"ROMs-Output/\" \\\n  --dir-dat-description\n</code></pre> <p>Note</p> <p>Most DAT groups fill out the \"description\" field with the DAT's \"name\" plus verbose information such as game count or DAT generation date. Most of the time you will want to prefer using <code>--dir-dat-name</code> instead of this option.</p>"}, {"location": "output/path-options/#append-game-letters", "title": "Append game letter(s)", "text": "<pre><code>--dir-letter\n</code></pre> <p>This option appends one or more letters as a subdirectory. This option is further controlled by the other <code>--dir-letter-*</code> options below.</p> <p>For devices such as flash carts that are slow to scroll, it can be helpful to limit the number of files in one subdirectory. One way to do that is to group games by their first letter.</p> <p>For example, here are some ROMs that have don't all share the same first letter:</p> <pre><code>ROMs-Input/\n\u251c\u2500\u2500 Kirby's Dream Land (USA, Europe).gb\n\u251c\u2500\u2500 Kirby's Dream Land 2 (USA, Europe) (SGB Enhanced).gb\n\u251c\u2500\u2500 Pokemon - Blue Version (USA, Europe) (SGB Enhanced).gb\n\u251c\u2500\u2500 Pokemon - Red Version (USA, Europe) (SGB Enhanced).gb\n\u251c\u2500\u2500 Pokemon - Yellow Version - Special Pikachu Edition (USA, Europe) (CGB+SGB Enhanced).gb\n\u251c\u2500\u2500 Super Mario Land (World) (Rev 1).gb\n\u2514\u2500\u2500 Super Mario Land 2 - 6 Golden Coins (USA, Europe) (Rev 2).gb\n</code></pre> <p>The ROMs will be grouped together by their first letter in the output directory:</p>  Windows macOS Linux <pre><code>igir copy ^\n  --input \"ROMs-Input\" ^\n  --output \"ROMs-Output\" ^\n  --dir-letter\n</code></pre> <pre><code>igir copy \\\n  --input \"ROMs-Input/\" \\\n  --output \"ROMs-Output/\" \\\n  --dir-letter\n</code></pre> <pre><code>igir copy \\\n  --input \"ROMs-Input/\" \\\n  --output \"ROMs-Output/\" \\\n  --dir-letter\n</code></pre> <pre><code>ROMs-Output/\n\u251c\u2500\u2500 K\n\u2502   \u251c\u2500\u2500 Kirby's Dream Land (USA, Europe).gb\n\u2502   \u2514\u2500\u2500 Kirby's Dream Land 2 (USA, Europe) (SGB Enhanced).gb\n\u251c\u2500\u2500 P\n\u2502   \u251c\u2500\u2500 Pokemon - Blue Version (USA, Europe) (SGB Enhanced).gb\n\u2502   \u251c\u2500\u2500 Pokemon - Red Version (USA, Europe) (SGB Enhanced).gb\n\u2502   \u2514\u2500\u2500 Pokemon - Yellow Version - Special Pikachu Edition (USA, Europe) (CGB+SGB Enhanced).gb\n\u2514\u2500\u2500 S\n    \u251c\u2500\u2500 Super Mario Land (World) (Rev 1).gb\n    \u2514\u2500\u2500 Super Mario Land 2 - 6 Golden Coins (USA, Europe) (Rev 2).gb\n</code></pre> <p>Tip</p> <p>You will probably want to use <code>--dir-dat-name</code> or <code>--dir-dat-description</code> any time you're processing multiple DAT files, otherwise ROMs from different consoles will be mixed into the same letter subdirectories.</p>"}, {"location": "output/path-options/#change-the-number-of-letters", "title": "Change the number of letters", "text": "<pre><code>--dir-letter-count &lt;count&gt;\n</code></pre> <p>This option controls the number of leading letters to use for the <code>--dir-letter</code> option, with a default of one letter.</p> <p>For example, if we increase the number of letters used for subdirectory names from the above example, then the output would be:</p>  Windows macOS Linux <pre><code>igir copy ^\n  --input \"ROMs-Input\" ^\n  --output \"ROMs-Output\" ^\n  --dir-letter ^\n  --dir-letter-count 3\n</code></pre> <pre><code>igir copy \\\n  --input \"ROMs-Input/\" \\\n  --output \"ROMs-Output/\" \\\n  --dir-letter \\\n  --dir-letter-count 3\n</code></pre> <pre><code>igir copy \\\n  --input \"ROMs-Input/\" \\\n  --output \"ROMs-Output/\" \\\n  --dir-letter \\\n  --dir-letter-count 3\n</code></pre> <pre><code>ROMs-Output/\n\u251c\u2500\u2500 KIR\n\u2502   \u251c\u2500\u2500 Kirby's Dream Land (USA, Europe)\n\u2502   \u2514\u2500\u2500 Kirby's Dream Land 2 (USA, Europe) (SGB Enhanced)\n\u251c\u2500\u2500 POK\n\u2502   \u251c\u2500\u2500 Pokemon - Blue Version (USA, Europe) (SGB Enhanced).gb\n\u2502   \u251c\u2500\u2500 Pokemon - Red Version (USA, Europe) (SGB Enhanced).gb\n\u2502   \u2514\u2500\u2500 Pokemon - Yellow Version - Special Pikachu Edition (USA, Europe) (CGB+SGB Enhanced).gb\n\u2514\u2500\u2500 SUP\n    \u251c\u2500\u2500 Super Mario Land (World) (Rev 1).gb\n    \u2514\u2500\u2500 Super Mario Land 2 - 6 Golden Coins (USA, Europe) (Rev 2).gb\n</code></pre> <p>Tip</p> <p>This option is best used when combined with <code>--dir-letter-group</code> (below), otherwise you may find the subdirectory structure harder to navigate than leaving this option as the default of one letter.</p>"}, {"location": "output/path-options/#limit-the-number-of-games-in-a-subdirectory", "title": "Limit the number of games in a subdirectory", "text": "<pre><code>--dir-letter-limit &lt;limit&gt;\n</code></pre> <p>This option limits the number of games that can exist in a letter subdirectory, splitting into multiple subdirectories if necessary.</p> <p>This helps when navigating on devices that are slow to scroll, such as flash carts. Additionally, some devices may have a limit on the number of files they will display in a folder, so you may be required to split them.</p> <p>For example, here are some ROMs that all start with the same first letter:</p> <pre><code>ROMs-Input/\n\u251c\u2500\u2500 Shaq Fu (USA) (SGB Enhanced).gb\n\u251c\u2500\u2500 Space Invaders (USA) (SGB Enhanced).gb\n\u251c\u2500\u2500 Star Wars (USA, Europe) (Rev 1).gb\n\u251c\u2500\u2500 Star Wars - The Empire Strikes Back (USA, Europe).gb\n\u251c\u2500\u2500 Street Fighter II (USA, Europe) (Rev 1) (SGB Enhanced).gb\n\u251c\u2500\u2500 Super Mario Land (World) (Rev 1).gb\n\u2514\u2500\u2500 Super Mario Land 2 - 6 Golden Coins (USA, Europe) (Rev 2).gb\n</code></pre> <p>If we limit the number of files per letter folder, then the output would be:</p>  Windows macOS Linux <pre><code>igir copy ^\n  --input \"ROMs-Input\" ^\n  --output \"ROMs-Output\" ^\n  --dir-letter ^\n  --dir-letter-limit 5\n</code></pre> <pre><code>igir copy \\\n  --input \"ROMs-Input/\" \\\n  --output \"ROMs-Output/\" \\\n  --dir-letter \\\n  --dir-letter-limit 5\n</code></pre> <pre><code>igir copy \\\n  --input \"ROMs-Input/\" \\\n  --output \"ROMs-Output/\" \\\n  --dir-letter \\\n  --dir-letter-limit 5\n</code></pre> <pre><code>ROMs-Output/\n\u251c\u2500\u2500 S1\n\u2502   \u251c\u2500\u2500 Shaq Fu (USA) (SGB Enhanced).gb\n\u2502   \u251c\u2500\u2500 Space Invaders (USA) (SGB Enhanced).gb\n\u2502   \u251c\u2500\u2500 Star Wars (USA, Europe) (Rev 1).gb\n\u2502   \u251c\u2500\u2500 Star Wars - The Empire Strikes Back (USA, Europe).gb\n\u2502   \u2514\u2500\u2500 Street Fighter II (USA, Europe) (Rev 1) (SGB Enhanced).gb\n\u2514\u2500\u2500 S2\n    \u251c\u2500\u2500 Super Mario Land (World) (Rev 1).gb\n    \u2514\u2500\u2500 Super Mario Land 2 - 6 Golden Coins (USA, Europe) (Rev 2).gb\n</code></pre>"}, {"location": "output/path-options/#group-multiple-letters-together", "title": "Group multiple letters together", "text": "<pre><code>--dir-letter-group\n</code></pre> <p>This option will combine multiple letter subdirectories, creating letter ranges. This requires the <code>--dir-letter-limit &lt;limit&gt;</code> option, as that will help determine what the letter ranges should be.</p> <p>For example, here are some ROMs that all start with different letters:</p> <pre><code>ROMs-Input/\n\u251c\u2500\u2500 Alleyway (World).gb\n\u251c\u2500\u2500 Battletoads (USA, Europe).gb\n\u251c\u2500\u2500 Centipede (USA) (Majesco).gb\n\u251c\u2500\u2500 Donkey Kong (World) (Rev 1) (SGB Enhanced).gb\n\u251c\u2500\u2500 Earthworm Jim (USA).gb\n\u251c\u2500\u2500 Final Fantasy Adventure (USA).gb\n\u251c\u2500\u2500 Game Boy Wars Turbo (Japan) (SGB Enhanced).gb\n\u251c\u2500\u2500 Harvest Moon GB (USA) (SGB Enhanced).gb\n\u251c\u2500\u2500 James Bond 007 (USA, Europe) (SGB Enhanced).gb\n\u251c\u2500\u2500 Kirby's Dream Land (USA, Europe).gb\n\u251c\u2500\u2500 Legend of Zelda, The - Link's Awakening (USA, Europe) (Rev 2).gb\n\u251c\u2500\u2500 Mario's Picross (USA, Europe) (SGB Enhanced).gb\n\u2514\u2500\u2500 Pocket Bomberman (Europe) (SGB Enhanced).gb\n</code></pre> <p>We can group the games into letter ranges, with a max of 10 games in each subdirectory like this:</p>  Windows macOS Linux <pre><code>igir copy ^\n  --input \"ROMs-Input\" ^\n  --output \"ROMs-Output\" ^\n  --dir-letter ^\n  --dir-letter-limit 10 ^\n  --dir-letter-group\n</code></pre> <pre><code>igir copy \\\n  --input \"ROMs-Input/\" \\\n  --output \"ROMs-Output/\" \\\n  --dir-letter \\\n  --dir-letter-limit 10 \\\n  --dir-letter-group\n</code></pre> <pre><code>igir copy \\\n  --input \"ROMs-Input/\" \\\n  --output \"ROMs-Output/\" \\\n  --dir-letter \\\n  --dir-letter-limit 10 \\\n  --dir-letter-group\n</code></pre> <pre><code>ROMs-Output/\n\u251c\u2500\u2500 A-K\n\u2502   \u251c\u2500\u2500 Alleyway (World).gb\n\u2502   \u251c\u2500\u2500 Battletoads (USA, Europe).gb\n\u2502   \u251c\u2500\u2500 Centipede (USA) (Majesco).gb\n\u2502   \u251c\u2500\u2500 Donkey Kong (World) (Rev 1) (SGB Enhanced).gb\n\u2502   \u251c\u2500\u2500 Earthworm Jim (USA).gb\n\u2502   \u251c\u2500\u2500 Final Fantasy Adventure (USA).gb\n\u2502   \u251c\u2500\u2500 Game Boy Wars Turbo (Japan) (SGB Enhanced).gb\n\u2502   \u251c\u2500\u2500 Harvest Moon GB (USA) (SGB Enhanced).gb\n\u2502   \u251c\u2500\u2500 James Bond 007 (USA, Europe) (SGB Enhanced).gb\n\u2502   \u251c\u2500\u2500 Kirby's Dream Land (USA, Europe).gb\n\u2514\u2500\u2500 L-P\n    \u251c\u2500\u2500 Legend of Zelda, The - Link's Awakening (USA, Europe) (Rev 2).gb\n    \u251c\u2500\u2500 Mario's Picross (USA, Europe) (SGB Enhanced).gb\n    \u2514\u2500\u2500 Pocket Bomberman (Europe) (SGB Enhanced).gb\n</code></pre> <p>You can also combine this option with <code>--dir-letter-count &lt;count&gt;</code> for ranges with more letters.</p> <p>Tip</p> <p>This option is helpful with smaller ROM collections because <code>--dir-letter</code> may leave some letter subdirectories with few ROMs in them.</p> <p>Note</p> <p>This is how the Hardware Target Game Database organizes most of their SMDBs, grouping ROMs into subdirectories of ~200 ROMs each.</p> <p>You can achieve a result similar to the Hardware Target Game Database DATs with the following options:</p>  Windows macOS Linux <pre><code>igir [commands..] ^\n  [options] ^\n  --output \"{datName}\\{region}\" ^\n  --dir-letter ^\n  --dir-letter-group ^\n  --dir-letter-limit 200\n</code></pre> <pre><code>igir [commands..] \\\n  [options] \\\n  --output \"{datName}/{region}\" \\\n  --dir-letter \\\n  --dir-letter-group \\\n  --dir-letter-limit 200\n</code></pre> <pre><code>igir [commands..] \\\n  [options] \\\n  --output \"{datName}/{region}\" \\\n  --dir-letter \\\n  --dir-letter-group \\\n  --dir-letter-limit 200\n</code></pre>"}, {"location": "output/path-options/#append-the-game-name", "title": "Append the game name", "text": "<pre><code>--dir-game-subdir &lt;mode&gt;\n</code></pre> <p>By default, games with multiple ROMs are grouped together into their own output subdirectory. This is because emulators typically expect these files to be next to each other, but also because different games may have duplicate filenames (e.g. Sega Dreamcast GDIs all have a <code>track01.bin</code>).</p> <pre><code>ROMS-Output/\n\u2514\u2500\u2500 TOSEC\n    \u251c\u2500\u2500 Sega Dreamcast - Games - US\n    \u2502   \u251c\u2500\u2500 Sonic Adventure 2 v1.008 (2001)(Sega)(US)(M5)[!][3S]\n    \u2502   \u2502   \u251c\u2500\u2500 Sonic Adventure 2 v1.008 (2001)(Sega)(US)(M5)[!][3S].gdi\n    \u2502   \u2502   \u251c\u2500\u2500 track01.bin\n    \u2502   \u2502   \u251c\u2500\u2500 track02.raw\n    \u2502   \u2502   \u2514\u2500\u2500 track03.bin\n    \u2502   \u2514\u2500\u2500 Sonic Adventure v1.005 (1999)(Sega)(US)(M5)[!][26S]\n    \u2502       \u251c\u2500\u2500 Sonic Adventure v1.005 (1999)(Sega)(US)(M5)[!][26S].gdi\n    \u2502       \u251c\u2500\u2500 track01.bin\n    \u2502       \u251c\u2500\u2500 track02.raw\n    \u2502       \u2514\u2500\u2500 track03.bin\n    \u2514\u2500\u2500 Sega Mega-CD &amp; Sega CD - CD - Games - [ISO]\n        \u2514\u2500\u2500 Sonic CD (1993)(Sega)(NTSC)(US)[!][SEGA4407RE152 R7D]\n            \u251c\u2500\u2500 Sonic CD (1993)(Sega)(NTSC)(US)(Track 01 of 35)[!][SEGA4407RE152 R7D].iso\n            \u251c\u2500\u2500 Sonic CD (1993)(Sega)(NTSC)(US)(Track 02 of 35)[!][SEGA4407RE152 R7D].wav\n            \u251c\u2500\u2500 Sonic CD (1993)(Sega)(NTSC)(US)(Track 03 of 35)[!][SEGA4407RE152 R7D].wav\n            \u251c\u2500\u2500 Sonic CD (1993)(Sega)(NTSC)(US)(Track 04 of 35)[!][SEGA4407RE152 R7D].wav\n            \u251c\u2500\u2500 Sonic CD (1993)(Sega)(NTSC)(US)(Track 05 of 35)[!][SEGA4407RE152 R7D].wav\n            \u251c\u2500\u2500 Sonic CD (1993)(Sega)(NTSC)(US)(Track 06 of 35)[!][SEGA4407RE152 R7D].wav\n            \u251c\u2500\u2500 Sonic CD (1993)(Sega)(NTSC)(US)(Track 07 of 35)[!][SEGA4407RE152 R7D].wav\n            \u251c\u2500\u2500 Sonic CD (1993)(Sega)(NTSC)(US)(Track 08 of 35)[!][SEGA4407RE152 R7D].wav\n            \u251c\u2500\u2500 Sonic CD (1993)(Sega)(NTSC)(US)(Track 09 of 35)[!][SEGA4407RE152 R7D].wav\n            \u251c\u2500\u2500 Sonic CD (1993)(Sega)(NTSC)(US)(Track 10 of 35)[!][SEGA4407RE152 R7D].wav\n            \u251c\u2500\u2500 Sonic CD (1993)(Sega)(NTSC)(US)(Track 11 of 35)[!][SEGA4407RE152 R7D].wav\n            \u251c\u2500\u2500 Sonic CD (1993)(Sega)(NTSC)(US)(Track 12 of 35)[!][SEGA4407RE152 R7D].wav\n            \u251c\u2500\u2500 Sonic CD (1993)(Sega)(NTSC)(US)(Track 13 of 35)[!][SEGA4407RE152 R7D].wav\n            \u251c\u2500\u2500 Sonic CD (1993)(Sega)(NTSC)(US)(Track 14 of 35)[!][SEGA4407RE152 R7D].wav\n            \u251c\u2500\u2500 Sonic CD (1993)(Sega)(NTSC)(US)(Track 15 of 35)[!][SEGA4407RE152 R7D].wav\n            \u251c\u2500\u2500 Sonic CD (1993)(Sega)(NTSC)(US)(Track 16 of 35)[!][SEGA4407RE152 R7D].wav\n            \u251c\u2500\u2500 Sonic CD (1993)(Sega)(NTSC)(US)(Track 17 of 35)[!][SEGA4407RE152 R7D].wav\n            \u251c\u2500\u2500 Sonic CD (1993)(Sega)(NTSC)(US)(Track 18 of 35)[!][SEGA4407RE152 R7D].wav\n            \u251c\u2500\u2500 Sonic CD (1993)(Sega)(NTSC)(US)(Track 19 of 35)[!][SEGA4407RE152 R7D].wav\n            \u251c\u2500\u2500 Sonic CD (1993)(Sega)(NTSC)(US)(Track 20 of 35)[!][SEGA4407RE152 R7D].wav\n            \u251c\u2500\u2500 Sonic CD (1993)(Sega)(NTSC)(US)(Track 21 of 35)[!][SEGA4407RE152 R7D].wav\n            \u251c\u2500\u2500 Sonic CD (1993)(Sega)(NTSC)(US)(Track 22 of 35)[!][SEGA4407RE152 R7D].wav\n            \u251c\u2500\u2500 Sonic CD (1993)(Sega)(NTSC)(US)(Track 23 of 35)[!][SEGA4407RE152 R7D].wav\n            \u251c\u2500\u2500 Sonic CD (1993)(Sega)(NTSC)(US)(Track 24 of 35)[!][SEGA4407RE152 R7D].wav\n            \u251c\u2500\u2500 Sonic CD (1993)(Sega)(NTSC)(US)(Track 25 of 35)[!][SEGA4407RE152 R7D].wav\n            \u251c\u2500\u2500 Sonic CD (1993)(Sega)(NTSC)(US)(Track 26 of 35)[!][SEGA4407RE152 R7D].wav\n            \u251c\u2500\u2500 Sonic CD (1993)(Sega)(NTSC)(US)(Track 27 of 35)[!][SEGA4407RE152 R7D].wav\n            \u251c\u2500\u2500 Sonic CD (1993)(Sega)(NTSC)(US)(Track 28 of 35)[!][SEGA4407RE152 R7D].wav\n            \u251c\u2500\u2500 Sonic CD (1993)(Sega)(NTSC)(US)(Track 29 of 35)[!][SEGA4407RE152 R7D].wav\n            \u251c\u2500\u2500 Sonic CD (1993)(Sega)(NTSC)(US)(Track 30 of 35)[!][SEGA4407RE152 R7D].wav\n            \u251c\u2500\u2500 Sonic CD (1993)(Sega)(NTSC)(US)(Track 31 of 35)[!][SEGA4407RE152 R7D].wav\n            \u251c\u2500\u2500 Sonic CD (1993)(Sega)(NTSC)(US)(Track 32 of 35)[!][SEGA4407RE152 R7D].wav\n            \u251c\u2500\u2500 Sonic CD (1993)(Sega)(NTSC)(US)(Track 33 of 35)[!][SEGA4407RE152 R7D].wav\n            \u251c\u2500\u2500 Sonic CD (1993)(Sega)(NTSC)(US)(Track 34 of 35)[!][SEGA4407RE152 R7D].wav\n            \u251c\u2500\u2500 Sonic CD (1993)(Sega)(NTSC)(US)(Track 35 of 35)[!][SEGA4407RE152 R7D].wav\n            \u2514\u2500\u2500 Sonic CD (1993)(Sega)(NTSC)(US)[!][SEGA4407RE152 R7D].cue\n</code></pre> <p>You can change this behavior with the <code>--dir-game-subdir &lt;mode&gt;</code> option:</p> Mode Outcome <code>--dir-game-subdir never</code> Games with multiple ROMs are never grouped into their own subdirectory, which may cause conflicting output files <code>--dir-game-subdir auto</code> (default) Games with multiple ROMs are grouped into their own subdirectory, games with a single ROM are not <code>--dir-game-subdir always</code> Every game is grouped into its on subdirectory, no matter the number of ROMs it has"}, {"location": "output/playlists/", "title": "Writing Multi-Disc Playlists", "text": "<p>Most DAT groups that catalog optical media-based consoles (e.g. PS1, Dreamcast, GameCube) consider different discs of a multi-disc game to be separate \"games,\" with no relation between them other than having a similar name. This is because ROM managers may not process games unless all of its ROM files are present, but there may be bonus discs that you don't care about for storage reasons.</p> <p>Many emulators and frontends support <code>.m3u</code> playlist files that group multiple discs together:</p> <ul> <li>Batocera</li> <li>EmulationStation ES-DE</li> <li>libretro (RetroArch)</li> <li>Recalbox</li> <li>RetroPie</li> </ul> <p>Note</p> <p>Different frontends have different instructions on how to show or hide individual discs when using playlists. See your frontend's documentation for any settings you may need to change.</p> <p>Grouping multiple discs of the same game together is beneficial for a few reasons:</p> <ul> <li>Emulators and frontends typically provide an easy way to swap between discs in a playlist</li> <li>Save files typically mirror the input ROM's filename, so when using playlists, the save filename is typically named after the playlist and therefore shared among all discs</li> </ul>"}, {"location": "output/playlists/#playlist-command", "title": "<code>playlist</code> command", "text": "<p>Igir can create <code>.m3u</code> playlists for your multi-disc games with the <code>playlist</code> command like this:</p> <ul> <li> <p>For already sorted ROMs that don't need to be copied or moved:</p>  Windows macOS Linux <pre><code>igir playlist ^\n  --dat \"Redump*.zip\" ^\n  --input ROMs\\\n</code></pre> <pre><code>igir playlist \\\n  --dat \"Redump*.zip\" \\\n  --input ROMs/\n</code></pre> <pre><code>igir playlist \\\n  --dat \"Redump*.zip\" \\\n  --input ROMs/\n</code></pre> </li> </ul> <ul> <li> <p>When writing ROMs to an output directory:</p>  Windows macOS Linux <pre><code>igir copy extract playlist ^\n  --dat \"Redump*.zip\" ^\n  --input ROMs\\ ^\n  --output ROMs-Sorted\\\n</code></pre> <pre><code>igir copy extract playlist \\\n  --dat \"Redump*.zip\" \\\n  --input ROMs/ \\\n  --output ROMs-Sorted/\n</code></pre> <pre><code>igir copy extract playlist \\\n  --dat \"Redump*.zip\" \\\n  --input ROMs/ \\\n  --output ROMs-Sorted/\n</code></pre> </li> </ul> <p>Note</p> <p>The <code>igir playlist</code> command uses the same logic to group discs together as the <code>--merge-discs</code> option, which means it shares the same suggestions and limitations.</p> <p>The <code>--merge-discs</code> option isn't required for the <code>igir playlist</code> command, but it may be helpful for file grouping.</p> <p>Note</p> <p>Most frontends require discs to be extracted before they can be included in <code>.m3u</code> playlists. See the <code>igir extract</code> command for information on how to do this.</p>"}, {"location": "output/playlists/#example-scenarios", "title": "Example scenarios", "text": ""}, {"location": "output/playlists/#already-sorted-roms", "title": "Already sorted ROMs", "text": "<p>Let's say you already have a well-sorted ROM collection that looks like this:</p> <pre><code>ROMs/\n\u2514\u2500\u2500 Sony - PlayStation\n    \u251c\u2500\u2500 Final Fantasy IX (USA) (Disc 1)\n    \u2502   \u251c\u2500\u2500 Final Fantasy IX (USA) (Disc 1).bin\n    \u2502   \u2514\u2500\u2500 Final Fantasy IX (USA) (Disc 1).cue\n    \u251c\u2500\u2500 Final Fantasy IX (USA) (Disc 2)\n    \u2502   \u251c\u2500\u2500 Final Fantasy IX (USA) (Disc 2).bin\n    \u2502   \u2514\u2500\u2500 Final Fantasy IX (USA) (Disc 2).cue\n    \u251c\u2500\u2500 Final Fantasy IX (USA) (Disc 3)\n    \u2502   \u251c\u2500\u2500 Final Fantasy IX (USA) (Disc 3).bin\n    \u2502   \u2514\u2500\u2500 Final Fantasy IX (USA) (Disc 3).cue\n    \u251c\u2500\u2500 Final Fantasy IX (USA) (Disc 4)\n    \u2502   \u251c\u2500\u2500 Final Fantasy IX (USA) (Disc 4).bin\n    \u2502   \u2514\u2500\u2500 Final Fantasy IX (USA) (Disc 4).cue\n    \u251c\u2500\u2500 Legend of Dragoon, The (USA) (Disc 1)\n    \u2502   \u251c\u2500\u2500 Legend of Dragoon, The (USA) (Disc 1).bin\n    \u2502   \u2514\u2500\u2500 Legend of Dragoon, The (USA) (Disc 1).cue\n    \u251c\u2500\u2500 Legend of Dragoon, The (USA) (Disc 2)\n    \u2502   \u251c\u2500\u2500 Legend of Dragoon, The (USA) (Disc 2).bin\n    \u2502   \u2514\u2500\u2500 Legend of Dragoon, The (USA) (Disc 2).cue\n    \u251c\u2500\u2500 Legend of Dragoon, The (USA) (Disc 3)\n    \u2502   \u251c\u2500\u2500 Legend of Dragoon, The (USA) (Disc 3).bin\n    \u2502   \u2514\u2500\u2500 Legend of Dragoon, The (USA) (Disc 3).cue\n    \u251c\u2500\u2500 Legend of Dragoon, The (USA) (Disc 4)\n    \u2502   \u251c\u2500\u2500 Legend of Dragoon, The (USA) (Disc 4).bin\n    \u2502   \u2514\u2500\u2500 Legend of Dragoon, The (USA) (Disc 4).cue\n    \u2514\u2500\u2500 Vagrant Story (USA)\n        \u251c\u2500\u2500 Vagrant Story (USA).bin\n        \u2514\u2500\u2500 Vagrant Story (USA).cue\n</code></pre> <p>Igir can automatically generate <code>.m3u</code> playlist files for these games without modifying them:</p>  Windows macOS Linux <pre><code>igir playlist ^\n  --dat \"Redump*.zip\" ^\n  --input ROMs\\\n</code></pre> <pre><code>igir playlist \\\n  --dat \"Redump*.zip\" \\\n  --input ROMs/\n</code></pre> <pre><code>igir playlist \\\n  --dat \"Redump*.zip\" \\\n  --input ROMs/\n</code></pre> <p>The resulting files would look like this:</p> <pre><code>ROMs/\n\u2514\u2500\u2500 Sony - PlayStation\n    \u251c\u2500\u2500 Final Fantasy IX (USA) (Disc 1)\n    \u2502   \u251c\u2500\u2500 Final Fantasy IX (USA) (Disc 1).bin\n    \u2502   \u2514\u2500\u2500 Final Fantasy IX (USA) (Disc 1).cue\n    \u251c\u2500\u2500 Final Fantasy IX (USA) (Disc 2)\n    \u2502   \u251c\u2500\u2500 Final Fantasy IX (USA) (Disc 2).bin\n    \u2502   \u2514\u2500\u2500 Final Fantasy IX (USA) (Disc 2).cue\n    \u251c\u2500\u2500 Final Fantasy IX (USA) (Disc 3)\n    \u2502   \u251c\u2500\u2500 Final Fantasy IX (USA) (Disc 3).bin\n    \u2502   \u2514\u2500\u2500 Final Fantasy IX (USA) (Disc 3).cue\n    \u251c\u2500\u2500 Final Fantasy IX (USA) (Disc 4)\n    \u2502   \u251c\u2500\u2500 Final Fantasy IX (USA) (Disc 4).bin\n    \u2502   \u2514\u2500\u2500 Final Fantasy IX (USA) (Disc 4).cue\n    \u251c\u2500\u2500 Final Fantasy IX (USA).m3u\n    \u251c\u2500\u2500 Legend of Dragoon, The (USA) (Disc 1)\n    \u2502   \u251c\u2500\u2500 Legend of Dragoon, The (USA) (Disc 1).bin\n    \u2502   \u2514\u2500\u2500 Legend of Dragoon, The (USA) (Disc 1).cue\n    \u251c\u2500\u2500 Legend of Dragoon, The (USA) (Disc 2)\n    \u2502   \u251c\u2500\u2500 Legend of Dragoon, The (USA) (Disc 2).bin\n    \u2502   \u2514\u2500\u2500 Legend of Dragoon, The (USA) (Disc 2).cue\n    \u251c\u2500\u2500 Legend of Dragoon, The (USA) (Disc 3)\n    \u2502   \u251c\u2500\u2500 Legend of Dragoon, The (USA) (Disc 3).bin\n    \u2502   \u2514\u2500\u2500 Legend of Dragoon, The (USA) (Disc 3).cue\n    \u251c\u2500\u2500 Legend of Dragoon, The (USA) (Disc 4)\n    \u2502   \u251c\u2500\u2500 Legend of Dragoon, The (USA) (Disc 4).bin\n    \u2502   \u2514\u2500\u2500 Legend of Dragoon, The (USA) (Disc 4).cue\n    \u251c\u2500\u2500 Legend of Dragoon, The (USA).m3u\n    \u2514\u2500\u2500 Vagrant Story (USA)\n        \u251c\u2500\u2500 Vagrant Story (USA).bin\n        \u2514\u2500\u2500 Vagrant Story (USA).cue\n</code></pre> <p>The two created playlists will have the contents:</p> Final Fantasy IX (USA).m3uLegend of Dragoon, The (USA).m3u <pre><code>Final Fantasy IX (USA) (Disc 1)/Final Fantasy IX (USA) (Disc 1).cue\nFinal Fantasy IX (USA) (Disc 2)/Final Fantasy IX (USA) (Disc 2).cue\nFinal Fantasy IX (USA) (Disc 3)/Final Fantasy IX (USA) (Disc 3).cue\nFinal Fantasy IX (USA) (Disc 4)/Final Fantasy IX (USA) (Disc 4).cue\n</code></pre> <pre><code>Legend of Dragoon, The (USA) (Disc 1)/Legend of Dragoon, The (USA) (Disc 1).cue\nLegend of Dragoon, The (USA) (Disc 2)/Legend of Dragoon, The (USA) (Disc 2).cue\nLegend of Dragoon, The (USA) (Disc 3)/Legend of Dragoon, The (USA) (Disc 3).cue\nLegend of Dragoon, The (USA) (Disc 4)/Legend of Dragoon, The (USA) (Disc 4).cue\n</code></pre> <p>Note</p> <p>A <code>.m3u</code> playlist file was not created for <code>Vagrant Story (USA)</code> because it is not a multi-disc game.</p>"}, {"location": "output/playlists/#when-writing-sorting-roms", "title": "When writing &amp; sorting ROMs", "text": "<p>Let's say you haven't sorted your ROM collection yet and want to do that, while writing playlist files at the same time. Your input files might look like this:</p> <pre><code>ROMs/\n\u251c\u2500\u2500 Resident Evil - Code Veronica v1.000 (2000)(Capcom)(US)(Disc 1 of 2)[!]\n\u2502   \u251c\u2500\u2500 Resident Evil - Code Veronica v1.000 (2000)(Capcom)(US)(Disc 1 of 2)[!].gdi\n\u2502   \u251c\u2500\u2500 track01.bin\n\u2502   \u251c\u2500\u2500 track02.raw\n\u2502   \u2514\u2500\u2500 track03.bin\n\u251c\u2500\u2500 Resident Evil - Code Veronica v1.000 (2000)(Capcom)(US)(Disc 2 of 2)[!]\n\u2502   \u251c\u2500\u2500 Resident Evil - Code Veronica v1.000 (2000)(Capcom)(US)(Disc 2 of 2)[!].gdi\n\u2502   \u251c\u2500\u2500 track01.bin\n\u2502   \u251c\u2500\u2500 track02.raw\n\u2502   \u2514\u2500\u2500 track03.bin\n\u251c\u2500\u2500 Skies of Arcadia v1.002 (2000)(Sega)(US)(Disc 1 of 2)[!]\n\u2502   \u251c\u2500\u2500 Skies of Arcadia v1.002 (2000)(Sega)(US)(Disc 1 of 2)[!].gdi\n\u2502   \u251c\u2500\u2500 track01.bin\n\u2502   \u251c\u2500\u2500 track02.raw\n\u2502   \u2514\u2500\u2500 track03.bin\n\u251c\u2500\u2500 Skies of Arcadia v1.002 (2000)(Sega)(US)(Disc 2 of 2)[!]\n\u2502   \u251c\u2500\u2500 Skies of Arcadia v1.002 (2000)(Sega)(US)(Disc 2 of 2)[!].gdi\n\u2502   \u251c\u2500\u2500 track01.bin\n\u2502   \u251c\u2500\u2500 track02.raw\n\u2502   \u2514\u2500\u2500 track03.bin\n\u2514\u2500\u2500 Typing of the Dead, The v1.004 (2000)(Sega)(US)[!][req. keyboard]\n    \u251c\u2500\u2500 Typing of the Dead, The v1.004 (2000)(Sega)(US)[!][req. keyboard].gdi\n    \u251c\u2500\u2500 track01.bin\n    \u251c\u2500\u2500 track02.raw\n    \u251c\u2500\u2500 track03.bin\n    \u251c\u2500\u2500 track04.raw\n    \u2514\u2500\u2500 track05.bin\n</code></pre> <p>Let's say you also want to use the <code>--merge-discs</code> option to group multiple discs together into one folder:</p>  Windows macOS Linux <pre><code>igir move extract playlist ^\n  --dat \"TOSEC*.zip\" ^\n  --input ROMs\\ ^\n  --output ROMs-Sorted\\ ^\n  --dir-dat-name ^\n  --merge-discs\n</code></pre> <pre><code>igir move extract playlist \\\n  --dat \"TOSEC*.zip\" \\\n  --input ROMs/ \\\n  --output ROMs-Sorted/ \\\n  --dir-dat-name \\\n  --merge-discs\n</code></pre> <pre><code>igir move extract playlist \\\n  --dat \"TOSEC*.zip\" \\\n  --input ROMs/ \\\n  --output ROMs-Sorted/ \\\n  --dir-dat-name \\\n  --merge-discs\n</code></pre> <p>The resulting files would look like this:</p> <pre><code>ROMs-Sorted/\n\u2514\u2500\u2500 Sega Dreamcast - Games - US\n    \u251c\u2500\u2500 Resident Evil - Code Veronica v1.000 (2000)(Capcom)(US)[!]\n    \u2502   \u251c\u2500\u2500 Resident Evil - Code Veronica v1.000 (2000)(Capcom)(US)(Disc 1 of 2)[!]\n    \u2502   \u2502   \u251c\u2500\u2500 Resident Evil - Code Veronica v1.000 (2000)(Capcom)(US)(Disc 1 of 2)[!].gdi\n    \u2502   \u2502   \u251c\u2500\u2500 track01.bin\n    \u2502   \u2502   \u251c\u2500\u2500 track02.raw\n    \u2502   \u2502   \u2514\u2500\u2500 track03.bin\n    \u2502   \u251c\u2500\u2500 Resident Evil - Code Veronica v1.000 (2000)(Capcom)(US)(Disc 2 of 2)[!]\n    \u2502   \u2502   \u251c\u2500\u2500 Resident Evil - Code Veronica v1.000 (2000)(Capcom)(US)(Disc 2 of 2)[!].gdi\n    \u2502   \u2502   \u251c\u2500\u2500 track01.bin\n    \u2502   \u2502   \u251c\u2500\u2500 track02.raw\n    \u2502   \u2502   \u2514\u2500\u2500 track03.bin\n    \u2502   \u2514\u2500\u2500 Resident Evil - Code Veronica v1.000 (2000)(Capcom)(US)[!].m3u\n    \u251c\u2500\u2500 Skies of Arcadia v1.002 (2000)(Sega)(US)[!]\n    \u2502   \u251c\u2500\u2500 Skies of Arcadia v1.002 (2000)(Sega)(US)(Disc 1 of 2)[!]\n    \u2502   \u2502   \u251c\u2500\u2500 Skies of Arcadia v1.002 (2000)(Sega)(US)(Disc 1 of 2)[!].gdi\n    \u2502   \u2502   \u251c\u2500\u2500 track01.bin\n    \u2502   \u2502   \u251c\u2500\u2500 track02.raw\n    \u2502   \u2502   \u2514\u2500\u2500 track03.bin\n    \u2502   \u251c\u2500\u2500 Skies of Arcadia v1.002 (2000)(Sega)(US)(Disc 2 of 2)[!]\n    \u2502   \u2502   \u251c\u2500\u2500 Skies of Arcadia v1.002 (2000)(Sega)(US)(Disc 2 of 2)[!].gdi\n    \u2502   \u2502   \u251c\u2500\u2500 track01.bin\n    \u2502   \u2502   \u251c\u2500\u2500 track02.raw\n    \u2502   \u2502   \u2514\u2500\u2500 track03.bin\n    \u2502   \u2514\u2500\u2500 Skies of Arcadia v1.002 (2000)(Sega)(US)[!].m3u\n    \u2514\u2500\u2500 Typing of the Dead, The v1.004 (2000)(Sega)(US)[!][req. keyboard]\n        \u251c\u2500\u2500 Typing of the Dead, The v1.004 (2000)(Sega)(US)[!][req. keyboard].gdi\n        \u251c\u2500\u2500 track01.bin\n        \u251c\u2500\u2500 track02.raw\n        \u251c\u2500\u2500 track03.bin\n        \u251c\u2500\u2500 track04.raw\n        \u2514\u2500\u2500 track05.bin\n</code></pre> <p>The two created playlists will have the contents:</p> Resident Evil - Code Veronica v1.000 (2000)(Capcom)(US)[!].m3uSkies of Arcadia v1.002 (2000)(Sega)(US)[!].m3u <pre><code>Resident Evil - Code Veronica v1.000 (2000)(Capcom)(US)(Disc 1 of 2)[!]/Resident Evil - Code Veronica v1.000 (2000)(Capcom)(US)(Disc 1 of 2)[!].gdi\nResident Evil - Code Veronica v1.000 (2000)(Capcom)(US)(Disc 2 of 2)[!]/Resident Evil - Code Veronica v1.000 (2000)(Capcom)(US)(Disc 2 of 2)[!].gdi\n</code></pre> <pre><code>Skies of Arcadia v1.002 (2000)(Sega)(US)(Disc 1 of 2)[!]/Skies of Arcadia v1.002 (2000)(Sega)(US)(Disc 1 of 2)[!].gdi\nSkies of Arcadia v1.002 (2000)(Sega)(US)(Disc 2 of 2)[!]/Skies of Arcadia v1.002 (2000)(Sega)(US)(Disc 2 of 2)[!].gdi\n</code></pre> <p>Note</p> <p>A <code>.m3u</code> playlist file was not created for <code>Typing of the Dead, The v1.004 (2000)(Sega)(US)[!][req. keyboard]</code> because it is not a multi-disc game.</p>"}, {"location": "output/playlists/#rom-extensions", "title": "ROM extensions", "text": "<p>By default, Igir will include only certain file extensions in playlist files. See the <code>igir --help</code> message for the default list.</p> <p>You can override the default extension list with the <code>--playlist-extensions &lt;exts&gt;</code> like so:</p> <pre><code>igir playlist --input ROMs --playlist-extensions \".cue,.gdi\"\n</code></pre>"}, {"location": "output/reporting/", "title": "Writing ROM Reports", "text": ""}, {"location": "output/reporting/#overview", "title": "Overview", "text": "<p>When using DATs (the <code>--dat &lt;path&gt;</code> option), the <code>igir report</code> command can report on:</p> <ul> <li><code>FOUND</code>: what ROMs were found, and where their files are on disk</li> <li><code>MISSING</code>: what ROMs were wanted, but weren't found</li> <li><code>DUPLICATE</code>: what input files did match to a ROM but weren't used when writing</li> <li><code>UNUSED</code>: what input files didn't match to any ROM</li> <li><code>DELETED</code>: what output files were cleaned (<code>igir clean</code> command)</li> </ul> <p>At least one DAT is required for the <code>igir report</code> command to work, otherwise Igir has no way to understand what input files are known ROMs and which aren't. See the DAT docs for more information about DATs.</p> <p>The <code>igir report</code> command can be specified on its own without any writing command (i.e. <code>igir copy</code>, <code>igir move</code>, etc.) to report on an existing collection. This causes Igir to operate in a read-only mode, no files will be copied, moved, or deleted. For example:</p>  Windows macOS Linux <pre><code>&gt; igir.exe report --dat *.dat --input ROMs\\\n\n&gt; dir /b *.csv\nigir_2023-03-29T18;26;00-04;00.csv\n</code></pre> <pre><code>$ igir report --dat *.dat --input ROMs/\n\n$ ls *.csv\nigir_2023-03-29T18;26;00-04;00.csv\n</code></pre> <pre><code>$ igir report --dat *.dat --input ROMs/\n\n$ ls *.csv\nigir_2023-03-29T18;26;00-04;00.csv\n</code></pre> <p>See the <code>igir --help</code> message for the report's default location.</p>"}, {"location": "output/reporting/#format-filtering", "title": "Format &amp; filtering", "text": "<p>The output report format is a standard CSV that can be opened in Microsoft Excel, Apple Numbers, Google Sheets, LibreOffice Calc, and other similar spreadsheet applications.</p> <p>Unlike the report formats of other ROM managers, CSVs allow you to filter rows by column values. For example, you can filter the \"Status\" column to only \"MISSING\" to understand what ROMs are missing from your collection, or to \"UNUSED\" to understand what input files weren't used as the source of any output file. The ability to filter CSVs in spreadsheet applications means that Igir shouldn't need use-case-specific report options to achieve your goal.</p> <p>To perform this filtering, most spreadsheet applications have a button or menu item to \"create a filter\" or \"auto filter.\"</p>"}, {"location": "output/reporting/#output-location", "title": "Output location", "text": "<p>The <code>--report-output &lt;path&gt;</code> option is provided to configure where the <code>igir report</code> CSV is written. See the <code>igir --help</code> message for the report's default location.</p> <p>The report output filename supports a version of Moment.js symbols for date and time. To make it clearer what is a replaceable symbol, <code>%</code> is prepended to symbols. This is non-standard for Moment.js, but the <code>%</code> format should feel more familiar to more people as it resembles Python's <code>date.strftime()</code>, PHP's <code>strftime()</code>, C++'s <code>strftime()</code>, and more.</p> <p>Info</p> <p>See the Moment.js docs for a complete list of tokens you can use.</p> <p>Warning</p> <p>The <code>%</code> character is used to denote replaceable variable names (such as <code>%USERPROFILE%</code> and <code>%TEMP%</code>) in Windows Batch scripting. You may need to \"escape\" <code>%</code> characters with a <code>^</code> if you experience problems. Example:</p> <pre><code>--report-output ^%X.csv\n</code></pre> <p>Here are some example usages:</p>  Windows macOS Linux <pre><code>&gt; igir.exe report --dat *.dat --input ROMs\\ --report-output \".\\report.csv\"\n\n&gt; igir.exe report --dat *.dat --input ROMs\\ --report-output \".\\report %dddd, %MMMM %Do %YYYY, %h:%mm:%ss %a.csv\"\nREM ./report Friday, April 14th 2023, 4:28:26 pm.csv\n\n&gt; igir.exe report --dat *.dat --input ROMs\\ --report-output \"igir\\%X.csv\"\nREM /igir/1681515048.csv\n</code></pre> <pre><code>$ igir report --dat *.dat --input ROMs/ --report-output \"./report.csv\"\n\n$ igir report --dat *.dat --input ROMs/ --report-output \"./report %dddd, %MMMM %Do %YYYY, %h:%mm:%ss %a.csv\"\n# ./report Friday, April 14th 2023, 4:28:26 pm.csv\n\n$ igir report --dat *.dat --input ROMs/ --report-output \"igir\\%X.csv\"\n# /igir/1681515048.csv\n</code></pre> <pre><code>$ igir report --dat *.dat --input ROMs/ --report-output \"./report.csv\"\n\n$ igir report --dat *.dat --input ROMs/ --report-output \"./report %dddd, %MMMM %Do %YYYY, %h:%mm:%ss %a.csv\"\n# ./report Friday, April 14th 2023, 4:28:26 pm.csv\n\n$ igir report --dat *.dat --input ROMs/ --report-output \"igir/%X.csv\"\n# /igir/1681515048.csv\n</code></pre>"}, {"location": "output/tokens/", "title": "Output Path Tokens", "text": "<p>When specifying a ROM writing command you have to specify an <code>--output &lt;path&gt;</code> directory. Igir has a few replaceable \"tokens\" that can be referenced in the <code>--output &lt;path&gt;</code> directory value. This can aid in sorting ROMs into a more complicated directory structure.</p> <p>See output path tokens for other options that will further sort your ROMs into subdirectories.</p> <p>For example, if you want to group all ROMs based on their region, you would specify:</p>  Windows macOS Linux <pre><code>igir copy extract ^\n  --dat *.dat ^\n  --input ROMs\\ ^\n  --output \"ROMs-Sorted\\{region}\\\"\n</code></pre> <pre><code>igir copy extract \\\n  --dat *.dat \\\n  --input ROMs/ \\\n  --output \"ROMs-Sorted/{region}/\"\n</code></pre> <pre><code>igir copy extract \\\n  --dat *.dat \\\n  --input ROMs/ \\\n  --output \"ROMs-Sorted/{region}/\"\n</code></pre> <p>This might result in an output structure such as:</p> <pre><code>ROMs-Sorted/\n\u251c\u2500\u2500 AUS\n\u2502   \u2514\u2500\u2500 Pokemon Pinball (USA, Australia) (Rumble Version) (SGB Enhanced) (GB Compatible).gbc\n\u251c\u2500\u2500 EUR\n\u2502   \u251c\u2500\u2500 Pokemon - Blue Version (USA, Europe) (SGB Enhanced).gb\n\u2502   \u251c\u2500\u2500 Pokemon - Red Version (USA, Europe) (SGB Enhanced).gb\n\u2502   \u2514\u2500\u2500 Pokemon - Yellow Version - Special Pikachu Edition (USA, Europe) (CGB+SGB Enhanced).gb\n\u2514\u2500\u2500 USA\n    \u251c\u2500\u2500 Pokemon - Blue Version (USA, Europe) (SGB Enhanced).gb\n    \u251c\u2500\u2500 Pokemon - Red Version (USA, Europe) (SGB Enhanced).gb\n    \u251c\u2500\u2500 Pokemon - Yellow Version - Special Pikachu Edition (USA, Europe) (CGB+SGB Enhanced).gb\n    \u2514\u2500\u2500 Pokemon Pinball (USA, Australia) (Rumble Version) (SGB Enhanced) (GB Compatible).gbc\n</code></pre> <p>Note</p> <p>Tokens can resolve to multiple values for each ROM. For example, a ROM may have multiple regions or languages. This will result in the same ROM being written to multiple locations.</p>"}, {"location": "output/tokens/#dat-information", "title": "DAT information", "text": "<p>When using DATs, you can make use of console &amp; game information contained in them:</p> <ul> <li><code>{datName}</code> the matching DAT's name, similar to how the <code>--dir-dat-name</code> option works</li> <li><code>{datDescription}</code> the matching DAT's description, similar to how the <code>--dir-dat-description</code> option works</li> <li><code>{region}</code> each of the game's region(s) (e.g. <code>USA</code>, <code>EUR</code>, <code>JPN</code>, <code>WORLD</code>)</li> <li><code>{language}</code> each of the game's language(s) (e.g. <code>EN</code>, <code>ES</code>, <code>JA</code>)</li> <li><code>{type}</code> the game's \"type,\" one of: <code>Aftermarket</code>, <code>Alpha</code>, <code>Bad</code>, <code>Beta</code>, <code>BIOS</code>, <code>Demo</code>, <code>Device</code>, <code>Fixed</code>, <code>Hacked</code>, <code>Homebrew</code>, <code>Overdump</code>, <code>Pending Dump</code>, <code>Pirated</code>, <code>Prototype</code>, <code>Retail</code> (most games will be this), <code>Sample</code>, <code>Test</code>, <code>Trained</code>, <code>Translated</code>, <code>Unlicensed</code></li> <li><code>{category}</code> the game's \"category\" (only some DATs provide this)</li> <li><code>{genre}</code> the game's \"genre\" (most DATs don't provide this)</li> </ul>"}, {"location": "output/tokens/#file-information", "title": "File information", "text": "<p>You can use some information about the input and output file's name &amp; location:</p> <ul> <li><code>{inputDirname}</code> the input file's dirname (full path minus file basename)</li> <li><code>{outputBasename}</code> the output file's basename, equivalent to <code>{outputName}.{outputExt}</code></li> <li><code>{outputName}</code> the output file's filename without its extension</li> <li><code>{outputExt}</code> the output file's extension</li> </ul>"}, {"location": "output/tokens/#specific-hardware", "title": "Specific hardware", "text": "<p>To help sort ROMs into unique file structures for popular frontends &amp; hardware, Igir offers a few specific tokens:</p> <ul> <li><code>{adam}</code> the 'Adam' image emulator's directory for the ROM</li> <li><code>{batocera}</code> the Batocera emulator's directory for the ROM</li> <li><code>{es}</code> the EmulationStation emulator's directory for the ROM</li> <li><code>{funkeyos}</code> the FunKey OS emulator's directory for the ROM</li> <li><code>{jelos}</code> the JELOS emulator's directory for the ROM</li> <li><code>{minui}</code> the MinUI emulator's directory for the ROM</li> <li><code>{mister}</code> the MiSTer FPGA core's directory for the ROM</li> <li><code>{miyoocfw}</code> the MiyooCFW emulator's directory for the ROM</li> <li><code>{onion}</code> the OnionOS / GarlicOS emulator's directory for the ROM</li> <li><code>{pocket}</code> the Analogue Pocket core's directory for the ROM</li> <li><code>{retrodeck}</code> the RetroDECK emulator's directory for the ROM</li> <li><code>{romm}</code> the RomM manager directory for the ROM</li> <li><code>{twmenu}</code> the TWiLightMenu++ emulator's directory for the ROM</li> </ul> <p>Tip</p> <p>See the <code>igir --help</code> message for the list of all replaceable tokens.</p>"}, {"location": "output/writing-archives/", "title": "Writing Zip Archives", "text": "<p>Igir supports creating <code>.zip</code> archives with the <code>igir zip</code> command.</p> <p>Note</p> <p>It is intentional that Igir only supports <code>.zip</code> archives right now.</p> <p><code>.zip</code> archives store CRC32 information in their \"central directory\" which helps drastically speed up Igir's file scanning, and zip archives are easy to create without proprietary tools (e.g. 7-Zip, Rar).</p> <p>See the reading archives page for more information on archive formats and their capabilities.</p>"}, {"location": "output/writing-archives/#torrentzip", "title": "TorrentZip", "text": "<p>Igir adheres to the TorrentZip standard for zip files. This standard allows ROM managers to write byte-for-byte identical zip files given the same input files.</p>"}, {"location": "output/writing-archives/#rvzstd", "title": "RVZSTD", "text": "<p>The original TorrentZip format uses the widely supported DEFLATE compression algorithm. Gordon J from RomVault has since extended the structured zip format to support Zstandard (\"Zstd\") compression, which can compress files smaller than DEFLATE with less processing power.</p> <p>Although the zip format officially added support for Zstd compression in June 2020, support among archive programs and OSes remains quite low. Igir uses the old DEFLATE algorithm by default, but you can instead switch to using Zstandard with the option:</p> <pre><code>--zip-format rvzstd\n</code></pre>"}, {"location": "output/writing-archives/#implications-for-testing", "title": "Implications for testing", "text": "<p>When Igir tests written zip files, it will test to make sure they're valid a TorrentZip or RVSTD file, whichever was specified. This means that zip files that aren't of the expected structured format will be considered invalid, even if they contain all expected files. This isn't a problem for the <code>igir zip</code> command which will rewrite the zip as necessary, but it could be a problem if you have invalid zips in your input paths and omit the command.</p> <p>The <code>--overwrite-invalid</code> option can help you convert your collection between different zip formats like this:</p>  Windows macOS Linux <pre><code>igir move zip test ^\n  --dat \"DATs\\\" ^\n  --input \"ROMs\\\" ^\n  --output \"ROMs\\\" ^\n  --dir-mirror ^\n  --zip-format &lt;format&gt; ^\n  --overwrite-invalid\n</code></pre> <pre><code>igir move zip test \\\n  --dat \"DATs/\" \\\n  --input \"ROMs/\" \\\n  --output \"ROMs/\" \\\n  --dir-mirror \\\n  --zip-format &lt;format&gt; \\\n  --overwrite-invalid\n</code></pre> <pre><code>igir move zip test \\\n  --dat \"DATs/\" \\\n  --input \"ROMs/\" \\\n  --output \"ROMs/\" \\\n  --dir-mirror \\\n  --zip-format &lt;format&gt; \\\n  --overwrite-invalid\n</code></pre> <p>Tip</p> <p>You can test if zip files in input directories are valid TorrentZip archives without writing anything with the <code>igir test</code> command.</p>"}, {"location": "output/writing-archives/#example-zipping-a-rom-collection", "title": "Example: zipping a ROM collection", "text": "<p>One aspect of organizing a ROM collection is to ensure a consistent archive format. You can ensure all ROMs in a collection are in a <code>.zip</code> archive like this:</p>  Windows macOS Linux <pre><code>igir move zip --dat \"*.dat\" --input \"ROMs\\\" --output \"ROMs\\\"\n</code></pre> <pre><code>igir move zip --dat \"*.dat\" --input \"ROMs/\" --output \"ROMs/\"\n</code></pre> <pre><code>igir move zip --dat \"*.dat\" --input \"ROMs/\" --output \"ROMs/\"\n</code></pre>"}, {"location": "output/writing-archives/#excluding-files-from-zipping", "title": "Excluding files from zipping", "text": "<p>There are multiple reasons why you might need some files to be extracted and not in a <code>.zip</code> archive:</p> <ul> <li>Most emulators don't support archived BIOS files</li> <li>Some emulators don't support archived disc formats such as <code>.iso</code> or <code>.bin/.cue</code></li> <li>It may not make sense to compress already compressed formats such as <code>.chd</code>, <code>.cso</code>, and <code>.rvz</code></li> </ul> <p>You can exclude files from being zipped with the <code>--zip-exclude &lt;glob&gt;</code> option. The \"glob\" value for this option will be matched against the file's intended output location (as opposed to an input file's location).</p> <p>You can exclude some disc images like this:</p>  Windows macOS Linux <pre><code>igir copy zip ^\n  --dat \"*.dat\" ^\n  --input \"ROMs\\\" ^\n  --output \"ROMs-Sorted\\\" ^\n  --zip-exclude \"**/*.{iso,bin,cue,chd}\"\n</code></pre> <pre><code>igir copy zip \\\n  --dat \"*.dat\" \\\n  --input \"ROMs/\" \\\n  --output \"ROMs-Sorted/\" \\\n  --zip-exclude \"**/*.{iso,bin,cue,chd}\"\n</code></pre> <pre><code>igir copy zip \\\n  --dat \"*.dat\" \\\n  --input \"ROMs/\" \\\n  --output \"ROMs-Sorted/\" \\\n  --zip-exclude \"**/*.{iso,bin,cue,chd}\"\n</code></pre> <p>You can exclude some BIOS files like this:</p>  Windows macOS Linux <pre><code>igir copy zip ^\n  --dat \"*.dat\" ^\n  --input \"ROMs\\\" ^\n  --output \"ROMs-Sorted\\\" ^\n  --zip-exclude \"**/*[BIOS]*\"\n</code></pre> <pre><code>igir copy zip \\\n  --dat \"*.dat\" \\\n  --input \"ROMs/\" \\\n  --output \"ROMs-Sorted/\" \\\n  --zip-exclude \"**/*[BIOS]*\"\n</code></pre> <pre><code>igir copy zip \\\n  --dat \"*.dat\" \\\n  --input \"ROMs/\" \\\n  --output \"ROMs-Sorted/\" \\\n  --zip-exclude \"**/*[BIOS]*\"\n</code></pre> <p>Tip</p> <p>globster.xyz is a great website to test various glob patterns.</p>"}, {"location": "roms/filtering-preferences/", "title": "ROM Filtering &amp; Preferences", "text": "<p>Igir offers many options for filtering as well as 1G1R preferences/priorities (when combined with the <code>--single</code> option).</p> <p>ROM filters cut down the list of games desired for a set, and any games filtered out will not appear in reports. ROM preferences decide what duplicates to eliminate (1G1R).</p> <p>Tip</p> <p>Filters &amp; preferences are applied before generating fixdats and dir2dats, allowing you to DATs for your exact needs!</p>"}, {"location": "roms/filtering-preferences/#filters", "title": "Filters", "text": "<p>Multiple filter options can be specified at once.</p> <p>Note</p> <p>Filters are applied against all DATs before ROM matching happens.</p> <p>If no DATs are provided, Igir will infer DATs from the input files.</p>"}, {"location": "roms/filtering-preferences/#game-name-filter", "title": "Game name filter", "text": "<pre><code>--filter-regex &lt;pattern|filename&gt;, --filter-regex-exclude &lt;pattern|filename&gt;\n</code></pre> <p>Only include or exclude games based on if their DAT name (or filename if not using DATs) matches a regular expression.</p> <p>Regex flags can be optionally provided in the form <code>/&lt;pattern&gt;/&lt;flags&gt;</code>, for example:</p> <pre><code>Mario|Zelda\n/mario|zelda/i\n</code></pre> <p>A filename can be provided to a file that contains one or more lines of patterns. Multiple patterns will be combined in a logical \"or\" fashion. For example:</p> <pre><code># patterns.txt\n^Mario\n/kirby|zelda/i\n\n# --filter-regex patterns.txt would match:\nMario's Picross (USA, Europe) (SGB Enhanced)\nKirby's Dream Land (USA, Europe)\nLegend of Zelda, The - Link's Awakening (USA, Europe) (Rev 2)\n\n# --filter-regex patterns.txt would NOT match:\nDr. Mario (World) (Rev 1)\nSuper Mario Land (World) (Rev 1)\nTetris (World) (Rev 1)\nWario Land II (USA, Europe) (SGB Enhanced)\n</code></pre>"}, {"location": "roms/filtering-preferences/#language-filter", "title": "Language filter", "text": "<pre><code>--filter-language [languages..]\n</code></pre> <p>Languages are two-letter codes, and multiple languages can be specified with commas between them. See the <code>--help</code> message for the full list of supported languages.</p> <p>If a game doesn't have language information specified in its name, the region's primary language will be used. If a game doesn't have language or region information, then it will always be filtered out by this option.</p> <p>Here are some example game names that Igir can parse languages from, including ones with multiple languages:</p> <pre><code>English:\n  Donkey Kong (Japan, USA) (En) (SGB Enhanced)\n  Dr. Franken (USA)\n  Dragon's Lair - The Legend (Europe)\n  Gear Works (U) [!]\n\nJapanese:\n  Final Reverse (Japan)\n  Makai Toushi Sa-Ga (World) (Ja) (Rev 1) (Collection of SaGa)\n  Ohasuta Dance Dance Revolution GB (J) [C][!]\n\nSpanish:\n  Humans, The (Europe) (En,Fr,De,Es,It)\n  Pokemon - Edicion Azul (Spain) (SGB Enhanced)\n  Rugrats en Paris - La Pelicula (S) (M2) [C][!]\n</code></pre> <p>A game can have many languages, and all of them are considered during filtering.</p>"}, {"location": "roms/filtering-preferences/#region-filter", "title": "Region filter", "text": "<pre><code>--filter-region [regions..]\n</code></pre> <p>Regions are two or three-letter codes, and you can specify multiple regions with commas between them. See the <code>--help</code> message for the full list of supported regions.</p> <p>If a game doesn't have region information then it will always be filtered out by this option.</p> <p>Here are some example game names that Igir can parse regions from:</p> <pre><code>USA:\n  10-Pin Bowling (USA)\n  Addams Family, The - Pugsley's Scavenger Hunt (USA, Europe)\n  Castelian (U) [!]\n\nJapan:\n  Dragon Quest I &amp; II (J) [C][!]\n  Taikyoku Renju (Japan) (En,Ja)\n\nEurope:\n  Adventures of Lolo (Europe) (SGB Enhanced)\n  Castlevania Adventure, The (E) [!]\n  Soccer (Europe, Australia) (En,Fr,De) (SGB Enhanced)\n\nSpain:\n  Dragon Ball Z - Guerreros de Leyenda (S) [C][!]\n  Star Trek - The Next Generation (Spain)\n</code></pre> <p>A game can only have one primary region. The first region detected is what is used.</p>"}, {"location": "roms/filtering-preferences/#category-filter", "title": "Category filter", "text": "<pre><code>--filter-category-regex &lt;pattern|filename&gt;\n</code></pre> <p>Only include games whose category matches the provided regular expression.</p> <p>Warning</p> <p>This options requires that the DATs you use include category information. Not every DAT release group includes category information (e.g. MAME, TOSEC), and not every release group includes category in every version of their DATs (e.g. No-Intro). Games without categories will always be filtered out by this option!</p>"}, {"location": "roms/filtering-preferences/#bios", "title": "BIOS", "text": "<pre><code>--no-bios, --only-bios\n</code></pre> <p>Filter out, or only include games that are marked <code>isbios=\"yes\"</code> in the DAT, or contain <code>[BIOS]</code> in their name, e.g.:</p> <pre><code>[BIOS] Nintendo Game Boy Boot ROM (World) (Rev 1)\n[BIOS] Nintendo Game Boy Color Boot ROM (World) (Rev 1)\n</code></pre> <p>Tip</p> <p><code>--only-bios</code> is a great option to collate all BIOS files across all consoles to one directory.</p>"}, {"location": "roms/filtering-preferences/#mame-devices", "title": "MAME devices", "text": "<pre><code>--no-device, --only-device\n</code></pre> <p>Filter out or only include MAME devices. MAME devices typically represent physical devices, such as microcontrollers, video display controllers, sounds boards, and more. Many MAME devices don't have any associated ROM files.</p>"}, {"location": "roms/filtering-preferences/#unlicensed", "title": "Unlicensed", "text": "<pre><code>--no-unlicensed, --only-unlicensed\n</code></pre> <p>Filter out, or only include games that contain <code>(Unl)</code> or <code>(Unlicensed)</code> in their name, e.g.:</p> <pre><code>4 in 1 (Europe) (4B-002, Sachen) (Unl)\nCaihong Zhanshi - Rainbow Prince (Taiwan) (Unl)\n</code></pre> <p>These games are still considered \"retail\" releases (below).</p>"}, {"location": "roms/filtering-preferences/#only-retail", "title": "Only retail", "text": "<pre><code>--only-retail\n</code></pre> <p>Enables all the following <code>--no-*</code> options, as well as filtering out games that are:</p> <ul> <li> <p>Alphas: games that contain <code>(Alpha)</code> in their name, e.g.:</p> <pre><code>Isle Quest (World) (v0.1c) (Alpha) (Aftermarket) (Homebrew)\nSword (Alpha) (PD) [C]\n</code></pre> </li> </ul> <ul> <li>Bootleg: games that contain <code>bootleg</code> in their manufacturer</li> </ul> <ul> <li> <p>Cracked: games that contain <code>[cr]</code> or <code>[cr *]</code> in their name, e.g.:</p> <pre><code>Jet Set Willy (1984)(Software Projects)[cr]\nBuck Rogers - Countdown to Doomsday v1.0 (1991)(SSI)(Disk 1 of 3)[cr2][FD installed]\nDungeon Master (1987)(FTL)[cr 42-Crew]\n</code></pre> </li> </ul> <ul> <li> <p>Enhancement chips: games that contain <code>(Enhancement Chip)</code> in their name, e.g.:</p> <pre><code>DSP1 B (World) (Enhancement Chip)\nSuper Game Boy SGB-CPU (World) (Enhancement Chip)\n</code></pre> </li> </ul> <ul> <li> <p>Fixed: games that contain <code>[f]</code> or <code>[f#]</code> in their name, e.g.:</p> <pre><code>Black Bass - Lure Fishing (U) [C][f1]\nBugs Bunny - Crazy Castle 3 (J) [C][f2]\n</code></pre> </li> </ul> <ul> <li> <p>Non-public \"MIA\": games that contain <code>[MIA]</code> in their name, e.g.:</p> <pre><code>[MIA] Better Dead Than Alien (Europe)\n[MIA] Billiards Simulator (Europe) (En,Fr,De)\n</code></pre> </li> </ul> <ul> <li> <p>Overdumps: games that contain <code>[o]</code> or <code>[o#]</code> in their name, e.g.:</p> <pre><code>Castlevania II - Belmont's Revenge (U) [o1]\nCave Noire (J) [o2]\n</code></pre> </li> </ul> <ul> <li> <p>Pending dumps: games that contain <code>[!p]</code> in their name, e.g.:</p> <pre><code>Cheetah Men II (Active Enterprises) [!p]\n</code></pre> </li> </ul> <ul> <li> <p>Pirated: games that contain <code>(Pirate)</code>, <code>[p]</code>, or <code>[p#]</code> in their name, e.g.:</p> <pre><code>Flipull (J) [p1]\nSuper Mario 4 (Unknown) (Ja) (Pirate)\nSuper Robot Taisen Final Vol.1 (Unl) [C][p2]\n</code></pre> </li> </ul> <ul> <li> <p>Unofficial translations: games that contain <code>[T-*]</code> or <code>[T+*]</code> in their name, e.g.:</p> <pre><code>Duck Tales (E) [T-Ger]\nFinal Fantasy Legend II (U) [T+Fre]\n</code></pre> </li> </ul> <ul> <li> <p>Games with hacks: games that contain <code>(Hack)</code> or <code>[h*]</code> in their name, or <code>hack</code> in their manufacturer, e.g.:</p> <pre><code>Kirby's Dream Land 2 (U) [S][h1] (Sound Test)\nPokemon - Blue Version (UE) [S][h2]\nQ-bert II (UE) [h1C]\n</code></pre> </li> </ul> <ul> <li> <p>Games with trainers: games that contain <code>[t]</code> or <code>[t#]</code> in their name, e.g.:</p> <pre><code>Qix Adventure (J) [C][t1]\nR-Type DX (U) [C][t2]\n</code></pre> </li> </ul>"}, {"location": "roms/filtering-preferences/#debug", "title": "Debug", "text": "<pre><code>--no-debug, --only-debug\n</code></pre> <p>Filter out, or only include games that contain <code>(Debug)</code> in their name, e.g.:</p> <pre><code>Megaman - Battle Network 2 (USA) (Debug Version)\nPerfect Dark (USA) (2000-03-22) (Debug)\n</code></pre>"}, {"location": "roms/filtering-preferences/#demos", "title": "Demos", "text": "<pre><code>--no-demo, --only-demo\n</code></pre> <p>Filter out or only include games that contain one of the following in their name:</p> <ul> <li><code>(Demo[a-z0-9. -]*)</code> (regex)</li> <li><code>@barai</code></li> <li><code>(Kiosk[a-z0-9. -]*)</code> (regex)</li> <li><code>(Preview)</code></li> <li><code>GameCube Preview</code></li> <li><code>Kiosk Demo Disc</code></li> <li><code>PS2 Kiosk</code></li> <li><code>PSP System Kiosk</code></li> <li><code>Taikenban</code></li> <li><code>Trial Edition</code></li> </ul> <p>or has the game category of <code>Demos</code>, e.g.:</p> <pre><code>Coria and the Sunken City (Unknown) (Demo)\nTwo Hearts (Japan) (Demo) (Unl)\n</code></pre>"}, {"location": "roms/filtering-preferences/#betas", "title": "Betas", "text": "<pre><code>--no-beta, --only-beta\n</code></pre> <p>Filter out, or only include games that contain <code>(Beta)</code> in their name, e.g.:</p> <pre><code>Cosmo Tank (Japan) (Beta)\nF-15 Strike Eagle II (USA, Europe) (Beta) (July, 1992)\n</code></pre>"}, {"location": "roms/filtering-preferences/#samples", "title": "Samples", "text": "<pre><code>--no-sample, --only-sample\n</code></pre> <p>Filter out, or only include games that contain <code>(Sample)</code> in their name, e.g.:</p> <pre><code>Mega Man III (USA) (Sample)\nShin Nihon Pro Wrestling - Toukon Sanjuushi (Japan) (Sample)\n</code></pre>"}, {"location": "roms/filtering-preferences/#prototypes", "title": "Prototypes", "text": "<pre><code>--no-prototype, --only-prototype\n</code></pre> <p>Filter out, or only include games that contain <code>(Proto)</code> or <code>(Prototype)</code> in their name, or has the game category of <code>Preproduction</code>, e.g.:</p> <pre><code>Philip &amp; Marlowe in Bloomland (USA) (Proto)\nSword of Hope, The (Europe) (Proto)\n</code></pre>"}, {"location": "roms/filtering-preferences/#program-application-roms", "title": "Program application ROMS", "text": "<pre><code>--no-program, --only-program\n</code></pre> <p>Filter out or only include games that contain one of the following in their name</p> <ul> <li><code>([a-z0-9. ]*Program)</code> (regex)</li> <li><code>Check Program</code></li> <li><code>Sample Program</code></li> </ul> <pre><code>AGB Aging Cartridge (World) (v1.0) (Test Program)\nAGB-Parallel Interface Cartridge (Japan) (En) (Program)\n</code></pre>"}, {"location": "roms/filtering-preferences/#homebrew", "title": "Homebrew", "text": "<pre><code>--no-homebrew, --only-homebrew\n</code></pre> <p>Filter out, or only include games that contain <code>(Homebrew)</code> in their name, e.g.:</p> <pre><code>Game Boy Camera Gallery 2022, The (World) (Aftermarket) (Homebrew)\nGB-Wordyl (World) (Aftermarket) (Homebrew)\n</code></pre>"}, {"location": "roms/filtering-preferences/#unverified-dumps", "title": "Unverified dumps", "text": "<pre><code>--no-unverified, --only-unverified\n</code></pre> <p>Only include, or filter out games that contain <code>[!]</code> in their name.</p> <p>For example, <code>--no-unverified</code> would filter out the following:</p> <pre><code>Getaway, The (U)\nGex - Enter the Gecko (U) [C][b1]\nGolf (W) [o1]\nGrand Theft Auto (E) (M5) [C][t1]\n</code></pre> <p>and <code>--only-unverified</code> would filter out the following:</p> <pre><code>Kirby &amp; The Amazing Mirror (U) [!]\nLegend of Zelda, The - A Link To The Past with Four Swords (E) (M5) [!]\nMario &amp; Luigi - Superstar Saga (U) [!]\n</code></pre> <p>Warning</p> <p>This is a GoodTools naming convention, other groups such as No-Intro never include <code>[!]</code> in their names!</p>"}, {"location": "roms/filtering-preferences/#bad-dumps", "title": "Bad dumps", "text": "<pre><code>--no-bad, --only-bad\n</code></pre> <p>Filter out, or only include games that contain <code>[b]</code> or <code>[b#]</code> in their name, e.g.:</p> <pre><code>[MIA] Aprilia - DiTech Interface (Unknown) (Unl) [b]\nGreat Greed (U) [b1]\nGremlins 2 - The New Batch (W) [b2]\n</code></pre> <p>as well as games that contain <code>[c]</code> or <code>[x]</code> and are not verified dumps (above), e.g.:</p> <pre><code>Brian Lara Cricket 96 (E) [a1][x]\nMicro Machines Military - It's a Blast! (E) [x]\n</code></pre> <p>Warning</p> <p>This is a GoodTools naming convention, other groups such as No-Intro never include <code>[b]</code> in their names!</p>"}, {"location": "roms/filtering-preferences/#preferences-for-1g1r", "title": "Preferences (for 1G1R)", "text": "<p>The <code>--single</code> option is required for all <code>--prefer-*</code> options, otherwise there would be no effect.</p> <p>Multiple <code>--prefer-*</code> options can be specified at once, and they will be applied in the following order of importance (most important to least important).</p> <p>Note</p> <p>Filters are applied against all DATs before ROM matching happens.</p> <p>If no DATs are provided, Igir will infer DATs from the input files, and then infer parents among those games.</p>"}, {"location": "roms/filtering-preferences/#prefer-game-names", "title": "Prefer game names", "text": "<pre><code>--prefer-game-regex &lt;pattern|filename&gt;\n</code></pre> <p>Prefer games if their DAT name (or filename if not using DATs) matches a regular expression.</p> <p>Regex flags can be optionally provided in the form <code>/&lt;pattern&gt;/&lt;flags&gt;</code>, for example:</p> <pre><code>Mario|Zelda\n/mario|zelda/i\n</code></pre>"}, {"location": "roms/filtering-preferences/#prefer-rom-filenames", "title": "Prefer ROM filenames", "text": "<pre><code>--prefer-rom-regex &lt;pattern|filename&gt;\n</code></pre> <p>Prefer games if any of their ROM filenames matches a regular expression.</p> <p>Regex flags can be optionally provided in the form <code>/&lt;pattern&gt;/&lt;flags&gt;</code>, for example:</p> <pre><code>Mario.*\\\\.gb$\n/mario.*\\\\.gb$/i\n</code></pre>"}, {"location": "roms/filtering-preferences/#prefer-verified", "title": "Prefer verified", "text": "<pre><code>--prefer-verified\n</code></pre> <p>Prefer games that contain <code>[!]</code> in their name over those that don't.</p> <p>See the unverified dumps section for more information about \"verified\" and \"unverified\" ROM dumps.</p>"}, {"location": "roms/filtering-preferences/#prefer-good", "title": "Prefer good", "text": "<pre><code>--prefer-good\n</code></pre> <p>Prefer games that don't contain <code>[b]</code> or <code>[b#]</code> in their name over those that do.</p> <p>See the bad dumps section for more information about \"good\" and \"bad\" ROM dumps.</p>"}, {"location": "roms/filtering-preferences/#prefer-language", "title": "Prefer language", "text": "<pre><code>--prefer-language [languages..]\n</code></pre> <p>Prefer games of certain languages over those in other languages. Multiple languages can be specified, in priority order, with commas between them. See the <code>--help</code> message for the full list of understood languages.</p> <p>If a game doesn't have language information specified in its name, the region's primary language will be used.</p> <p>For example, to prefer games in English and then Japanese, the command would be:</p> <pre><code>--prefer-language En,Ja\n</code></pre>"}, {"location": "roms/filtering-preferences/#prefer-region", "title": "Prefer region", "text": "<pre><code>--prefer-region [regions..]\n</code></pre> <p>Prefer games from certain regions over those from other regions. Multiple regions can be specified, in priority order, with commas between them. See the <code>--help</code> message for the full list of understood regions.</p> <p>For example, to prefer games from: USA (highest priority), \"world,\" and then Europe, the command would be:</p> <pre><code>--prefer-region USA,WORLD,EUR\n</code></pre>"}, {"location": "roms/filtering-preferences/#prefer-revision", "title": "Prefer revision", "text": "<pre><code>--prefer-revision &lt;older|newer&gt;\n</code></pre> <p>Prefer newer or older revisions, versions, or ring codes of a game.</p> <p>Revisions can be numeric:</p> <pre><code>Frogger (Europe) (En,Fr,De,Es,It,Nl) (GB Compatible)\nFrogger (USA) (Rev 1) (GB Compatible)\nFrogger (USA) (Rev 2) (GB Compatible)\n</code></pre> <p>or alphabetical:</p> <pre><code>MSR - Metropolis Street Racer (Europe) (En,Fr,De,Es)\nMSR - Metropolis Street Racer (Europe) (En,Fr,De,Es) (Rev A)\nMSR - Metropolis Street Racer (Europe) (En,Fr,De,Es) (Rev B)\n</code></pre> <p>Versions can be semantic:</p> <pre><code>F1 World Grand Prix for Dreamcast v1.011 (1999)(Video System)(JP)(en)[!]\nF1 World Grand Prix for Dreamcast v1.000 (1999)(Video System)(PAL)(M4)[!]\nF1 World Grand Prix v1.006 (2000)(Video System)(US)(M4)[!]\n</code></pre> <p>Ring codes can be numeric:</p> <pre><code>Sonic CD (USA) (RE125)\nSonic CD (USA) (RE125) (Alt)\n</code></pre>"}, {"location": "roms/filtering-preferences/#prefer-retail", "title": "Prefer retail", "text": "<pre><code>--prefer-retail\n</code></pre> <p>Prefer games that are considered \"retail\" releases over those that aren't.</p> <p>See the only retail section for more information on what games are considered \"retail.\"</p>"}, {"location": "roms/filtering-preferences/#prefer-parent", "title": "Prefer parent", "text": "<pre><code>--prefer-parent\n</code></pre> <p>Prefer games that DATs consider the \"parent\" of other game clones, over the clones themselves.</p> <p>It is unlikely you will often use this option, it is more likely other preference options will accomplish what you want.</p>"}, {"location": "roms/headers/", "title": "ROM Headers", "text": "<p>There are a handful of consoles where it is common for their ROMs to have extra data at the beginning of the file (a \"header\") that wasn't present on the physical ROM chip.</p> <p>Some of these headers are used to tell the emulator information about how to emulate the game (Atari 7800 \"A78,\" NES \"iNES,\" Famicom Disk System \"FDS,\" etc.). There are other consoles where it is somewhat common to find the ROMs without a header (Atari Lynx \"LYX,\" SNES \"SFC\").</p>"}, {"location": "roms/headers/#header-detection", "title": "Header detection", "text": "<p>Igir can detect headers for the following consoles and file extensions:</p> Console Header Extension Atari 7800 A78 <code>.a78</code> Atari Lynx LNX <code>.lnx</code> Nintendo - NES iNES, NES 2.0 <code>.nes</code> Nintendo - Famicom Disk System fsNES/FDS <code>.fds</code> Nintendo - SNES SMC <code>.smc</code> <p>Those file extensions above are the commonly accepted \"correct\" extensions, and Igir will attempt to detect if a header is present in those ROM files automatically. If for some reason your files don't have the right extension (e.g. <code>.rom</code>) you can force header detection with the <code>--header</code> glob option:</p> <pre><code>igir [commands..] --dat &lt;dats&gt; --input &lt;input&gt; --header \"*.rom\"\n</code></pre> <p>Igir will use this detected header information to compute both \"headered\" and \"headerless\" checksums of ROMs and use both of those to match against DAT files.</p> <p>Warning</p> <p>Many DAT groups expressly only include the size and checksum information for the headerless ROM, even if the header should not be removed.</p>"}, {"location": "roms/headers/#manual-header-removal", "title": "Manual header removal", "text": "<p>Some emulators cannot parse ROMs with headers and instead need a \"headerless\" version. This seems most common with SNES. Sometimes \"headerless\" files will have a different file extension:</p> Console Header HeaderedExtension HeaderlessExtension Atari 7800 A78 <code>.a78</code> (no change) Atari Lynx LNX <code>.lnx</code> <code>.lyx</code> Nintendo - NES iNES, NES 2.0 <code>.nes</code> (no change) Nintendo - Famicom Disk System fsNES/FDS <code>.fds</code> (no change) Nintendo - SNES SMC <code>.smc</code> <code>.sfc</code> <p>For every console that Igir can understand the headers for, it can also remove them with the <code>--remove-headers</code> option. This only makes sense for the consoles above with different \"headerless\" extensions, so you have to specify the extensions like this:</p> <pre><code>igir [commands..] --dat &lt;dats&gt; --input &lt;input&gt; --remove-headers .lnx,.smc\n</code></pre> <p>But if you're absolutely sure you want to remove any known header from every single ROM file, you can omit the extension argument:</p> <pre><code>igir [commands..] --dat &lt;dats&gt; --input &lt;input&gt; --remove-headers\n</code></pre>"}, {"location": "roms/headers/#automatic-header-removal", "title": "Automatic header removal", "text": "<p>Some DAT groups such as No-Intro publish \"headered\" and \"headerless\" DATs for the same console, such as NES. Igir will treat these DATs differently, it will automatically remove headers (if present) for \"headerless\" DATs, and leave the header intact for \"headered\" DATs (ignoring the <code>--remove-headers</code> option completely).</p> <p>As explained above, you almost always want the \"headered\" version. It's only in very specific circumstances that you might need the \"headerless\" version.</p>"}, {"location": "roms/matching/", "title": "ROM Matching", "text": "<p>When Igir scans ROM files in the input directory, it calculates a number of checksums to uniquely identify each file. These checksums are then matched to ones found in DATs.</p> <p>By default, Igir will use CRC32 + filesize to match input files to ROMs found in DATs. CRC32 checksums are fast to calculate, and many archive formats include them in their directory of files, which greatly speeds up scanning.</p> <p>Note</p> <p>The main drawback of CRC32 checksums are their small keyspace of 4.29 billion unique values (see below). This might seem like a lot, but it's sufficiently small enough that it is very possible for two different files to have the same CRC32. Chances of these \"collisions\" can be reduced by also comparing the filesize of the two different files.</p>"}, {"location": "roms/matching/#automatically-using-other-checksum-algorithms", "title": "Automatically using other checksum algorithms", "text": "<p>Some DAT release groups do not include every checksum for every file. For example, CHDs in MAME DATs only include SHA1 checksums and nothing else, not even filesize information.</p> <p>Some DAT release groups do not include filesize information for every file, preventing a safe use of CRC32. For example, not every Hardware Target Game Database SMDB includes file sizes, but they typically include all the normal checksums.</p> <p>Warning</p> <p>For situations like these, Igir will automatically detect what combination of checksums it needs to calculate for input files to be able to match them to DATs. This does have the chance of greatly slowing down file scanning, especially with archives.</p> <p>To constrain what checksums are calculated, you can use the <code>--input-checksum-quick</code> option (below), or <code>--input-checksum-max &lt;algorithm&gt;</code> which accepts the same algorithm options as <code>--input-checksum-min &lt;algorithm&gt;</code> (also below).</p> <p>For example, if you provide all of these DATs at once with the <code>--dat &lt;path&gt;</code> option:</p> <ul> <li>No-Intro's Nintendo Game Boy DAT (which includes filesize, CRC32, MD5, and SHA1 information)</li> <li>Hardware Target Game Database's Atari Lynx SMBD (which includes CRC32, MD5, SHA1, and SHA256 information but not filesize)</li> <li>MAME ListXML (which only includes SHA1 information for CHD \"disks\")</li> </ul> <p>...then Igir will determine that SHA1 is the minimum necessary checksum to calculate because not every ROM in every DAT includes CRC32 and filesize information.</p> <p>Note</p> <p>When generating a dir2dat with the <code>igir dir2dat</code> command, Igir will calculate CRC32, MD5, and SHA1 information for every file. This helps ensure that the generated DAT has the most complete information it can. You can additionally add SHA256 information with the option <code>igir [commands..] [options] --input-checksum-min SHA256</code> (below).</p>"}, {"location": "roms/matching/#quick-scanning-files", "title": "Quick scanning files", "text": "<p>A number of archives formats require the extraction of files to calculate their checksums, and this extraction can greatly increase scanning time and add hard drive wear &amp; tear. Igir's default settings will give you the best chance of matching input files to DATs, but there may be situations where you want to make scanning faster.</p> <p>The <code>--input-checksum-quick</code> option will prevent any extraction of archives (both in memory and using temporary files) to calculate checksums of files contained inside. This means that Igir will rely solely on the information available in the archive's file directory. Non-archive files will still have their checksum calculated as normal. See the archive formats page for more information about what file types contain what checksum information.</p> <p>Warning</p> <p>If an archive format doesn't contain any checksum information (e.g. <code>.cso</code>, <code>.tar.gz</code>), then there will be no way to match those input files to DATs when quick scanning! Only use quick scanning when all input archives store checksums of their files!</p> <p>Warning</p> <p>Different DAT groups catalog CHDs of CD-ROMs (<code>.bin</code> &amp; <code>.cue</code>) and GD-ROMs (<code>.gdi</code> &amp; <code>.bin</code>/<code>.raw</code>) that use a track sheet plus one or more track files differnetly. Take the Sega Dreamcast for example, Redump catalogs <code>.bin</code> &amp; <code>.cue</code> files (which is problematic with CHDs), MAME Redump catalogs <code>.chd</code> CD files, and TOSEC catalogs <code>.gdi</code> &amp; <code>.bin</code>/<code>.raw</code> files. Quick scanning of CHDs means only the SHA1 stored in its header will be used for matching, which may or may not work depending on the DATs you use.</p>"}, {"location": "roms/matching/#manually-using-other-checksum-algorithms", "title": "Manually using other checksum algorithms", "text": "<p>Danger</p> <p>Most people do not need to calculate checksums above CRC32. CRC32 + filesize is sufficient to match ROMs and test written files in the gross majority of cases. The below information is for people that truly know they need higher checksums.</p> <p>You can specify higher checksum algorithms with the <code>--input-checksum-min &lt;algorithm&gt;</code> option like this:</p> <pre><code>igir [commands..] [options] --input-checksum-min MD5\nigir [commands..] [options] --input-checksum-min SHA1\nigir [commands..] [options] --input-checksum-min SHA256\n</code></pre> <p>This option defines the minimum checksum that will be used based on digest size (below). If not every ROM in every DAT provides the checksum you specify, Igir may automatically calculate and match files based on a higher checksum (see above), but never lower.</p> <p>The reason you might want to do this is to have a higher confidence that found files exactly match ROMs in DATs. Keep in mind that explicitly enabling non-CRC32 checksums will greatly slow down scanning of files within archives (see <code>--input-checksum-quick</code> above).</p> <p>Here is a table that shows the keyspace for each checksum algorithm, where the higher number of bits reduces the chances of collisions:</p> Algorithm Digest size Unique values Example value CRC32 32 bits 2^32 = 4.29 billion <code>30a184a7</code> MD5 128 bits 2^128 = 340.28 undecillion <code>52bb8f12b27cebd672b1fd8a06145b1c</code> SHA1 160 bits 2^160 = 1.46 quindecillion <code>666d29a15d92f62750dd665a06ce01fbd09eb98a</code> SHA256 256 bits 2^256 = 115.79 quattuorvigintillion <code>1934e26cf69aa49978baac893ad5a890af35bdfb2c7a9393745f14dc89459137</code> <p>When files are tested after being written, Igir will use the highest checksum available from the scanned file to check the written file. This lets you have equal confidence that a file was written correctly as well as matched correctly.</p>"}, {"location": "roms/patching/", "title": "ROM Patching", "text": "<p>Patches contain a set of changes that can be applied to a file, turning that file into something different. Common examples for patching ROMs are: translating text to a different language but keeping game logic the same, and fan-made creations such as new levels for an existing game.</p> <p>Games and their ROMs are protected under copyrights, so patches are used to not share copyrighted code online. A person needs the original ROM file plus a patch file to get the resulting patched ROM that will be played with an emulator.</p>"}, {"location": "roms/patching/#specifying-patch-files", "title": "Specifying patch files", "text": "<p>Patch files can be specified with the <code>--patch &lt;path&gt;</code> option. See the file scanning docs for more information.</p>"}, {"location": "roms/patching/#patch-types", "title": "Patch types", "text": "<p>There are many, many patch types that ROM hackers use to distribute their changes on the internet (xkcd \"Standards\"). Typically, a patch will only be distributed in one format, so gamers are entirely at the mercy of the ROM hacker's choice.</p> <p>Not all patch types are created equal. Here are some tables of some existing formats, whether Igir supports them, and what the patch supports.</p> <p>Common patch types:</p> Type Supported CRC32 in patch contents Notes <code>.bps</code> \u2705 \u2705 <code>.ips</code> \u2705 IPS, IPS32 \u274c <code>.ppf</code> \u2705 2.0, 3.0 \u274c <code>.ups</code> \u2705 \u2705 \u26a0\ufe0f UPS patches read and write files byte-by-byte, making them horribly slow and inefficient. The author, byuu, created <code>.ups</code> to replace <code>.ips</code>, but then created <code>.bps</code> as a replacement for <code>.ups</code>. <code>.vcdiff</code>, <code>.xdelta</code> \u26a0\ufe0f without secondary compression \u274c \u26a0\ufe0f xdelta3 makes use of LZMA secondary compression by default, so many patches are likely to be unsupported. <p>Uncommon patch types:</p> Type Supported CRC32 in patch contents Notes <code>.aps</code> (GBA) \u2705 \u274c <code>.aps</code> (N64) \u2705 simple &amp; N64 \u274c <code>.bdf</code> (BSDiff) \u274c \u2753 <code>.bsp</code> (Binary Script Patching) \u274c \u274c BSP will probably never be supported, the implementation is non-trivial. <code>.dldi</code> (NDS libfat) \u274c \u274c No file specification exists. <code>.dps</code> (Deufeufeu) \u2705 \u274c <code>.ebp</code> (EarthBound) \u2705 \u274c EBP is just IPS with some JSON after the <code>EOF</code> string. <code>.gdiff</code> \u274c \u2753 <code>.mod</code> (Star Rod) \u274c \u2753 No file specification exists anymore. <code>.ffp</code>, <code>.pat</code> (FireFlower) \u274c \u2753 No file specification exists anymore. <code>.pds</code> (Sephiroth87's NDS) \u274c \u2753 No file specification exists. <code>.rup</code> (NINJA 2.0) \u26a0\ufe0f only single file patches, only raw/binary file type \u274c uses MD5 <code>.rxl</code> (ROM eXtension Library) \u274c \u274c RXL will probably never be supported, it is used to inject files at manually specified locations into ROMs. <p>If you have a choice in patch format, choose one that contains CRC32 checksums in the patch file contents (e.g. choose <code>.bps</code> over <code>.ips</code> if possible).</p>"}, {"location": "roms/patching/#rom-checksums", "title": "ROM checksums", "text": "<p>Igir needs to be able to know what source ROM each patch file applies to, and it does this using CRC32 checksums.</p> <p>A few patch formats include the source ROM's CRC32 checksum in the patch's file contents. This is the most accurate and therefore the best way to get source ROM information. <code>.bps</code> is a great example of an efficient and simple patch format that includes this information.</p> <p>Most patch formats do not include the source ROM's CRC32 checksum. <code>.ips</code> patches are some of the most likely you will come across. For those patches, you need to put the source ROM's CRC32 checksum in the patch's filename, either at the beginning or end, like this:</p> <pre><code>Source ROM filename:\nSuper Mario Land (World).gb\n\nPatch filename:\nSuper Mario Land DX v2.0 (World) 90776841.ips\n</code></pre> <pre><code>Source ROM filename:\nNBA Jam - Tournament Edition (USA) (Track 1).bin\n\nPatch filename:\na8f1adf5 NBA Jam 22 v1.4.ppf\n</code></pre>"}, {"location": "roms/patching/#creating-rom-patches", "title": "Creating ROM patches", "text": "<p>Marc Robledo's Rom Patcher JS site is a great resource for creating ROM patches in a number of common formats without the need to download any tools.</p>"}, {"location": "roms/sets/", "title": "ROM Sets", "text": "<p>\"Sets\" here refers to the collection of all ROM files for a game. The options here change what is included or excluded from sets, how sets can be combined, and what is permissible in sets.</p>"}, {"location": "roms/sets/#rom-set-merge-types", "title": "ROM set merge types", "text": "<p>The <code>--merge-roms &lt;mode&gt;</code> option is used to reduce storage requirements when working with MAME and other arcade DATs that supply parent/clone information. See the arcade docs for information on this option.</p>"}, {"location": "roms/sets/#merging-multi-disc-games", "title": "Merging multi-disc games", "text": "<p>Most DAT groups that catalog optical media-based consoles (e.g. PS1, Dreamcast, GameCube) consider different discs of a multi-disc game to be separate \"games,\" with no relation between them other than having a similar name. This is because ROM managers may not process games unless all of its ROM files are present, but there may be bonus discs that you don't care about for storage reasons.</p> <p>The <code>--merge-discs</code> option will merge these separate discs into a single game. The option relies on well-named files in formats like these:</p> <ul> <li> <p>Redump-style:</p> <pre><code>Final Fantasy IX (USA) (Disc 1)\nFinal Fantasy IX (USA) (Disc 2)\nFinal Fantasy IX (USA) (Disc 3)\nFinal Fantasy IX (USA) (Disc 4)\n\nMetal Gear Solid - The Twin Snakes (USA) (Disc 1)\nMetal Gear Solid - The Twin Snakes (USA) (Disc 2)\n</code></pre> </li> </ul> <ul> <li> <p>TOSEC-style:</p> <pre><code>Skies of Arcadia v1.002 (2000)(Sega)(US)(Disc 1 of 2)[!]\nSkies of Arcadia v1.002 (2000)(Sega)(US)(Disc 2 of 2)[!]\n\nPanzer Dragoon Saga v1.000 (1998)(Sega)(PAL)(Disc 1 of 4)[!]\nPanzer Dragoon Saga v1.000 (1998)(Sega)(PAL)(Disc 2 of 4)[!]\nPanzer Dragoon Saga v1.000 (1998)(Sega)(PAL)(Disc 3 of 4)[!]\nPanzer Dragoon Saga v1.000 (1998)(Sega)(PAL)(Disc 4 of 4)[!]\n</code></pre> </li> </ul> <p>Note</p> <p>This option doesn't require you to supply DATs with the <code>--dat &lt;path&gt;</code> option, but doing so will greatly increase the chance of the option working as intended.</p> <p>Info</p> <p>Multi-disc games can also be associated together for emulators and frontends with the <code>igir playlist</code> command.</p>"}, {"location": "roms/sets/#merging-limitations", "title": "Merging limitations", "text": "<ul> <li> <p>TOSEC-style ring/box codes.</p> <p>The way that TOSEC catalogs different pressings of discs may prevent the merging of discs together.</p> <p>For example, with Shenmue for the Sega Dreamcast. There are two pressings of the third disc, but we probably only want one of them, so it doesn't make sense to merge all of these together:</p> <pre><code>Shenmue v1.003 (2000)(Sega)(US)(Disc 1 of 4)[!][1S]\nShenmue v1.003 (2000)(Sega)(US)(Disc 2 of 4)[!]\nShenmue v1.003 (2000)(Sega)(US)(Disc 3 of 4)[!][1S]\nShenmue v1.003 (2000)(Sega)(US)(Disc 3 of 4)[!][2S]\nShenmue v1.003 (2000)(Sega)(US)(Disc 4 of 4)[!][Passport v1.004]\n</code></pre> <p>TOSEC doesn't have a standard for these codes, so it's difficult to programmatically differentiate them from other metadata. Here are some other examples that don't make sense to merge together:</p> <pre><code># Philips CD-i\n7th Guest, The (1994)(Philips)(EU)(Disc 1 of 2)[!][The Game][DVC][8110033V113 50404169 02]\n7th Guest, The (1994)(Philips)(EU)(Disc 1 of 2)[!][The Game][DVC][8111033V113 50404169 01]\n7th Guest, The (1994)(Philips)(EU)(Disc 2 of 2)[!][The Music, Die Musik][CD-Audio]\n\n# Sega CD\nGround Zero Texas (1993)(Sony Imagesoft)(NTSC)(US)(Disc 1 of 2)[!]\nGround Zero Texas (1993)(Sony Imagesoft)(NTSC)(US)(Disc 2 of 2)[!][CDAC-053300 1]\nGround Zero Texas (1993)(Sony Imagesoft)(NTSC)(US)(Disc 2 of 2)[!][CDAC-053300 2]\n\n# Sega Saturn\nEnemy Zero v1.000 (1996)(Warp)(JP)(Disc 1 of 4)[!][Disk-0 - Opening Disk][T-30001GP-01270 2M3]\nEnemy Zero v1.000 (1996)(Warp)(JP)(Disc 1 of 4)[!][Disk-0 - Opening Disk][T-30001GP-01270-P1K]\nEnemy Zero v1.000 (1996)(Warp)(JP)(Disc 1 of 4)[!][Disk-0 - Opening Disk][T-30001GP-01270-P2K]\nEnemy Zero v1.000 (1996)(Warp)(JP)(Disc 2 of 4)[!][Disk-1 - Game Disk][T-30001GP-01271-P1K]\nEnemy Zero v1.000 (1996)(Warp)(JP)(Disc 2 of 4)[!][Disk-1 - Game Disk][T-30001GP-01271-P2K]\nEnemy Zero v1.000 (1996)(Warp)(JP)(Disc 3 of 4)[!][Disk-2 - Game Disk][T-30001GP-01272 2MB5, 2MM1]\nEnemy Zero v1.000 (1996)(Warp)(JP)(Disc 3 of 4)[!][Disk-2 - Game Disk][T-30001GP-01272-P1C, P2C]\nEnemy Zero v1.000 (1996)(Warp)(JP)(Disc 4 of 4)[!][Disk-3 - Game Disk][T-30001GP-01273 1M1]\nEnemy Zero v1.000 (1996)(Warp)(JP)(Disc 4 of 4)[!][Disk-3 - Game Disk][T-30001GP-01273 1MM1, 4M1]\nEnemy Zero v1.000 (1996)(Warp)(JP)(Disc 4 of 4)[!][Disk-3 - Game Disk][T-30001GP-01273-P1K]\n</code></pre> </li> </ul> <ul> <li> <p>TOSEC-style metadata.</p> <p>Because it is difficult to programmatically differentiate ring/box codes from other metadata, multi-disc games such as these won't be merged together:</p> <pre><code># Sega CD\nEcco the Dolphin CD (1995)(Sega)(NTSC)(JP)(Disc 1 of 2)[!][Ecco the Dolphin]\nEcco the Dolphin CD (1995)(Sega)(NTSC)(JP)(Disc 2 of 2)[!][Ecco the Dolphin II]\n\n# Sega Dreamcast\nResident Evil 2 v1.001 (2000)(Capcom)(US)(Disc 1 of 2)[!][Leon]\nResident Evil 2 v1.001 (2000)(Capcom)(US)(Disc 2 of 2)[!][Claire]\n\n# Sega Saturn\nEve Burst Error v1.000 (1996)(Imagineer)(JP)(Disc 1 of 4)[!][Kojiroh Disc]\nEve Burst Error v1.000 (1996)(Imagineer)(JP)(Disc 2 of 4)[!][Marina Disc]\nEve Burst Error v1.000 (1996)(Imagineer)(JP)(Disc 3 of 4)[!][Terror Disc]\nEve Burst Error v1.000 (1996)(Imagineer)(JP)(Disc 4 of 4)[!][Making Disc]\n</code></pre> </li> </ul>"}, {"location": "roms/sets/#allowing-inexact-sets", "title": "Allowing inexact sets", "text": "<p>Igir has two options that allow for inexact sets of ROM files:</p> <ul> <li> <p><code>--allow-excess-sets</code></p> <p>Downloaded archives may have extra junk or metadata files in them such as <code>.txt</code> or <code>.nfo</code> files. When writing archives without extracting or zipping them, this option will allow those archives with excess files to still be used.</p> </li> </ul> <ul> <li> <p><code>--allow-incomplete-sets</code></p> <p>This option will allow writing games where not every one of its ROMs was found in an <code>--input &lt;path&gt;</code> directory. This could be useful for arcade DATs that change ROM sets between versions.</p> </li> </ul>"}, {"location": "roms/trimming/", "title": "ROM Trimming", "text": "<p>Warning</p> <p>Igir does not support creating trimmed ROMs, it only supports detecting trimmed ROMs and matching them against DAT files. To trim ROMs, you should use a tool such as NDSToky`oTrim.</p> <p>ROM chips found in cartridges typically come in sizes that are a power of two (e.g. 32KiB, 128KiB, 64MiB, 2GiB, etc.). Because people in the ROM community value preservation, ROM dumps typically contain full contents of the ROM chip. However, most games don't need exactly all the space on their ROM chip, so there is usually blank space at the end of the ROM in the form of <code>0x00</code> or <code>0xFF</code> bytes.</p> <p>It has become common to \"trim\" this padding at the end of ROM dumps for some handheld consoles, to save space on flash carts. Igir is able to detect ROMs that have been trimmed and add back their padding bytes so that they can be matched against DAT files.</p> <p>Igir can process these file types:</p> Console Extension Most commonpadding byte Most common ROM sizes Nintendo - 3DS <code>.3ds</code> <code>0xFF</code> 0.5, 1, 2 GiB Nintendo - DS <code>.nds</code> <code>0x00</code> 8, 16, 32, 64, 128 MiB Nintendo - Game Boy Advance <code>.gba</code> <code>0x00</code> 4, 8, 16, 32 MiB <p>Igir can detect these files from their signature even if the file extension is wrong.</p> <p>If you wish to force trimming detection of other file types (not recommended), you can use the <code>--trimmed-glob &lt;glob&gt;</code> option like this:</p> <pre><code>igir [commands..] --dat &lt;dats&gt; --input &lt;input&gt; --trimmed-glob \"*.rom\"\n</code></pre>"}, {"location": "roms/trimming/#padding-strategy", "title": "Padding strategy", "text": "<p>Igir detects the \"correct\" size for a ROM by rounding the trimmed file's size up to the nearest power of two. Here are some examples:</p> Console ROM Size when trimmed by NDSTokyoTrim v3.11 Full size Nintendo - 3DS <code>Heroes of Ruin (USA) (En,Fr,Es).3ds</code> 494.7MiB (96.6%) 512MiB (2^29) Nintendo - 3DS <code>Steel Diver (USA) (En,Fr,Es).3ds</code> 175.5MiB (68.5%) 256MiB (2^28) Nintendo - 3DS <code>Theatrhythm Final Fantasy - Curtain Call (USA).3ds</code> 1.7GiB (83.1%) 2GiB (2^31) Nintendo - DS <code>Kirby - Canvas Curse (USA).nds</code> 50.6MiB (79.0%) 64MiB (2^26) Nintendo - DS <code>Metroid Prime - Hunters - First Hunt (USA, Australia) (Demo) (Not for Resale).nds</code> 14.9MiB (93.1%) 16MiB (2^24) Nintendo - DS <code>Picross DS (USA) (En,Fr,Es).nds</code> 31.9MiB (99.6%) 32MiB (2^25) Nintendo - Game Boy Advance <code>2 Game Pack! - Uno + Skip-Bo (USA).gba</code> 3.9MiB (96.5%) 4MiB (2^22) Nintendo - Game Boy Advance <code>Golden Sun - The Lost Age (USA, Europe).gba</code> 15.5MiB (96.7%) 16MiB (2^24) Nintendo - Game Boy Advance <code>Zone of the Enders - The Fist of Mars (USA).gba</code> 7.5MiB (94.4%) 8MiB (2^23) <p>Even though each console has a padding byte that is most common (above), this isn't a guarantee, so Igir will calculate two different sets of checksums using both <code>0x00</code> and <code>0xFF</code> padding bytes.</p> <p>Like other calculated checksums, checksums of the padded files are cached to speed up subsequent runs.</p>"}, {"location": "roms/trimming/#trimmed-roms-in-archives", "title": "Trimmed ROMs in archives", "text": "<p>It does not make sense to archive trimmed ROMs. Even the simplest of compression algorithms will compress ROM padding to just a few bytes, so trimming before archiving will have very little effect.</p> <p>To save processing time, Igir will not detect ROM trimming for files in archives. If you need to enable this behavior, you can use the option:</p> <pre><code>--trim-scan-archives\n</code></pre> <p>You can also force trimming detection using the <code>--trimmed-glob &lt;glob&gt;</code> option described above.</p>"}, {"location": "usage/arcade/", "title": "Arcade ROM Sets", "text": "<p>Building a ROM set that works with the exact version of your arcade emulator is necessarily complicated, and the terminology is confusing.</p> <p>This page is written to give users just enough context to build &amp; re-build arcade ROM sets. MAME, MAMEWorld, Pleasuredome, RetroArch, and RetroPie are great resources to read more about the nuances of arcade emulation &amp; ROM sets.</p> <p>Warning</p> <p>People often shorthand all arcade emulation as \"MAME,\" but there are other modern and actively maintained arcade emulators such as FinalBurn Neo. Different emulators have different needs, so it's important to understand what emulator and what version you're using.</p>"}, {"location": "usage/arcade/#emulator-versions-dats", "title": "Emulator versions &amp; DATs", "text": "<p>Unlike traditional console emulators that only have to emulate a small set of hardware, arcade emulators have the monumental task of emulating a wildly varying number of hardware chips, inputs, and outputs. This results in each version of an emulator having a very specific set of games it can emulate, and newer emulator versions will likely add more games to this set.</p> <p>Due to arcade machines being more complicated and rarer than games for home consoles, arcade ROM dumps are sometimes imperfect. Because of this, newer emulator versions may expect different ROM files than older versions. This makes ROM sets potentially incompatible between different emulator versions.</p> <p>Because of all of these reasons, each arcade emulator version usually comes with a companion DAT that details the exact set of ROM files supported by that exact emulator version. Emulators such as MAME take this a step further and expect an exact zip file name for each game.</p> <p>Danger</p> <p>tl;dr each arcade emulator version has an exact DAT file you need to use to sort your ROMs or your games may not work!</p>"}, {"location": "usage/arcade/#finding-dats", "title": "Finding DATs", "text": "<p>Here is a chart of instructions for various setups:</p> Emulator How to get DATs Alternatives Frontends (Batocera, EmulationStation, Lakka, Recalbox, RetroArch, RetroPie, etc.) Each frontend's documentation should have instructions or links to download the appropriate DAT(s). For example, RetroArch's arcade docs links to the exact DAT needed for each arcade core. N/A MAME The easiest way to ensure you're using exactly the right DAT for your MAME version is to provide the executable as <code>--dat ./mame</code>. See the DATs page for more information. A standalone download of the latest MAME ListXML can be found on the official site. See the DATs page for other alternatives. FinalBurn Neo FinalBurn Neo doesn't provide an obvious way to find the correct DAT for each version. But it is likely that you are using FinalBurn Neo through a frontend, so use the above instructions.If you are using RetroArch's FinalBurn Neo core then you can use their DATs from GitHub. N/A FinalBurn Alpha FinalBurn Alpha was forked into FinalBurn Neo, so you should use that if possible. Otherwise, hopefully your frontend's documentation has links to download the correct DAT. N/A"}, {"location": "usage/arcade/#rom-set-merge-types", "title": "ROM set merge types", "text": "<p>There are three broadly accepted types of ROM sets, with one extra variation, resulting in four types.</p> <p>First, you will want to read up on parent/clone sets and how DATs catalog them.</p> <p>Here is a comparison chart:</p> Type Parent games Clone games BIOS &amp; hardware device ROMs Pros &amp; cons Full non-mergedThe ROM set for each game contains every file necessary, including all ROM files from its parent, and BIOS &amp; hardware device ROMs. This is the most space-inefficient way to store games because parent, BIOS, and hardware device ROMs will be duplicated potentially multiple times, but this type offers the greatest portability.Note: other tools such as ClrMamePro don't offer this as a standalone type, but instead offer an option to not separate BIOS sets.<code>--merge-roms fullnonmerged</code> (default) \u2705 Contains all of its own ROMs, as well as BIOS &amp; hardware device ROMs \u2705 Contains all of its own ROMs and its parent's ROMs, as well as BIOS &amp; hardware device ROMs \u2705 Included Most disk space, but game files can be played entirely in isolation.Makes for a safe default choice because of the portability of output files. Non-mergedThe ROM set for each game contains all game files, including all ROM files from its parent, without BIOS &amp; hardware device ROMs. This means that games will depend on BIOS and hardware device ROMs existing in other archives.Note: Pleasuredome includes BIOS files in their non-merged sets in a non-standard way. <code>--merge-roms nonmerged</code> Contains all of its own ROMs, without BIOS &amp; hardware device ROMs \ud83d\udc6a Contains all of its own ROMs and its parent's ROMs, without BIOS &amp; hardware device ROMs \u27a1\ufe0f Expected to exist elsewhere Game files can be played mostly in isolation while eliminating frequently duplicated BIOS &amp; device hardware ROMs. SplitThe ROM set for each game contains only its own files, excluding any ROMs that are already present in its parent.                                                                                                                                                                                                                                                                                                                                                                                                             <code>--merge-roms split</code> Contains all of its own ROMs, without BIOS &amp; hardware device ROMs \ud83d\udc76 Contains only its own ROMs, excluding any ROMs already present in its parent, and without BIOS &amp; hardware device ROMs \u27a1\ufe0f Expected to exist elsewhere Smallest amount of disk usage that still keeps clone games as separate files.Makes for a good choice because of its high compatability with emulator frontends while also saving disk space. MergedThe ROM set for each game and all of its clones are merged together, eliminating duplicate ROMs and preserving disk space.Note: most downloads found online will be in this format because it is the most space-efficient. <code>--merge-roms merged</code> Contains all of its own ROMs, without BIOS &amp; hardware device ROMs \u27a1\ufe0f Merged into its parent \u27a1\ufe0f Expected to exist elsewhere Least disk space, but emulators such as RetroArch may not be able to automatically detect clones. <p>The ROM merge type can be specified with the <code>--merge-roms &lt;type&gt;</code> option, with the types described above:</p>  Windows macOS Linux <pre><code>igir copy zip ^\n  --dat \"mame0258b_64bit.exe\" ^\n  --input &lt;input&gt; ^\n  --output &lt;output&gt; ^\n  --merge-roms split\n</code></pre> <pre><code>igir copy zip \\\n  --dat \"mame0258-x86/mame\" \\\n  --input &lt;input&gt; \\\n  --output &lt;output&gt; \\\n  --merge-roms split\n</code></pre> <pre><code>igir copy zip \\\n  --dat \"$(which \"mame\")\" \\\n  --input &lt;input&gt; \\\n  --output &lt;output&gt; \\\n  --merge-roms split\n</code></pre>"}, {"location": "usage/arcade/#chd-disks", "title": "CHD disks", "text": "<p>As arcade machines got more complicated, their storage requirements grew beyond what ROM chips can handle cost effectively. Cabinets started embedding hard drives, optical drives, laser disc drives, and more. Because backup images of these media types can get large, the MAME developers created a new compression format called \"compressed hunks of data\" (CHD).</p> <p>MAME DATs catalog these \"disks\" separately from \"ROMs,\" which lets users choose whether to care about them or not. Typically, games that require disks will not run without them, so Igir requires them for a game to be considered present/complete. You can use the <code>--exclude-disks</code> option to exclude disks and only process ROMs to save some space.</p>"}, {"location": "usage/arcade/#example-building-a-new-rom-set", "title": "Example: building a new ROM set", "text": "<p>Let's say we want to build an arcade ROM set that's compatible with the most recent version of RetroArch. The steps would look like this:</p> <ol> <li> <p>Determine which arcade emulator we want to use.</p> <p>Let's say we want to use MAME, for its high accuracy.</p> </li> <li> <p>Determine the arcade emulator's version.</p> <p>After downloading and loading the \"Arcade (MAME - Current)\" core in the RetroArch UI, the footer of the \"core information\" menu says the MAME version is \"MAME (0.258 (b6d4105ea))\".</p> </li> <li> <p>Locate or download the emulator version's DAT.</p> <p>progetto-SNAPS provides a mirror of mostly unaltered MAME ListXMLs, so we'll download the 0.258 (August 30, 2023) DAT from it.</p> </li> <li> <p>Obtain a set of arcade ROM files.</p> <p>This is left as an exercise for the reader.</p> </li> <li> <p>Determine what kind of ROM set we want.</p> <p>Let's say we care first and foremost that the arcade games \"just work,\" and then we would like to conserve disk space. A \"split\" ROM set makes a good choice because RetroArch should be able to automatically index every game, including both parents and clones.</p> </li> <li> <p>Run Igir.</p> <p>Note</p> <p>Most arcade emulators expect games to be in zip files, so it is important to specify the <code>igir zip</code> command.</p> <p>After determining where we want to put our ROMs, we can build our MAME v0.258 ROM set like this:</p>  Windows (64-bit) Windows (32-bit) macOS Linux <pre><code>igir copy zip ^\n  --dat \"MAME_Dats_258\\DATs\\MAME 0.258.dat\" ^\n  --input \"MAME-ROMs\\\" ^\n  --output C:\\RetroArch-Win64\\roms\\MAME-0.258 ^\n  --merge-roms split\n</code></pre> <pre><code>igir copy zip ^\n  --dat \"MAME_Dats_258\\DATs\\MAME 0.258.dat\" ^\n  --input \"MAME-ROMs\\\" ^\n  --output C:\\RetroArch-Win32\\roms\\MAME-0.258 ^\n  --merge-roms split\n</code></pre> <pre><code>igir copy zip \\\n  --dat \"MAME_Dats_258/DATs/MAME 0.258.dat\" \\\n  --input \"MAME-ROMs/\" \\\n  --output ~/Documents/RetroArch/roms/MAME-0.258 \\\n  --merge-roms split\n</code></pre> <pre><code>igir copy zip \\\n  --dat \"MAME_Dats_258/DATs/MAME 0.258.dat\" \\\n  --input \"MAME-ROMs/\" \\\n  --output ~/Documents/RetroArch/roms/MAME-0.258 \\\n  --merge-roms split\n</code></pre> </li> </ol>"}, {"location": "usage/arcade/#example-re-building-a-rom-set", "title": "Example: re-building a ROM set", "text": "<p>Most other ROM managers use the terms \"re-build\" &amp; \"fix\" when talking about taking an existing set of arcade ROMs, a different emulator version's DAT, and using that DAT to perform an in-place rename of the ROM files. You can think about this as \"upgrading\" or \"downgrading\" your ROM set to work with a different emulator version.</p> <p>Note</p> <p>A game's required ROM files may change between emulator versions. This usually occurs when bad ROM dumps are replaced with better dumps. Igir cannot magically deal with these ROM differences, and Igir will only write complete ROM sets, so you may see games disappear when re-building. You will need to source the differing ROM files in order to keep your full game set.</p> <p>A major reason Igir was created was to help disambiguate what it means to build &amp; re-build ROM sets. Igir explicitly requires users to choose whether ROM files are copied or moved, so that users know what decision they're making. To \"re-build\" a ROM set, a user just needs to <code>igir move</code> ROMs from an input directory to the same directory specified again as the output.</p> <p>Taking the MAME v0.258 set we created above, let's say we want to \"downgrade\" it to MAME 2003 (v0.78) because an underpowered device requires it. The steps would look like this:</p> <ol> <li> <p>Locate or download the emulator version's DAT.</p> <p>progetto-SNAPS provides a mirror of mostly unaltered MAME ListXMLs, so we'll download the 0.78 (December 25, 2003) DAT from it.</p> </li> <li> <p>Optional: obtain a set of the arcade ROM files that MAME v0.78 needs that v0.258 doesn't have.</p> <p>These are sometimes called \"rollback\" sets.</p> <p>This is left as an exercise for the reader.</p> </li> <li> <p>Run Igir.</p>  Windows (64-bit) Windows (32-bit) macOS Linux <pre><code>igir copy zip ^\n  --dat \"MAME Dats 0.78\\MAME 078.dat\" ^\n  --input C:\\RetroArch-Win64\\roms\\MAME-0.258 ^\n  --input \"MAME-0.78-Rollback\\\" ^\n  --output C:\\RetroArch-Win64\\roms\\MAME-0.78 ^\n  --merge-roms split\n</code></pre> <pre><code>igir copy zip ^\n  --dat \"MAME Dats 0.78\\MAME 078.dat\" ^\n  --input C:\\RetroArch-Win32\\roms\\MAME-0.258 ^\n  --input \"MAME-0.78-Rollback\\\" ^\n  --output C:\\RetroArch-Win32\\roms\\MAME-0.78 ^\n  --merge-roms split\n</code></pre> <pre><code>igir copy zip \\\n  --dat \"MAME Dats 0.78/MAME 078.dat\" \\\n  --input ~/Documents/RetroArch/roms/MAME-0.258 \\\n  --input \"MAME-0.78-Rollback/\" \\\n  --output ~/Documents/RetroArch/roms/MAME-0.78 \\\n  --merge-roms split\n</code></pre> <pre><code>igir copy zip \\\n  --dat \"MAME Dats 0.78/MAME 078.dat\" \\\n  --input ~/Documents/RetroArch/roms/MAME-0.258 \\\n  --input \"MAME-0.78-Rollback/\" \\\n  --output ~/Documents/RetroArch/roms/MAME-0.78 \\\n  --merge-roms split\n</code></pre> </li> </ol>"}, {"location": "usage/arcade/#building-other-rom-sets", "title": "Building other ROM sets", "text": "<p>Sometimes people have a need to build very specific sets. Here are some instructions on how you would build them.</p>"}, {"location": "usage/arcade/#bios-set", "title": "BIOS set", "text": "<p>Build a set of only BIOS files, with each in its own <code>.zip</code> file:</p>  Windows macOS Linux <pre><code>igir copy zip ^\n  --dat \"MAME_Dats_258\\DATs\\MAME 0.258.dat\" ^\n  --input \"MAME-ROMs\\\" ^\n  --output \"MAME-BIOS\\\" ^\n  --only-bios\n</code></pre> <pre><code>igir copy zip \\\n  --dat \"MAME_Dats_258/DATs/MAME 0.258.dat\" \\\n  --input \"MAME-ROMs/\" \\\n  --output \"MAME-BIOS/\" \\\n  --only-bios\n</code></pre> <pre><code>igir copy zip \\\n  --dat \"MAME_Dats_258/DATs/MAME 0.258.dat\" \\\n  --input \"MAME-ROMs/\" \\\n  --output \"MAME-BIOS/\" \\\n  --only-bios\n</code></pre>"}, {"location": "usage/arcade/#device-set", "title": "Device set", "text": "<p>Build a set of only device files, with each in its own <code>.zip</code> file:</p>  Windows macOS Linux <pre><code>igir copy zip ^\n  --dat \"MAME_Dats_258\\DATs\\MAME 0.258.dat\" ^\n  --input \"MAME-ROMs\\\" ^\n  --output \"MAME-Devices\\\" ^\n  --only-device\n</code></pre> <pre><code>igir copy zip \\\n  --dat \"MAME_Dats_258/DATs/MAME 0.258.dat\" \\\n  --input \"MAME-ROMs/\" \\\n  --output \"MAME-Devices/\" \\\n  --only-device\n</code></pre> <pre><code>igir copy zip \\\n  --dat \"MAME_Dats_258/DATs/MAME 0.258.dat\" \\\n  --input \"MAME-ROMs/\" \\\n  --output \"MAME-Devices/\" \\\n  --only-device\n</code></pre>"}, {"location": "usage/basic/", "title": "Basic Usage Examples", "text": "<p>A walkthrough of an example way to sort your ROM collection.</p> <p>Info</p> <p>See the <code>igir --help</code> message for a few common examples.</p>"}, {"location": "usage/basic/#with-dats", "title": "With DATs", "text": "<p>Even though Igir can work without DATs, using DATs to sort your collection is the best practice to end up with the most accurate and organized set of ROMs.</p>"}, {"location": "usage/basic/#first-time-collection-sort", "title": "First time collection sort", "text": "<p>First, you need to download a set of DATs. For these examples I'll assume you downloaded a No-Intro daily P/C XML <code>.zip</code>.</p> <p>Let's say that you have a directory named <code>ROMs/</code> that contains ROMs for many different systems, and it needs some organization. To make sure we're alright with the output, we'll have Igir copy these files to a different directory rather than move them. We'll also zip them to reduce disk space &amp; speed up future scans.</p>  Windows macOS Linux <pre><code>igir copy zip test ^\n  --dat \"No-Intro*.zip\" ^\n  --input ROMs\\ ^\n  --output ROMs-Sorted\\ ^\n  --dir-dat-name\n</code></pre> <pre><code>igir copy zip test \\\n  --dat \"No-Intro*.zip\" \\\n  --input ROMs/ \\\n  --output ROMs-Sorted/ \\\n  --dir-dat-name\n</code></pre> <pre><code>igir copy zip test \\\n  --dat \"No-Intro*.zip\" \\\n  --input ROMs/ \\\n  --output ROMs-Sorted/ \\\n  --dir-dat-name\n</code></pre> <p>This will organize your ROMs into system-specific subdirectories within the <code>ROMs-Sorted/</code> directory and name all of your ROMs according to the No-Intro DATs. Because we copied and didn't move the files, no files were deleted from the <code>ROMs/</code> input directory.</p> <p><code>ROMs-Sorted/</code> then might look something like this:</p> <pre><code>ROMs-Sorted/\n\u251c\u2500\u2500 Nintendo - Game Boy\n\u2502   \u251c\u2500\u2500 Pokemon - Blue Version (USA, Europe) (SGB Enhanced).zip\n\u2502   \u2514\u2500\u2500 Pokemon - Yellow Version - Special Pikachu Edition (USA, Europe) (CGB+SGB Enhanced).zip\n\u251c\u2500\u2500 Nintendo - Game Boy Advance\n\u2502   \u251c\u2500\u2500 Pokemon - Emerald Version (USA, Europe).zip\n\u2502   \u2514\u2500\u2500 Pokemon - Sapphire Version (USA, Europe) (Rev 2).zip\n\u2514\u2500\u2500 Nintendo - Game Boy Color\n    \u251c\u2500\u2500 Pokemon - Crystal Version (USA, Europe) (Rev 1).zip\n    \u2514\u2500\u2500 Pokemon Pinball (USA, Australia) (Rumble Version) (SGB Enhanced) (GB Compatible).zip\n</code></pre> <p>Info</p> <p>See the output path options and output path tokens pages for other ways that you can organize your collection.</p>"}, {"location": "usage/basic/#subsequent-collection-sorts", "title": "Subsequent collection sorts", "text": "<p>Let's say that we've done the above first time sort and were happy with the results. We can now consider the <code>ROMs-Sorted/</code> directory to be our \"golden\" or \"primary\" collection, as every file in there has been matched to a DAT.</p> <p>We now have new ROMs that we want to merge into our collection, and we want to generate a report of what ROMs are still missing. We also want to \"clean\" or delete any unknown files that may have made their way into our collection.</p>  Windows macOS Linux <pre><code>igir move zip test clean report ^\n  --dat \"No-Intro*.zip\" ^\n  --input ROMs-New\\ ^\n  --input ROMs-Sorted\\ ^\n  --output ROMs-Sorted\\ ^\n  --dir-dat-name\n</code></pre> <pre><code>igir move zip test clean report \\\n  --dat \"No-Intro*.zip\" \\\n  --input ROMs-New/ \\\n  --input ROMs-Sorted/ \\\n  --output ROMs-Sorted/ \\\n  --dir-dat-name\n</code></pre> <pre><code>igir move zip test clean report \\\n  --dat \"No-Intro*.zip\" \\\n  --input ROMs-New/ \\\n  --input ROMs-Sorted/ \\\n  --output ROMs-Sorted/ \\\n  --dir-dat-name\n</code></pre> <p>Any new ROMs in <code>ROMs-New/</code> that we didn't already have in <code>ROMs-Sorted/</code> will be moved to <code>ROMs-Sorted/</code>, and a report will be generated for us.</p> <p>Note</p> <p>Note that we're using <code>ROMs-Sorted/</code> as both an input directory and as the output directory. This is required to ensure the <code>clean</code> command doesn't delete \"good\" files already in the output directory!</p> <p>You can always use the <code>--clean-dry-run</code> option to see what files would be deleted without actually deleting them.</p> <p><code>ROMs-Sorted/</code> then might look something like this, with new ROMs added:</p> <pre><code>ROMs-Sorted/\n\u251c\u2500\u2500 Nintendo - Game Boy\n\u2502   \u251c\u2500\u2500 Pokemon - Blue Version (USA, Europe) (SGB Enhanced).zip\n\u2502   \u251c\u2500\u2500 Pokemon - Red Version (USA, Europe) (SGB Enhanced).zip\n\u2502   \u2514\u2500\u2500 Pokemon - Yellow Version - Special Pikachu Edition (USA, Europe) (CGB+SGB Enhanced).zip\n\u251c\u2500\u2500 Nintendo - Game Boy Advance\n\u2502   \u251c\u2500\u2500 Pokemon - Emerald Version (USA, Europe).zip\n\u2502   \u251c\u2500\u2500 Pokemon - Ruby Version (USA, Europe) (Rev 2).zip\n\u2502   \u2514\u2500\u2500 Pokemon - Sapphire Version (USA, Europe) (Rev 2).zip\n\u2514\u2500\u2500 Nintendo - Game Boy Color\n    \u251c\u2500\u2500 Pokemon - Crystal Version (USA, Europe) (Rev 1).zip\n    \u2514\u2500\u2500 Pokemon Pinball (USA, Australia) (Rumble Version) (SGB Enhanced) (GB Compatible).zip\n</code></pre>"}, {"location": "usage/basic/#flash-cart-1g1r", "title": "Flash cart 1G1R", "text": "<p>Let's say we've done the above sorting we want to copy some ROMs from <code>ROMs-Sorted/</code> to a flash cart.</p> <p>We would prefer having only one copy of every game because we have a preferred language, and so there is less to scroll through to find what game we want.</p> <p>Note</p> <p>The common name for this is \"one-game, one-ROM\" or \"1G1R\"\u2014this is what Igir is named after! Igir has some of the most extensive filtering and 1G1R options of any ROM manager.</p> <p>Our example flash cart, like most flash carts, can't read <code>.zip</code> files, so we'll need to extract our ROMs during copying.</p>  Windows macOS Linux <p>Replace the <code>E:\\</code> drive letter with wherever your SD card is:</p> <pre><code>igir copy extract test clean ^\n  --dat \"No-Intro*.zip\" ^\n  --input \"ROMs-Sorted\\Nintendo - Game Boy\" ^\n  --output E:\\ ^\n  --dir-letter ^\n  --no-bios ^\n  --single ^\n  --prefer-language EN ^\n  --prefer-region USA,WORLD,EUR,JPN\n</code></pre> <p>Replace the <code>/Volumes/FlashCart</code> drive name with whatever your SD card is named:</p> <pre><code>igir copy extract test clean \\\n  --dat \"No-Intro*.zip\" \\\n  --input \"ROMs-Sorted/Nintendo - Game Boy\" \\\n  --output /Volumes/FlashCart/ \\\n  --dir-letter \\\n  --no-bios \\\n  --single \\\n  --prefer-language EN \\\n  --prefer-region USA,WORLD,EUR,JPN\n</code></pre> <p>Replace the <code>/media/FlashCart</code> path with wherever your SD card is mounted:</p> <pre><code>igir copy extract test clean \\\n  --dat \"No-Intro*.zip\" \\\n  --input \"ROMs-Sorted/Nintendo - Game Boy\" \\\n  --output /media/FlashCart/ \\\n  --dir-letter \\\n  --no-bios \\\n  --single \\\n  --prefer-language EN \\\n  --prefer-region USA,WORLD,EUR,JPN\n</code></pre> <p>Your flash cart might then look something like this:</p> <pre><code>/Volumes/FlashCart\n\u2514\u2500\u2500 P\n    \u251c\u2500\u2500 Pokemon - Blue Version (USA, Europe) (SGB Enhanced).gb\n    \u251c\u2500\u2500 Pokemon - Red Version (USA, Europe) (SGB Enhanced).gb\n    \u2514\u2500\u2500 Pokemon - Yellow Version - Special Pikachu Edition (USA, Europe) (CGB+SGB Enhanced).gb\n</code></pre>"}, {"location": "usage/basic/#without-dats", "title": "Without DATs", "text": "<p>ROM organization is very opinion-based, and your opinion may not match that of DAT groups. To preserve your custom ROM sorting, you can skip providing any DATs by omitting the <code>--dat &lt;path&gt;</code> option.</p> <p>Note</p> <p>If your custom ROM sorting includes directories, you will want to provide the <code>--dir-mirror</code> option to preserve the structure.</p>"}, {"location": "usage/basic/#extracting-or-zipping-all-roms", "title": "Extracting or zipping all ROMs", "text": "<p>It is possible to extract or zip your ROM files en masse without complicated Bash or Batch scripts, and you can do this without DATs because the root of the filename won't change.</p>  Windows macOS Linux <pre><code>igir move extract test ^\n  --input \"ROMs\\\" ^\n  --output \"ROMs\\\" ^\n  --dir-mirror\n</code></pre> <pre><code>igir move extract test \\\n  --input \"ROMs/\" \\\n  --output \"ROMs/\" \\\n  --dir-mirror\n</code></pre> <pre><code>igir move extract test \\\n  --input \"ROMs/\" \\\n  --output \"ROMs/\" \\\n  --dir-mirror\n</code></pre>"}, {"location": "usage/basic/#fixing-file-extensions", "title": "Fixing file extensions", "text": "<p>Igir is able to detect more than 60 ROM and archive file types and automatically correct file extensions when needed during writing. See the writing options page for more information.</p>  Windows macOS Linux <pre><code>igir move extract test ^\n  --input \"ROMs\\\" ^\n  --output \"ROMs\\\" ^\n  --dir-mirror ^\n  --fix-extension always\n</code></pre> <pre><code>igir move extract test \\\n  --input \"ROMs/\" \\\n  --output \"ROMs/\" \\\n  --dir-mirror \\\n  --fix-extension always\n</code></pre> <pre><code>igir move extract test \\\n  --input \"ROMs/\" \\\n  --output \"ROMs/\" \\\n  --dir-mirror \\\n  --fix-extension always\n</code></pre>"}, {"location": "usage/best-practices/", "title": "Best Practices", "text": "<p>Use an installation method that auto-updates.</p> <p>Downloading bundled binaries from GitHub is the most difficult way to receive updates to Igir. See the installation page for options available to you.</p>"}, {"location": "usage/best-practices/#dats", "title": "DATs", "text": "<p>Use DATs.</p> <p>While DATs are optional, they allow you to organize your ROMs in a human-understandable manner while trimming out unknown files. Additional metadata provided by some DAT groups allows you filter your ROM set to only what you care about.</p> <p>Choose DAT groups with parent/clone information.</p> <p>Parent/clone information lets you apply 1G1R preference rules. For example, prefer No-Intro's Game Boy DAT over TOSEC's, as TOSEC doesn't provide parent/clone information.</p> <p>Use consistent versions across all devices.</p> <p>DATs work best if you store them alongside your primary ROM collection and when you use the same DAT versions across all devices (i.e. your primary collection, handhelds, flash carts, etc.). Some DAT groups release new versions as often as daily, so keeping your collection in sync is easier with consistent DATs.</p> <p>Process DATs from different groups separately.</p> <p>DAT groups have some overlap between them, so using DATs from multiple groups at the same time may cause duplicate files or filename collisions. Different groups also have different conventions that may require different settings, such as filters and 1G1R preferences.</p> <p>Also, keep ROM sets organized by DATs from different groups in separate directories. For example, create different directories for No-Intro, Redump, and TOSEC-organized ROM sets.</p>"}, {"location": "usage/best-practices/#file-inputs", "title": "File Inputs", "text": "<p>Keep one primary collection and then copy to other sub-collections.</p> <p>Provide your output directory as one of the input directories, and then any other input directories you wish to copy or move into your primary collection. Doing so will let you clean the output directory safely.</p> <p>Then, create sub-collections by copying files from your main collection to other devices, optionally applying filtering and preference rules.</p> <p>Provide the output directory as an input directory when moving or cleaning.</p> <p>This is because the <code>igir clean</code> command won't delete file paths considered for writing (no matter if a file was actually written, or it was ignored because of overwriting rules). Providing the output directory as an input directory will ensure no DAT-matched files are deleted.</p> <p>Example:</p>  Windows macOS Linux <pre><code>igir move clean ^\n  --input ROMs\\ ^\n  --input \"%UserProfile%\\Downloads\\\" ^\n  --output ROMs\\\n</code></pre> <pre><code>igir move clean \\\n  --input ROMs/ \\\n  --input ~/Downloads/ \\\n  --output ROMs/\n</code></pre> <pre><code>igir move clean \\\n  --input ROMs/ \\\n  --input ~/Downloads/ \\\n  --output ROMs/\n</code></pre> <p>Prefer ROMs with headers.</p> <p>Igir can remove headers automatically when needed, but it cannot add them back. Keep ROMs with headers in your primary collection and then modify them when copying to other devices as needed.</p> <p>Don't use quick scanning unless you absolutely need it.</p> <p>The default settings for Igir will have the best chance for you to match input files to DATs. Using the <code>--input-checksum-quick</code> option will reduce those chances.</p> <p>Don't increase the minimum checksum level unless you absolutely need it.</p> <p>The default settings for Igir will cause accurate file matching for the gross majority of cases with the least amount of processing. Additionally, most archive formats only store CRC32 checksums, so forcing any others will greatly increase scanning time. Use the <code>--input-checksum-min &lt;algorithm&gt;</code> option with caution.</p>"}, {"location": "usage/best-practices/#file-outputs", "title": "File Outputs", "text": "<p>Zip ROMs whenever it makes sense.</p> <p>Zip files generally save file space and are faster to scan, at the expense of more time to create them. For collections that will be read from more often than written to, such as a primary collection, prefer to eat the cost of archiving files once with the <code>igir zip</code> command.</p> <p>Organize ROM sets by DAT name or description.</p> <p>Ignoring arcade ROM sets, one purpose of sorting your ROM collection using DATs is to organize them in some human-understandable manner. A common way to help with this is to group ROMs from the same console together using <code>--dir-dat-name</code> or <code>--dir-dat-description</code>.</p> <p>Alternatively, you can filter to only the DATs you want and then combine them and write the resulting ROMs to one directory.</p> <p>Organize ROMs by letter for non-keyboard &amp; mouse devices.</p> <p>Devices that only have a D-pad to browse through files can make ROM selection tedious. Use the <code>--dir-letter</code> option and its <code>--dir-letter-*</code> modifier options to make this easier with large collections.</p> <p>Use the default game name appending option.</p> <p>Igir will automatically group games with multiple ROMs together into their own subfolder. Leave this <code>--dir-game-subdir &lt;mode&gt;</code> option as the default unless you know what you're doing.</p> <p>Overwrite invalid files.</p> <p>If you value keeping a clean and accurate ROM collection, use the <code>--overwrite-invalid</code> option to overwrite files in the output directory that don't match what's expected with a \"valid\" file.</p>"}, {"location": "usage/best-practices/#arcade", "title": "Arcade", "text": "<p>Use the right DAT version for your emulator version.</p> <p>You must choose the right DAT for your emulator (e.g. MAME) and emulator version (e.g. MAME 0.258) or your ROMs may not work correctly. See the arcade ROM sets page for more information.</p> <p>For MAME, use the official DATs or ones from progetto-SNAPS.</p> <p>These DATs provide the most flexibility (i.e. can use any merge type) and the most amount of metadata (i.e. parent/clone information, ROMs &amp; CHDs together in one DAT) for Igir to use for processing. Other DAT groups such as pleasuredome modify the official DATs quite heavily by pre-applying filters.</p> <p>Pick a ROM merge type intentionally.</p> <p>Igir will produce full non-merged sets by default for the highest level of compatability. However, you should understand the difference between the supported merge types and choose one that best suits your needs.</p>"}, {"location": "usage/best-practices/#advanced", "title": "Advanced", "text": "<p>Use an SSD or a RAM drive for the temp directory.</p> <p>Igir sometimes needs to write files to a temporary directory, such as when extracting archives that it can't read natively. Using a fast hard drive for this directory can speed up processing.</p>"}, {"location": "usage/personal/", "title": "Maintainer's Usage Example", "text": "<p>Igir has many options available to fit almost any use case, but the number of options can be overwhelming. So that begs a question: how do I, the maintainer of Igir, use Igir in the real world?</p>"}, {"location": "usage/personal/#primary-rom-library", "title": "Primary ROM library", "text": "<p>I have a 4TiB external hard drive that I use as my source of truth where I store all of my DATs, ROMs, and patches. In general, I'm more interested in cartridge-based consoles for space-saving reasons, but I have some optical-based ROMs.</p> <p>The file tree in that hard drive looks like this:</p> <pre><code>/Volumes/WDPassport4\n\u251c\u2500\u2500 FBNeo\n\u2502   \u251c\u2500\u2500 Arcade\n\u2502   \u2514\u2500\u2500 Neogeo\n\u251c\u2500\u2500 No-Intro\n\u2502   \u251c\u2500\u2500 Nintendo - Game Boy\n\u2502   \u251c\u2500\u2500 Nintendo - Game Boy Advance\n\u2502   \u251c\u2500\u2500 Nintendo - Game Boy Advance (Multiboot)\n\u2502   \u251c\u2500\u2500 Nintendo - Game Boy Advance (Video)\n\u2502   \u251c\u2500\u2500 Nintendo - Game Boy Advance (e-Reader)\n\u2502   \u251c\u2500\u2500 Nintendo - Game Boy Color\n\u2502   \u2514\u2500\u2500 etc...\n\u251c\u2500\u2500 No-Intro Love Pack (PC XML) (2023-01-29).zip\n\u251c\u2500\u2500 Patches\n\u2502   \u251c\u2500\u2500 gb\n\u2502   \u251c\u2500\u2500 gba\n\u2502   \u251c\u2500\u2500 gbc\n\u2502   \u251c\u2500\u2500 genesis\n\u2502   \u2514\u2500\u2500 snes\n\u251c\u2500\u2500 Redump\n\u2502   \u251c\u2500\u2500 Microsoft - Xbox - BIOS Images\n\u2502   \u251c\u2500\u2500 Nintendo - GameCube\n\u2502   \u251c\u2500\u2500 Sony - PlayStation - BIOS Images\n\u2502   \u2514\u2500\u2500 Sony - PlayStation 2 - BIOS Images\n\u251c\u2500\u2500 Redump (2023-01-29).zip\n\u251c\u2500\u2500 TOSEC - DAT Pack - Complete (3530) (TOSEC-v2022-07-10).zip\n\u2514\u2500\u2500 igir_library_sync.sh\n</code></pre> <p>The root directory has a DAT zip and subdirectory for each DAT release group. This helps separate differing quality of DATs and different DAT group ROM naming schemes. I then have one subdirectory for each game console, using the <code>--dir-dat-name</code> option.</p> <p>The <code>igir_library_sync.sh</code> script helps me keep this collection organized and merge new ROMs into it. The complete source is:</p> <pre><code>#!/usr/bin/env bash\n# @param {...string} $@ Input directories to merge into this collection\nset -euo pipefail\n\n# shellcheck disable=SC2064\ntrap \"cd \\\"${PWD}\\\"\" EXIT\ncd \"$(dirname \"$0\")\"\n\n\n# Treat every CLI argument as an input directory\nINPUTS=()\nfor INPUT in \"$@\"; do\n  INPUTS+=(--input \"${INPUT}\")\ndone\n\n# Cartridge-based consoles, 1st-5th generations\nnpx --yes igir@latest move zip test clean report \\\n  --dat \"./No-Intro*.zip\" \\\n  --dat-name-regex-exclude \"/encrypted|source code/i\" \\\n  --input \"./No-Intro/\" \\\n  \"${INPUTS[@]:-}\" \\\n  `# Trust checksums in archive headers, don't checksum archives (we only care about the contents)` \\\n  --input-checksum-max CRC32 \\\n  --input-checksum-archives never \\\n  --patch \"./Patches/\" \\\n  --output \"./No-Intro/\" \\\n  --dir-dat-name \\\n  --overwrite-invalid \\\n  --zip-exclude \"*.{chd,iso}\" \\\n  --reader-threads 4 \\\n  -v\n\n# Disc-based consoles, 4th+ generations\nnpx --yes igir@latest move test clean report \\\n  --dat \"./Redump*.zip\" \\\n  --input \"./Redump/\" \\\n  \"${INPUTS[@]}\" \\\n  `# Let maxcso calculate CSO CRC32s, don't checksum compressed discs (we only care about the contents)` \\\n  --input-checksum-max CRC32 \\\n  --input-checksum-archives never \\\n  --patch \"./Patches/\" \\\n  --output \"./Redump/\" \\\n  --dir-dat-name \\\n  --overwrite-invalid \\\n  --only-retail \\\n  --single \\\n  --prefer-language EN \\\n  --prefer-region USA,WORLD,EUR,JPN \\\n  --prefer-revision newer \\\n  -v\n\nnpx --yes igir@latest move zip test clean \\\n  `# Official MAME XML extracted from the progetto-SNAPS archive` \\\n  --dat \"./mame*.xml\" \\\n  `# Rollback DAT downloaded from Pleasuredome` \\\n  --dat \"./MAME*Rollback*.zip\" \\\n  --input \"./MAME/\" \\\n  \"${INPUTS[@]}\" \\\n  --input-checksum-quick \\\n  --input-checksum-archives never \\\n  --output \"./MAME/\" \\\n  --dir-dat-name \\\n  --overwrite-invalid \\\n  --merge-roms merged \\\n  -v\n</code></pre> <p>I then copy ROMs to other devices from this source of truth.</p>"}, {"location": "usage/personal/#analogue-pocket", "title": "Analogue Pocket", "text": "<p>Note</p> <p>See the full Analogue Pocket page for more detailed information.</p> <p>I have this script <code>igir_pocket_sync.sh</code> at the root of my Analogue Pocket's SD card:</p> <pre><code>#!/usr/bin/env bash\nset -euo pipefail\n\n# shellcheck disable=SC2064\ntrap \"cd \\\"${PWD}\\\"\" EXIT\ncd \"$(dirname \"$0\")\"\n\n\nSOURCE=/Volumes/WDPassport4\n\nnpx igir@latest copy extract test clean \\\n  --dat \"${SOURCE}/No-Intro*.zip\" \\\n  --dat-name-regex-exclude \"/headerless|OSTs/i\" \\\n  --input \"${SOURCE}/No-Intro/\" \\\n  --input-exclude \"${SOURCE}/No-Intro/Atari - 7800 (BIN)/\" \\\n  --input-exclude \"${SOURCE}/No-Intro/Commodore - Amiga*/**\" \\\n  --input-exclude \"${SOURCE}/No-Intro/Nintendo - Nintendo - Family Computer Disk System (QD)/\" \\\n  --input-exclude \"${SOURCE}/No-Intro/Nintendo - Game Boy Advance (e-Reader)/\" \\\n  --input-checksum-quick \\\n  --patch \"${SOURCE}/Patches/\" \\\n  --output \"./Assets/{pocket}/common/\" \\\n  --dir-letter \\\n  --dir-letter-limit 1000 \\\n  `# Leave BIOS files alone` \\\n  --clean-exclude \"./Assets/*/common/*.*\" \\\n  --clean-exclude \"./Assets/*/common/Palettes/**\" \\\n  --overwrite-invalid \\\n  --no-bios \\\n  --no-bad \\\n  --single \\\n  --prefer-language EN \\\n  --prefer-region USA,WORLD,EUR,JPN \\\n  --prefer-revision newer \\\n  --prefer-retail \\\n  -v\n</code></pre> <p>That lets me create an EN+USA preferred 1G1R set for my Pocket on the fly, making sure I don't delete BIOS files needed for each core.</p>"}, {"location": "usage/personal/#gamecube", "title": "GameCube", "text": "<p>Note</p> <p>See the full GameCube page for more detailed information.</p> <p>I have this script <code>sd2sp2_pocket_sync.sh</code> at the root of my GameCube SD2SP2 SD card:</p> <pre><code>#!/usr/bin/env bash\nset -euo pipefail\n\n# shellcheck disable=SC2064\ntrap \"cd \\\"${PWD}\\\"\" EXIT\ncd \"$(dirname \"$0\")\"\n\n\nSOURCE=/Volumes/WDPassport4\n\nnpx --yes igir@latest copy test clean report \\\n  --dat \"${SOURCE}/Redump*.zip\" \\\n  --dat-name-regex \"/GameCube/i\" \\\n  --input \"${SOURCE}/Redump/Nintendo - GameCube\" \\\n  --input-checksum-quick \\\n  --input-checksum-archives never \\\n  --patch \"${SOURCE}/Patches\" \\\n  --output \"./Games/\" \\\n  --dir-letter \\\n  --overwrite-invalid \\\n  --filter-regex-exclude \"/(Angler|Baseball|Basketball|Bass|Bonus Disc|Cabela|Disney|ESPN|F1|FIFA|Football|Golf|Madden|MLB|MLS|NASCAR|NBA|NCAA|NFL|NHL|Nickelodeon|Nick Jr|Nicktoons|PGA|Poker|Soccer|Tennis|Tonka|UFC|WWE)/i\" \\\n  --no-bios \\\n  --only-retail \\\n  --single \\\n  --prefer-language EN \\\n  --prefer-region USA,WORLD,EUR,JPN \\\n  --prefer-revision newer \\\n  --writer-threads 1 \\\n  -v\n</code></pre> <p>I use the trimmed NKit format for ISOs, which don't make sense to extract, so they're copied as-is. I also exclude some games due to limited SD card size.</p>"}, {"location": "usage/console/gamecube/", "title": "GameCube", "text": ""}, {"location": "usage/console/gamecube/#swiss", "title": "Swiss", "text": "<p>Swiss is typically used to load game backups on the GameCube. See the GC-Forever Wiki for resources on installing &amp; running Swiss.</p> <p>Warning</p> <p>Swiss is sensitive to files being fragmented on SD cards (swiss-gc#763, swiss-gc#122, etc.). This means that you should only write one ISO at a time!</p> <p>Igir has a <code>--writer-threads &lt;threads&gt;</code> option to limit the number of files being written at once. You can use the option like this:</p>  Windows macOS Linux <p>Replace the <code>E:\\</code> drive letter with wherever your SD card is:</p> <pre><code>igir copy test clean ^\n  --dat \"Redump*.zip\" ^\n  --dat-name-regex '/gamecube/i' ^\n  --input \"Games\" ^\n  --output \"E:\\Games\" ^\n  --dir-letter ^\n  --writer-threads 1\n</code></pre> <p>Replace the <code>/Volumes/SD2SP2</code> drive name with whatever your SD card is named:</p> <pre><code>igir copy test clean \\\n  --dat \"Redump*.zip\" \\\n  --dat-name-regex '/gamecube/i' \\\n  --input \"Games/\" \\\n  --output \"/Volumes/SD2SP2/Games/\" \\\n  --dir-letter \\\n  --writer-threads 1\n</code></pre> <p>Replace the <code>/media/SD2SP2</code> path with wherever your SD card is mounted:</p> <pre><code>igir copy test clean \\\n  --dat \"Redump*.zip\" \\\n  --dat-name-regex '/gamecube/i' \\\n  --input \"Games/\" \\\n  --output \"/media/SD2SP2/Games/\" \\\n  --dir-letter \\\n  --writer-threads 1\n</code></pre>"}, {"location": "usage/console/gamecube/#nkit", "title": "NKit", "text": "<p>Swiss supports ISOs in the trimmed NKit format, which can save significant space on your SD card. Some games such as Animal Crossing can be compressed as small as 28MB, while other games such as Wave Race: Blue Storm don't compress much at all.</p> <p>Igir can read the original ISO's CRC32 information stored in <code>.nkit.iso</code> files, which means it can match files to DATs (as long as you don't raise the minimum checksum level!). However, Igir can't extract NKit ISOs, you'll need to use Nanook's NKit tool instead.</p>"}, {"location": "usage/console/ps2/", "title": "PlayStation 2", "text": ""}, {"location": "usage/console/ps2/#open-ps2-loader-opl", "title": "Open PS2 Loader (OPL)", "text": "<p>OPL is typically used to load game backups on the PS2. See the PS2-HOME Forums for resources on installing &amp; running OPL.</p> <p>Warning</p> <p>OPL is sensitive to files being fragmented on USB drives and SD cards (MX4SIO/SIO2SD). This means that you should only write one ISO at a time!</p> <p>Igir has a <code>--writer-threads &lt;threads&gt;</code> option to limit the number of files being written at once. You can use the option like this:</p>  Windows macOS Linux <p>Replace the <code>E:\\</code> drive letter with wherever your USB drive is:</p> <pre><code>igir copy extract test clean ^\n  --dat \"Redump*.zip\" ^\n  --dat-name-regex '/playstation 2/i' ^\n  --input \"ISOs\" ^\n  --output \"E:\\DVD\" ^\n  --dir-letter ^\n  --writer-threads 1\n</code></pre> <p>Replace the <code>/Volumes/PS2</code> drive name with whatever your USB drive is named:</p> <pre><code>igir copy extract test clean \\\n  --dat \"Redump*.zip\" \\\n  --dat-name-regex '/playstation 2/i' \\\n  --input \"ISOs/\" \\\n  --output \"/Volumes/PS2/DVD/\" \\\n  --dir-letter \\\n  --writer-threads 1\n</code></pre> <p>Replace the <code>/media/PS2</code> path with wherever your USB drive is mounted:</p> <pre><code>igir copy extract test clean \\\n  --dat \"Redump*.zip\" \\\n  --dat-name-regex '/playstation 2/i' \\\n  --input \"ISOs/\" \\\n  --output \"/media/PS2/DVD/\" \\\n  --dir-letter \\\n  --writer-threads 1\n</code></pre>"}, {"location": "usage/desktop/batocera/", "title": "Batocera", "text": "<p>Batocera is a pre-configured Linux distribution for EmulationStation &amp; RetroArch. Batocera is primarily for single-board computers (SBCs) such as the Raspberry Pi.</p>"}, {"location": "usage/desktop/batocera/#bios", "title": "BIOS", "text": "<p>Because Batocera uses RetroArch under the hood, the instructions are generally the same as RetroArch. By default, the Batocera BIOS directory is <code>/userdata/bios/</code>:</p>  Batocera (Linux) <p>You can copy BIOS files from a USB drive named \"USB-Drive\" like this:</p> <pre><code>igir copy extract test clean \\\n  --dat \"https://raw.githubusercontent.com/libretro/libretro-database/master/dat/System.dat\" \\\n  --input /media/USB-Drive/BIOS/ \\\n  --output /userdata/bios/\n</code></pre>"}, {"location": "usage/desktop/batocera/#roms", "title": "ROMs", "text": "<p>Batocera uses its own proprietary ROM folder structure, so Igir has a replaceable <code>{batocera}</code> token to sort ROMs into the right place. See the replaceable tokens page for more information.</p>  Batocera (Linux) <p>You can copy ROMs from a USB drive named \"USB-Drive\" like this:</p> <pre><code>igir copy zip test clean \\\n  --dat \"/media/USB-Drive/No-Intro*.zip\" \\\n  --input \"/media/USB-Drive/ROMs/\" \\\n  --output \"/userdata/roms/{batocera}\" \\\n  --dir-letter \\\n  --no-bios\n</code></pre>"}, {"location": "usage/desktop/emuelec/", "title": "EmuELEC", "text": "<p>EmuELEC is an OS for Amlogic devices (Android TV boxes, ODROID) based on CoreELEC, Lakka, and Batocera.</p>"}, {"location": "usage/desktop/emuelec/#bios", "title": "BIOS", "text": "<p>Because EmuELEC is mostly Libretro under the hood, the instructions are generally the same as RetroArch. By default, EmuELEC has its BIOS directory at <code>/storage/roms/bios/</code>:</p>  EmuELEC (Linux) <p>You can copy BIOS files from a USB drive named \"USB-Drive\" like this:</p> <pre><code>igir copy extract test clean \\\n  --dat \"https://raw.githubusercontent.com/libretro/libretro-database/master/dat/System.dat\" \\\n  --input /media/USB-Drive/BIOS/ \\\n  --output /storage/roms/bios/\n</code></pre>"}, {"location": "usage/desktop/emuelec/#roms", "title": "ROMs", "text": "<p>Failure</p> <p>EmuELEC uses its own proprietary ROM folder structure. Igir does not support this folder structure, yet.</p>"}, {"location": "usage/desktop/emulationstation/", "title": "EmulationStation", "text": ""}, {"location": "usage/desktop/emulationstation/#emulationstation-desktop-edition-es-de", "title": "EmulationStation Desktop Edition (ES-DE)", "text": "<p>EmulationStation is a frontend for RetroArch and many other standalone emulators.</p>"}, {"location": "usage/desktop/emulationstation/#bios", "title": "BIOS", "text": "<p>Because EmulationStation uses RetroArch under the hood, the instructions are generally the same as RetroArch. By default, the EmulationStation BIOS directory is <code>/userdata/bios/</code>:</p>  EmulationStation (Linux) <p>You can copy BIOS files from a USB drive named \"USB-Drive\" like this:</p> <pre><code>igir copy extract test clean \\\n  --dat \"https://raw.githubusercontent.com/libretro/libretro-database/master/dat/System.dat\" \\\n  --input /media/USB-Drive/BIOS/ \\\n  --output /userdata/bios/\n</code></pre> <p>Other emulators may use other names for their BIOS images but all reside in the same BIOS directory.</p>"}, {"location": "usage/desktop/emulationstation/#roms", "title": "ROMs", "text": "<p>EmulationStation uses its own proprietary ROM folder structure, so Igir has a replaceable <code>{es}</code> token to sort ROMs into the right place. See the replaceable tokens page for more information.</p>  EmulationStation (Linux) <p>You can copy ROMs from a USB drive named \"USB-Drive\" like this:</p> <pre><code>igir copy zip test clean \\\n  --dat \"/media/USB-Drive/No-Intro*.zip\" \\\n  --input \"/media/USB-Drive/ROMs/\" \\\n  --output \"/userdata/roms/{es}\" \\\n  --no-bios\n</code></pre>"}, {"location": "usage/desktop/lakka/", "title": "Lakka", "text": "<p>Lakka is a pre-configured Linux distribution based on LibreELEC that comes with RetroArch installed. Lakka is primarily for single-board computers (SBCs) such as the Raspberry Pi.</p>"}, {"location": "usage/desktop/lakka/#bios", "title": "BIOS", "text": "<p>Because Lakka uses RetroArch under the hood, the instructions are generally the same as RetroArch. By default, the Lakka BIOS directory is <code>/storage/system/</code>:</p>  Lakka (Linux) <p>You can copy ROMs from a USB drive named \"USB-Drive\" like this:</p> <pre><code>igir copy extract test clean \\\n  --dat \"https://raw.githubusercontent.com/libretro/libretro-database/master/dat/System.dat\" \\\n  --input /media/USB-Drive/BIOS/ \\\n  --output /storage/system\n</code></pre>"}, {"location": "usage/desktop/lakka/#roms", "title": "ROMs", "text": "<p>Lakka has a <code>roms</code> folder at <code>/storage/roms/</code> that is used by default:</p>  Lakka (Linux) <p>You can copy ROMs from a USB drive named \"USB-Drive\" like this:</p> <pre><code>igir copy zip test clean \\\n  --dat \"/media/USB-Drive/No-Intro*.zip\" \\\n  --input \"/media/USB-Drive/ROMs/\" \\\n  --output \"/storage/roms/\" \\\n  --dir-dat-name \\\n  --dir-letter \\\n  --no-bios\n</code></pre>"}, {"location": "usage/desktop/launchbox/", "title": "LaunchBox", "text": "<p>LaunchBox is a game launcher for Windows for both retro games and modern games.</p> <p>LaunchBox uses RetroArch for its game emulation by default, as of v12.2 (2021). RetroArch will be downloaded the first time you import a ROM from LaunchBox's UI.</p> <p>Failure</p> <p>LaunchBox has its own ROM importing mechanism that copies files to <code>\\Games\\*\\*</code> in your install directory (so <code>%USERPROFILE%\\LaunchBox\\Games\\*\\*</code> by default). There is a mechanism to scan for ROMs added to these folders manually, but they must be sorted into the correct \"platform\" folder. LaunchBox doesn't have documentation cataloging these \"platform\" folders, so Igir does not currently support them.</p>"}, {"location": "usage/desktop/openemu/", "title": "OpenEmu", "text": "<p>OpenEmu is a launcher for various emulators for macOS. It differs from many other desktop frontends in that it is not based off of RetroArch/Libretro.</p> <p>Failure</p> <p>OpenEmu has its own ROM importing mechanism that copies files to <code>~/Library/Application Support/OpenEmu/Game Library/roms</code> and adds them to a database. OpenEmu will not automatically scan files you place into this folder, so Igir is unable to help sort them.</p>"}, {"location": "usage/desktop/recalbox/", "title": "Recalbox", "text": "<p>Recalbox is a pre-configured Linux distribution for EmulationStation &amp; RetroArch.</p>"}, {"location": "usage/desktop/recalbox/#bios", "title": "BIOS", "text": "<p>Because Recalbox uses RetroArch under the hood, the instructions are generally the same as RetroArch. By default, the Recalbox BIOS directory is <code>/recalbox/share/bios/</code>:</p>  Recalbox (Linux) <p>You can copy ROMs from a USB drive named \"USB-Drive\" like this:</p> <pre><code>igir copy extract test clean \\\n  --dat \"https://raw.githubusercontent.com/libretro/libretro-database/master/dat/System.dat\" \\\n  --input /media/USB-Drive/BIOS/ \\\n  --output /recalbox/share/bios\n</code></pre>"}, {"location": "usage/desktop/recalbox/#roms", "title": "ROMs", "text": "<p>Recalbox has a <code>roms</code> folder at <code>/recalbox/share/roms/</code> that is used by default:</p>  Recalbox (Linux) <p>You can copy ROMs from a USB drive named \"USB-Drive\" like this:</p> <pre><code>igir copy zip test clean \\\n  --dat \"/media/USB-Drive/No-Intro*.zip\" \\\n  --input \"/media/USB-Drive/ROMs/\" \\\n  --output \"/recalbox/share/roms/\" \\\n  --dir-dat-name \\\n  --dir-letter \\\n  --no-bios\n</code></pre>"}, {"location": "usage/desktop/retroarch/", "title": "RetroArch", "text": "<p>RetroArch is a frontend UI for the Libretro API.</p> <p>Note</p> <p>RetroArch is available for a number of devices, including smartphones and consoles. These instructions will only work on desktop OSes, but once your files are organized you can copy them over to your other device.</p>"}, {"location": "usage/desktop/retroarch/#bios", "title": "BIOS", "text": "<p>First, RetroArch needs a number of BIOS files. Thankfully, the libretro team maintains a DAT of these \"system\" files, so we don't have to guess at the correct filenames.</p> <p>With Igir's support for DAT URLs we don't even have to download the DAT! Locate your \"System/BIOS\" directory as configured in the RetroArch UI and use it as your output directory:</p>  Windows (64-bit) Windows (32-bit) macOS Linux <p>The root directory is based on where you installed RetroArch, but by default it is:</p> <pre><code>igir copy extract test clean ^\n  --dat \"https://raw.githubusercontent.com/libretro/libretro-database/master/dat/System.dat\" ^\n  --input BIOS/ ^\n  --output C:\\RetroArch-Win64\\system\n</code></pre> <p>The root directory is based on where you installed RetroArch, but by default it is:</p> <pre><code>igir copy extract test clean ^\n  --dat \"https://raw.githubusercontent.com/libretro/libretro-database/master/dat/System.dat\" ^\n  --input BIOS/ ^\n  --output C:\\RetroArch-Win32\\system\n</code></pre> <pre><code>igir copy extract test clean \\\n  --dat \"https://raw.githubusercontent.com/libretro/libretro-database/master/dat/System.dat\" \\\n  --input BIOS/ \\\n  --output ~/Documents/RetroArch/system/\n</code></pre> <pre><code>igir copy extract test clean \\\n  --dat \"https://raw.githubusercontent.com/libretro/libretro-database/master/dat/System.dat\" \\\n  --input BIOS/ \\\n  --output ~/Documents/RetroArch/system/\n</code></pre>"}, {"location": "usage/desktop/retroarch/#roms", "title": "ROMs", "text": "<p>RetroArch is less opinionated about where your ROMs can live, you have to specify \"content\" directories during setup in the RetroArch UI.</p> <p>If you want to store your ROMs in the RetroArch folder, you could co-locate them near your BIOS files:</p>  Windows (64-bit) Windows (32-bit) macOS Linux <p>The root directory is based on where you installed RetroArch, but by default it is:</p> <pre><code>igir copy zip test ^\n  --dat \"No-Intro*.zip\" ^\n  --input ROMs\\ ^\n  --output C:\\RetroArch-Win64\\roms ^\n  --dir-dat-name ^\n  --no-bios\n</code></pre> <p>The root directory is based on where you installed RetroArch, but by default it is:</p> <pre><code>igir copy zip test ^\n  --dat \"No-Intro*.zip\" ^\n  --input ROMs\\ ^\n  --output C:\\RetroArch-Win32\\roms ^\n  --dir-dat-name ^\n  --no-bios\n</code></pre> <pre><code>igir copy zip test \\\n  --dat \"No-Intro*.zip\" \\\n  --input ROMs/ \\\n  --output ~/Documents/RetroArch/roms \\\n  --dir-dat-name \\\n  --no-bios\n</code></pre> <pre><code>igir copy zip test \\\n  --dat \"No-Intro*.zip\" \\\n  --input ROMs/ \\\n  --output ~/Documents/RetroArch/roms \\\n  --dir-dat-name \\\n  --no-bios\n</code></pre> <p>From there, all you should have to do is \"import content\" in the RetroArch UI.</p>"}, {"location": "usage/desktop/retrodeck/", "title": "RetroDECK", "text": "<p>RetroDECK is a self contained application package that uses EmulationStation as a frontend for RetroArch and many other standalone emulators. It is primarily designed and optimised for the Steam Deck.</p>"}, {"location": "usage/desktop/retrodeck/#bios", "title": "BIOS", "text": "<p>Because RetroDECK uses RetroArch under the hood, the instructions are generally the same as RetroArch. By default, the RetroDECK BIOS directory is <code>/userdata/bios/</code>:</p>  RetroDECK (Linux) <p>You can copy BIOS files from a USB drive named \"USB-Drive\" like this:</p> <pre><code>igir copy extract test clean \\\n  --dat \"https://raw.githubusercontent.com/libretro/libretro-database/master/dat/System.dat\" \\\n  --input /media/USB-Drive/BIOS/ \\\n  --output /userdata/bios/\n</code></pre> <p>Other emulators may use other names for their BIOS images but all reside in the same BIOS directory. RetroDECK has a convenient tool that handles BIOS checks in the bundled RetroDECK Configuration app.</p>"}, {"location": "usage/desktop/retrodeck/#roms", "title": "ROMs", "text": "<p>RetroDECK uses its own proprietary ROM folder structure, so Igir has a replaceable <code>{retrodeck}</code> token to sort ROMs into the right place. See the replaceable tokens page for more information.</p>  RetroDECK (Linux) <p>You can copy ROMs from a USB drive named \"USB-Drive\" like this:</p> <pre><code>igir copy zip test clean \\\n  --dat \"/media/USB-Drive/No-Intro*.zip\" \\\n  --input \"/media/USB-Drive/ROMs/\" \\\n  --output \"/userdata/roms/{retrodeck}\" \\\n  --no-bios\n</code></pre>"}, {"location": "usage/desktop/retropie/", "title": "RetroPie", "text": "<p>RetroPie is an installer for EmulationStation &amp; RetroArch on single-board computers (SBCs) such as the Raspberry Pi.</p>"}, {"location": "usage/desktop/retropie/#bios", "title": "BIOS", "text": "<p>Because RetroPie uses RetroArch under the hood, the instructions are generally the same as RetroArch. By default, the RetroPie BIOS directory is <code>/home/pi/RetroPie/BIOS/</code>:</p>  RetroPie (Linux) <pre><code>igir copy extract test clean \\\n  --dat \"https://raw.githubusercontent.com/libretro/libretro-database/master/dat/System.dat\" \\\n  --input BIOS/ \\\n  --output /home/pi/RetroPie/BIOS\n</code></pre>"}, {"location": "usage/desktop/retropie/#roms", "title": "ROMs", "text": "<p>The RetroPie docs recommend creating a <code>retropie/roms</code> directory at the root of a USB drive. You can then load up this USB drive with your ROMs from a different computer:</p>  Windows macOS Linux <p>Replace the <code>E:\\</code> drive letter with wherever your SD card is:</p> <pre><code>igir copy zip test clean ^\n  --dat \"No-Intro*.zip\" ^\n  --input \"ROMs\" ^\n  --output \"E:\\retropie\\roms\" ^\n  --dir-dat-name ^\n  --dir-letter ^\n  --no-bios\n</code></pre> <p>Replace the <code>/Volumes/RETROPIE</code> drive name with whatever your SD card is named:</p> <pre><code>igir copy zip test clean \\\n  --dat \"No-Intro*.zip\" \\\n  --input \"ROMs/\" \\\n  --output \"/Volumes/RETROPIE/retropie/roms/\" \\\n  --dir-dat-name \\\n  --dir-letter \\\n  --no-bios\n</code></pre> <p>Replace the <code>/media/RETROPIE</code> path with wherever your SD card is mounted:</p> <pre><code>igir copy zip test clean \\\n  --dat \"No-Intro*.zip\" \\\n  --input \"ROMs/\" \\\n  --output \"/media/RETROPIE/retropie/roms/\" \\\n  --dir-dat-name \\\n  --dir-letter \\\n  --no-bios\n</code></pre>"}, {"location": "usage/desktop/romm/", "title": "RomM", "text": "<p>RomM is a web-based ROM management solution that allows you to scan, enrich, and browse your game collection with a clean and responsive interface. With support for multiple platforms, various naming schemes, and custom tags, RomM is a must-have for anyone who plays on emulators.</p>"}, {"location": "usage/desktop/romm/#roms", "title": "ROMs", "text": "<p>RomM uses its own proprietary ROM folder structure, so Igir has a replaceable <code>{romm}</code> token to sort ROMs into the right place. See the replaceable tokens page for more information.</p> <p>You can run RomM using Docker Compose. Create a file named <code>docker-compose.yml</code> with the following contents, but change all of the environment variables with the value of <code>CHANGEME!</code>:</p> <pre><code>version: \"3\"\n\n# https://github.com/rommapp/romm/blob/997d2cacd4b1980484eb63c2b3ffe65c83133966/examples/docker-compose.example.yml\nservices:\n  romm:\n    image: rommapp/romm\n    container_name: romm\n    restart: unless-stopped\n    environment:\n      - DB_HOST=romm-db\n      - DB_NAME=romm\n      - DB_USER=romm\n      - DB_PASSWD=CHANGEME!\n      - ENABLE_RESCAN_ON_FILESYSTEM_CHANGE=true\n      - ENABLE_SCHEDULED_RESCAN=true\n      - IGDB_CLIENT_ID=CHANGEME!\n      - IGDB_CLIENT_SECRET=CHANGEME!\n      - ROMM_AUTH_SECRET_KEY=CHANGEME!\n      - ROMM_AUTH_USERNAME=admin\n      - ROMM_AUTH_PASSWORD=CHANGEME!\n    volumes:\n      - ./romm/assets:/romm/assets\n      - ./romm/config:/romm/config\n      - ./romm/logs:/romm/logs\n      - ./romm/redis:/redis-data\n      - ./romm/resources:/romm/resources\n      - ./romm/roms:/romm/library/roms\n    ports:\n      - 80:8080\n    depends_on:\n      - romm-db\n  romm-db:\n    image: mariadb:latest\n    container_name: romm-mariadb\n    restart: unless-stopped\n    environment:\n      - MARIADB_RANDOM_ROOT_PASSWORD=true\n      - MARIADB_DATABASE=romm\n      - MARIADB_USER=romm\n      - MARIADB_PASSWORD=CHANGEME!\n    expose:\n      - 3306\n    volumes:\n      - ./romm-db:/var/lib/mysql\n</code></pre> <p>then, run Docker Compose as you would with any other config:</p> <pre><code>docker compose up\n</code></pre> <p>This will create all of the local directories necessary. On your host machine (not from inside the container) you can sort your ROMs into the correct directories like this:</p>  Windows macOS Linux <pre><code>igir copy zip test clean ^\n  --dat \"No-Intro*.zip\" ^\n  --input \"ROMs\\\" ^\n  --output \"romm\\roms\\{romm}\"\n</code></pre> <pre><code>igir copy zip test clean \\\n  --dat \"No-Intro*.zip\" \\\n  --input \"ROMs/\" \\\n  --output \"romm/roms/{romm}\"\n</code></pre> <pre><code>igir copy zip test clean \\\n  --dat \"No-Intro*.zip\" \\\n  --input \"ROMs/\" \\\n  --output \"romm/roms/{romm}\"\n</code></pre>"}, {"location": "usage/handheld/adam/", "title": "The 'Adam' image", "text": "<p>Adam (Code) is a custom firmware Ingenic JZ4770 chip-based portable emulation consoles. Specifically GCW-Zero, PocketGo2 v1/v2, Anbernic RG350, RG280 and RG300X. It is based on OpenDingux and the SimpleMenu frontend. While it is intended for the named less powerful handhelds, it packs a good and wide selection of emulators. The distribution defines it's own set of ROM folders (via SimpleMenu), so it makes use of it's own output token in igir.</p>"}, {"location": "usage/handheld/adam/#preparing-tf2", "title": "Preparing TF2", "text": "<p>When creating your own microSD card for your system, the documentation of the Adam image requires you to do the following:</p> <ul> <li>format the card using FAT32</li> <li>make sure the filesystem doesn't have a label</li> <li>insert the formatted blank card into your system and boot it up. The boot process will create the basic directory structure</li> <li>shut down the handheld</li> <li>use your computer to put BIOS and ROM files on your card</li> </ul> <p>This ensures that the card already has the correct folder structures and is recognized by your handheld properly.</p>"}, {"location": "usage/handheld/adam/#bios-files", "title": "BIOS Files", "text": "<p>The Adam image does not come with BIOS files. Where you have to put which of your own BIOS files is documented in the image's wiki. Most of the BIOS files have to be stored in the <code>BIOS</code> subfolder of the second SD card (TF2) and the libretro System.dat can be used to put them there</p>  Windows macOS Linux <p>Replace the <code>E:\\</code> drive letter with wherever your SD card is:</p> <pre><code>igir copy extract test clean ^\n  --dat \"https://raw.githubusercontent.com/libretro/libretro-database/master/dat/System.dat\" ^\n  --input BIOS\\ ^\n  --output E:\\BIOS\n</code></pre> <p>Replace the <code>/Volumes/JELOS</code> drive name with whatever your SD card is named:</p> <pre><code>igir copy extract test clean \\\n  --dat \"https://raw.githubusercontent.com/libretro/libretro-database/master/dat/System.dat\" \\\n  --input BIOS/ \\\n  --output /Volumes/ADAM/BIOS\n</code></pre> <p>Replace the <code>/media/JELOS</code> path with wherever your SD card is mounted:</p> <pre><code>igir copy extract test clean \\\n  --dat \"https://raw.githubusercontent.com/libretro/libretro-database/master/dat/System.dat\" \\\n  --input BIOS/ \\\n  --output /media/ADAM/BIOS/\n</code></pre>"}, {"location": "usage/handheld/adam/#roms", "title": "ROMs", "text": "<p>Adam supports many different ROM formats in subfolders of <code>ROMS</code> on the second SD card (TF2). An exhaustive list can be found in their wiki, where you can also find information about which ROMS are supported in compressed form. Most supported systems and their ROMS can be automatically sorted by Igir using the <code>{adam}</code> output token. See the replaceable tokens page for more information.</p> <p>Tip</p> <p>Please note that sorting the supported Arcade machine releases (MAME, CPS, FBA) in a single pass is not supported by Igir at this time. Try the Arcade docs docs for help with this.</p>  Windows macOS Linux <p>Replace the <code>E:\\</code> drive letter with wherever your SD card is:</p> <pre><code>igir copy extract test clean ^\n  --dat \"No-Intro*.zip\" ^\n  --input ROMs\\ ^\n  --output \"E:\\ROMS\\{adam}\" ^\n  --dir-letter ^\n  --no-bios\n</code></pre> <p>Replace the <code>/Volumes/ADAM</code> drive name with whatever your SD card is named:</p> <pre><code>igir copy extract test clean \\\n  --dat \"No-Intro*.zip\" \\\n  --input ROMs/ \\\n  --output \"/Volumes/ADAM/ROMS/{adam}\" \\\n  --dir-letter \\\n  --no-bios\n</code></pre> <p>Replace the <code>/media/ADAM</code> path with wherever your SD card is mounted:</p> <pre><code>igir copy extract test clean \\\n  --dat \"No-Intro*.zip\" \\\n  --input ROMs/ \\\n  --output \"/media/ADAM/ROMS/{adam}\" \\\n  --dir-letter \\\n  --no-bios\n</code></pre>"}, {"location": "usage/handheld/funkeyos/", "title": "FunKey OS", "text": "<p>Info</p> <p>FunKey OS is a Retro Emulation OS for the FunKey S handheld. It is also used on the Anbernic RG Nano. It is not very well documented which consoles are supported on which device. The <code>funkeyos</code> tag should handle systems supported by either of those handhelds.</p> <p>FunKey OS is a minimalistic buildroot based Linux distribution originally designed for the tiny ARM based FunKey S handheld. It is also used on the Anbernic RG Nano with a few modifications.</p>"}, {"location": "usage/handheld/funkeyos/#bios", "title": "BIOS", "text": "<p>FunKey OS ships with most emulators not needing BIOS files. Two notable exceptions are the GBA BIOS as well as the PS1 BIOS. These can be installed manually. Only two files are needed, so automating the task might be more work than copying them across.</p> <p>To sum up the documentation, two files need to be copied:</p> <ul> <li><code>gba_bios.bin</code> (MD5 hash <code>a860e8c0b6d573d191e4ec7db1b1e4f6</code>) to <code>&lt;sdcard&gt;/Game Boy Advance</code> for the GBA BIOS</li> <li><code>SCPH1001.BIN</code> (512kib in size) to <code>&lt;sdcard&gt;/PS1</code> of the card for the PS1 BIOS</li> </ul>"}, {"location": "usage/handheld/funkeyos/#roms", "title": "ROMs", "text": "<p>Funkey OS uses its own proprietary ROM folder structure based in the root of the SD card, so Igir has a replaceable <code>{funkeyos}</code> token to sort ROMs into the right place. See the replaceable tokens page for more information.</p>  Windows macOS Linux <p>Replace the <code>E:\\</code> drive letter with wherever your SD card is:</p> <pre><code>igir copy extract test clean ^\n  --dat \"No-Intro*.zip\" ^\n  --input ROMs\\ ^\n  --output \"E:\\{funkeyos}\" ^\n  --dir-letter ^\n  --no-bios\n</code></pre> <p>Replace the <code>/Volumes/FunKeyS</code> drive name with whatever your SD card is named:</p> <pre><code>igir copy extract test clean \\\n  --dat \"No-Intro*.zip\" \\\n  --input ROMs/ \\\n  --output \"/Volumes/FunKeyS/{funkeyos}\" \\\n  --dir-letter \\\n  --no-bios\n</code></pre> <p>Replace the <code>/media/FunKeyS</code> path with wherever your SD card is mounted:</p> <pre><code>igir copy extract test clean \\\n  --dat \"No-Intro*.zip\" \\\n  --input ROMs/ \\\n  --output \"/media/FunKeyS/{funkeyos}\" \\\n  --dir-letter \\\n  --no-bios\n</code></pre>"}, {"location": "usage/handheld/jelos/", "title": "JELOS", "text": "<p>Info</p> <p>JELOS is based on RetroArch and EmulationStation. If the instructions on this page don't lead to success on your device, you might want to try your luck with their documentation.</p> <p>JELOS (or Just Enough Linux OS) is a slim open source operating system for many devices by Anbernic, Powkiddy, Hardkernel etc. While it supports many devices as an aftermarket operating system choice, vendors have started shipping their devices with JELOS, too. With powerful features like custom collections and online scraping, it can make good use of huge and well managed ROM collections.</p>"}, {"location": "usage/handheld/jelos/#different-card-setups", "title": "Different card setups", "text": ""}, {"location": "usage/handheld/jelos/#os-card-rom-card", "title": "OS card, ROM card", "text": "<p>JELOS can be installed on single SD card devices as well as devices using a secondary SD card for games. In normal operation, the external SD card will be mounted under <code>/roms</code>. Please keep that in mind and adapt accordingly when following these instructions.</p> <p>We will assume the single card variant here. If you use a card just for roms, please remove the <code>roms/</code> path component when writing to your SD card as follows:</p> Component single SD card (OS+ROMs) separate SD card (ROMs only) BIOS <code>&lt;SD&gt;/roms/bios/</code> <code>&lt;SD&gt;/bios/</code> Game Boy ROMs <code>&lt;SD&gt;/roms/gb</code> <code>&lt;SD&gt;/gb</code> ... <p>The OS can also be installed on other media than SD cards. Still we will call them OS SD card and ROM SD card.</p>"}, {"location": "usage/handheld/jelos/#filesystems", "title": "Filesystems", "text": "<p>JELOS, being a Linux distribution, runs from a Linux filesystem. most Linux filesystems can not be read from or written to natively using Windows or macOS. When using a single SD card setup, you might need to access partitions of the card using a Linux filesystem (probably <code>ext4</code>). This is easiest using the Network functions of JELOS via Wifi, another system running the Linux operating system or special software.</p> <p>When using a separate card for ROMs and OS, the ROMs are most likely stored in a <code>FAT32</code> filesystem which can be accessed using either Windows, macOS or Linux natively.</p> <p>Please note that while <code>FAT32</code> is not case sensitive in most cases, <code>ext4</code> and many other filesystems are. Keep that in mind while copying.</p>"}, {"location": "usage/handheld/jelos/#bios", "title": "BIOS", "text": "<p>JELOS has its BIOS folder at <code>roms/bios/</code>, and it uses the RetroArch filenames. Most of the BIOS files should be found using the following guides. Check the many sections under the <code>Systems</code> menu in the JELOS Wiki for more precise instructions when you run into trouble.</p>  Windows macOS Linux <p>Replace the <code>E:\\</code> drive letter with wherever your SD card is:</p> <pre><code>igir copy extract test clean ^\n  --dat \"https://raw.githubusercontent.com/libretro/libretro-database/master/dat/System.dat\" ^\n  --input BIOS\\ ^\n  --output E:\\roms\\bios\n</code></pre> <p>Replace the <code>/Volumes/JELOS</code> drive name with whatever your SD card is named:</p> <pre><code>igir copy extract test clean \\\n  --dat \"https://raw.githubusercontent.com/libretro/libretro-database/master/dat/System.dat\" \\\n  --input BIOS/ \\\n  --output /Volumes/JELOS/roms/bios\n</code></pre> <p>Replace the <code>/media/JELOS</code> path with wherever your SD card is mounted:</p> <pre><code>igir copy extract test clean \\\n  --dat \"https://raw.githubusercontent.com/libretro/libretro-database/master/dat/System.dat\" \\\n  --input BIOS/ \\\n  --output /media/JELOS/roms/bios\n</code></pre>"}, {"location": "usage/handheld/jelos/#roms", "title": "ROMs", "text": "<p>JELOS supports many many systems and ROM formats. Check sections under the <code>Systems</code> menu in the JELOS Wiki for more precise instructions about the indivudual systems. Most supported systems and their ROMS can be automatically sorted by Igir using the <code>{jelos}</code> output token. See the replaceable tokens page for more information.</p>  Windows macOS Linux <p>Replace the <code>E:\\</code> drive letter with wherever your SD card is:</p> <pre><code>igir copy extract test clean ^\n  --dat \"No-Intro*.zip\" ^\n  --input ROMs\\ ^\n  --output \"E:\\roms\\{jelos}\" ^\n  --dir-letter ^\n  --no-bios\n</code></pre> <p>Replace the <code>/Volumes/JELOS</code> drive name with whatever your SD card is named:</p> <pre><code>igir copy extract test clean \\\n  --dat \"No-Intro*.zip\" \\\n  --input ROMs/ \\\n  --output \"/Volumes/JELOS/roms/{jelos}\" \\\n  --dir-letter \\\n  --no-bios\n</code></pre> <p>Replace the <code>/media/JELOS</code> path with wherever your SD card is mounted:</p> <pre><code>igir copy extract test clean \\\n  --dat \"No-Intro*.zip\" \\\n  --input ROMs/ \\\n  --output \"/media/JELOS/roms/{jelos}\" \\\n  --dir-letter \\\n  --no-bios\n</code></pre>"}, {"location": "usage/handheld/minui/", "title": "MinUI", "text": "<p>MinUI is a custom launcher supporting the Powkiddy RGB30, Trimui Smart (and Pro), Miyoo Mini (and Plus), as well as Anbernic RG35XX. It is focused on providing a minimalistic and easy to use frontend for the most important 8 and 16 bit consoles.</p>"}, {"location": "usage/handheld/minui/#bios-files", "title": "BIOS Files", "text": "<p>MinUI is strictly bring your own BIOS. You can find information on the required BIOS files in the docs.</p> <p>Info</p> <p>The following information is not guaranteed to be up to date and is based off the information from the link above at the time of writing as well as community contributions. Please reference the information provided by the developers of MinUI when running into troubles.</p> <p>Place these files under <code>/Bios/&lt;PAK-name&gt;/&lt;Filename&gt;</code>:</p> Console PAK File MD5 NEC TurboGrafx-16 PCE <code>syscard3.pce</code> <code>38179df8f4ac870017db21ebcbf53114</code> Nintendo Game Boy GB <code>gb_bios.bin</code> <code>32fbbd84168d3482956eb3c5051637f5</code> Nintendo Game Boy Color GBC <code>gbc_bios.bin</code> <code>dbfce9db9deaa2567f6a84fde55f9680</code> Nintendo Game Boy Advance GBA <code>gba_bios.bin</code> <code>a860e8c0b6d573d191e4ec7db1b1e4f6</code> Nintendo Game Boy Advance MGBA <code>gba_bios.bin</code> <code>a860e8c0b6d573d191e4ec7db1b1e4f6</code> Nintendo Pokemon Mini PKM <code>bios.min</code> <code>1e4fb124a3a886865acb574f388c803d</code> Nintendo Super Game Boy SGB <code>sgb.bios</code> <code>d574d4f9c12f305074798f54c091a8b4</code> Sony PlayStation PS <code>scph1001.bin</code> <code>924e392ed05558ffdb115408c263dccf</code>"}, {"location": "usage/handheld/minui/#roms", "title": "ROMs", "text": "<p>MinUI supports many many systems and ROM formats. Check the folders here (base) and here (extras) for a comprehensive list about the indivudual systems. Most supported systems and their ROMS can be automatically sorted by Igir using the <code>{minui}</code> output token. See the replaceable tokens page for more information.</p> <p>MinUI uses the names unter /Roms on the SD card in a more creative way than most other frontends. The folder names consist of a UI name and a PAK name. The UI name is used as the name shown in the User interface as a list item name, while the PAK name controls which software pack is used to open the files within. Files with the same UI name but different PAK name are listed in the same list in the UI but are opened with different PAKs. Igir uses the vendor recommendations for the folder names with some exceptions.</p> <p>MinUI requires multi-file releases to be grouped into subdirectories (bin/cue releases of the PS1 for example). It is recommended to use the <code>--dir-game-subdir multiple</code> option, which is the default at this time.</p> <p>More details about these features can be found in GitHub under the sections <code>Roms</code> and <code>Disc-based games</code>.</p>  Windows macOS Linux <p>Replace the <code>E:\\</code> drive letter with wherever your SD card is:</p> <pre><code>igir copy extract test clean ^\n  --dat \"No-Intro*.zip\" ^\n  --input ROMs\\ ^\n  --output \"E:\\roms\\{minui}\" ^\n  --dir-letter ^\n  --no-bios\n</code></pre> <p>Replace the <code>/Volumes/MinUI</code> drive name with whatever your SD card is named:</p> <pre><code>igir copy extract test clean \\\n  --dat \"No-Intro*.zip\" \\\n  --input ROMs/ \\\n  --output \"/Volumes/MinUI/roms/{minui}\" \\\n  --dir-letter \\\n  --no-bios\n</code></pre> <p>Replace the <code>/media/MinUI</code> path with wherever your SD card is mounted:</p> <pre><code>igir copy extract test clean \\\n  --dat \"No-Intro*.zip\" \\\n  --input ROMs/ \\\n  --output \"/media/MinUI/roms/{minui}\" \\\n  --dir-letter \\\n  --no-bios\n</code></pre>"}, {"location": "usage/handheld/miyoocfw/", "title": "MiyooCFW", "text": "<p>MiyooCFW (Code) is a custom firmware  for BittBoy, PocketGo, PowKiddy V90-Q90-Q20 and third party handheld consoles. It is based on the buildroot build environment and loosely based on OpenDingux. While it is intended for the named less powerful handhelds, it packs a good and wide selection of emulators. Some tinkering with the BIOS files is required though, but no worries, most of that is covered below or in their Wiki</p>"}, {"location": "usage/handheld/miyoocfw/#bios-files", "title": "BIOS Files", "text": "<p>MiyooCFW doesn't seem to have a centralized folder for putting BIOS files so it's a chore to prepare the card for running the provided emulators. Here's a try to help with finding the right ones and putting them in the right place.</p> <p>Info</p> <p>Please keep in mind that this information is based on the table in the official MiyooCFW Emulator Info and might be out of date. Please refer to the official list for reference.</p> System Emulator Folder Filenames MD5SUMs Comments GB/GBC Gambatte /.gambatte/bios/BIOS <code>gb_bios.bin</code> <code>gbc_bios.bin</code> <code>32fbbd84168d3482956eb3c5051637f5</code> <code>dbfce9db9deaa2567f6a84fde55f9680</code> Only required for authentic boot screen GBA GPSP /emus/gpsp_gameblabla/ <code>gba_bios.bin</code> <code>a860e8c0b6d573d191e4ec7db1b1e4f6</code> GBA GPSP Rumble /emus/gpsp/ <code>gba_bios.bin</code> <code>a860e8c0b6d573d191e4ec7db1b1e4f6</code> NES FCEUX /.fceux/ <code>disksys.rom</code> <code>ca30b50f880eb660a320674ed365ef7a</code> For Famicom Disk System Sega Master System / Game Gear SMS Plus GX /emus/smsplusgx/bios/ <code>BIOS.col</code> <code>840481177270d5642a14ca71ee72844c</code> System.dat calls this <code>bios.sms</code> Sega Megadrive / Genesis Picodrive /.picodrive/ <code>bios_cd_e.bin</code> <code>bios_cd_j.bin</code> <code>bios_cd_u.bin</code> <code>e66fa1dc5820d254611fdcdba0662372</code> <code>278a9397d192149e84e820ac621a8edd</code> <code>2efd74e3232ff260e371b99f84024f7f</code> for Mega-CD only. System.dat uses different casing. PC Engine / Turbogfx-16 Temper /.temper/syscards/ <code>syscard3.pce</code> <code>38179df8f4ac870017db21ebcbf53114</code> for CD based games SNK NeoGeo GNGeo /roms/NEOGEO/ <code>NEOGEO.zip</code> unknown version from FBA 0.2.97.39 works Sony PlayStation 1 PCSX ReARMed /emus/pcsx_rearmed/bios/ <code>SCPH1001.BIN</code> <code>924e392ed05558ffdb115408c263dccf</code> Optional but required for LLE, activate in options GCE Vectrex Vecxemu /.vecxemu/ <code>rom.dat</code> <code>ab082fa8c8e632dd68589a8c7741388f</code> not part of 'System.dat', available as part of the vecxemu rom.dat"}, {"location": "usage/handheld/miyoocfw/#roms", "title": "ROMs", "text": "<p>MiyooCFW supports many many systems and ROM formats. Check the table on the MiyooCFW Wiki for more precise instructions about the indivudual systems. Most supported systems and their ROMS can be automatically sorted by Igir using the <code>{miyoocfw}</code> output token. See the replaceable tokens page for more information.</p>  Windows macOS Linux <p>Replace the <code>E:\\</code> drive letter with wherever your SD card is:</p> <pre><code>igir copy extract test clean ^\n  --dat \"No-Intro*.zip\" ^\n  --input ROMs\\ ^\n  --output \"E:\\roms\\{miyoocfw}\" ^\n  --dir-letter ^\n  --no-bios\n</code></pre> <p>Replace the <code>/Volumes/MiyooCFW</code> drive name with whatever your SD card is named:</p> <pre><code>igir copy extract test clean \\\n  --dat \"No-Intro*.zip\" \\\n  --input ROMs/ \\\n  --output \"/Volumes/MiyooCFW/roms/{miyoocfw}\" \\\n  --dir-letter \\\n  --no-bios\n</code></pre> <p>Replace the <code>/media/MiyooCFW</code> path with wherever your SD card is mounted:</p> <pre><code>igir copy extract test clean \\\n  --dat \"No-Intro*.zip\" \\\n  --input ROMs/ \\\n  --output \"/media/MiyooCFW/roms/{miyoocfw}\" \\\n  --dir-letter \\\n  --no-bios\n</code></pre>"}, {"location": "usage/handheld/onionos/", "title": "OnionOS / GarlicOS", "text": "<p>Info</p> <p>OnionOS is based on RetroArch, and GarlicOS is based on OnionOS, so most instructions are very similar.</p> <p>OnionOS is a popular \"OS overhaul\" for the Miyoo Mini, and GarlicOS is a similar overhaul for the Anbernic RG35XX.</p>"}, {"location": "usage/handheld/onionos/#bios", "title": "BIOS", "text": "<p>OnionOS has its BIOS folder at the root of the SD card at <code>/BIOS/</code>, and it uses the RetroArch filenames:</p>  Windows macOS Linux <p>Replace the <code>E:\\</code> drive letter with wherever your SD card is:</p> <pre><code>igir copy extract test clean ^\n  --dat \"https://raw.githubusercontent.com/libretro/libretro-database/master/dat/System.dat\" ^\n  --input BIOS\\ ^\n  --output E:\\BIOS\n</code></pre> <p>Replace the <code>/Volumes/OnionOS</code> drive name with whatever your SD card is named:</p> <pre><code>igir copy extract test clean \\\n  --dat \"https://raw.githubusercontent.com/libretro/libretro-database/master/dat/System.dat\" \\\n  --input BIOS/ \\\n  --output /Volumes/OnionOS/BIOS\n</code></pre> <p>Replace the <code>/media/OnionOS</code> path with wherever your SD card is mounted:</p> <pre><code>igir copy extract test clean \\\n  --dat \"https://raw.githubusercontent.com/libretro/libretro-database/master/dat/System.dat\" \\\n  --input BIOS/ \\\n  --output /media/OnionOS/BIOS\n</code></pre>"}, {"location": "usage/handheld/onionos/#roms", "title": "ROMs", "text": "<p>OnionOS uses its own proprietary ROM folder structure, so Igir has a replaceable <code>{onion}</code> token to sort ROMs into the right place. See the replaceable tokens page for more information.</p>  Windows macOS Linux <p>Replace the <code>E:\\</code> drive letter with wherever your SD card is:</p> <pre><code>igir copy extract test clean ^\n  --dat \"No-Intro*.zip\" ^\n  --input ROMs\\ ^\n  --output \"E:\\Roms\\{onion}\" ^\n  --dir-letter ^\n  --no-bios\n</code></pre> <p>Replace the <code>/Volumes/OnionOS</code> drive name with whatever your SD card is named:</p> <pre><code>igir copy extract test clean \\\n  --dat \"No-Intro*.zip\" \\\n  --input ROMs/ \\\n  --output \"/Volumes/OnionOS/Roms/{onion}\" \\\n  --dir-letter \\\n  --no-bios\n</code></pre> <p>Replace the <code>/media/OnionOS</code> path with wherever your SD card is mounted:</p> <pre><code>igir copy extract test clean \\\n  --dat \"No-Intro*.zip\" \\\n  --input ROMs/ \\\n  --output \"/media/OnionOS/Roms/{onion}\" \\\n  --dir-letter \\\n  --no-bios\n</code></pre>"}, {"location": "usage/handheld/twmenu/", "title": "TWiLightMenu++", "text": "<p>Info</p> <p>TWiLightMenu++ is a Retro Emulation OS for the Nintendo 3DS and DSi handhelds. It is not very well documented which consoles are supported. While the contributors list in README.md suggests that a lot more systems are supported (Atari A800 for example) than we are filtering with the <code>{twmenu}</code> tag. This list may evolve while more users use and test the tag.</p> <p>TWiLightMenu++ is a launcher replacement software for the Nintendo 3DS and DSi handhelds. It aims to make launching and opening a multitude of media content types (Roms, music, videos etc.) easier and more convenient. It comes with many emulators preinstalled (see the link above). While large rom collections are hard to browse, it provides a neat way to carry more of your ROM collection on a great handheld.</p>"}, {"location": "usage/handheld/twmenu/#bios", "title": "BIOS", "text": "<p>TWiLightMenu++ ships with most emulators not needing BIOS files. No exceptions are known to the author.</p>"}, {"location": "usage/handheld/twmenu/#roms", "title": "ROMs", "text": "<p>TWiLightMenu uses its own proprietary ROM folder structure based in the root of the SD card, so Igir has a replaceable <code>{twmenu}</code> token to sort ROMs into the right place. See the replaceable tokens page for more information.</p>  Windows macOS Linux <p>Replace the <code>E:\\</code> drive letter with wherever your SD card is:</p> <pre><code>igir copy extract test clean ^\n  --dat \"No-Intro*.zip\" ^\n  --input ROMs\\ ^\n  --output \"E:\\{twmenu}\" ^\n  --dir-letter ^\n  --no-bios\n</code></pre> <p>Replace the <code>/Volumes/DSCard</code> drive name with whatever your SD card is named:</p> <pre><code>igir copy extract test clean \\\n  --dat \"No-Intro*.zip\" \\\n  --input ROMs/ \\\n  --output \"/Volumes/DSCard/roms/{twmenu}\" \\\n  --dir-letter \\\n  --no-bios\n</code></pre> <p>Replace the <code>/media/DSCard</code> path with wherever your SD card is mounted:</p> <pre><code>igir copy extract test clean \\\n  --dat \"No-Intro*.zip\" \\\n  --input ROMs/ \\\n  --output \"/media/DSCard/roms/{twmenu}\" \\\n  --dir-letter \\\n  --no-bios\n</code></pre>"}, {"location": "usage/hardware/analogue-pocket/", "title": "Analogue Pocket", "text": "<p>The Analogue Pocket is a field-programmable gate array (FPGA) handheld that plays Game Boy, Game Boy Color, and Game Boy Advance cartridges by simulating the hardware. It can also be extended to simulate other generation 1-4 consoles &amp; handheld hardware with Analogue's openFPGA.</p> <p>These other hardware simulations are called \"cores,\" and they each expect their ROMs in a very specific directory on the Analogue Pocket's SD card.</p> <p>Tip</p> <p>You can install openFPGA cores easily with utilities such as Matt Pannella's <code>pocket_updater</code>.</p>"}, {"location": "usage/hardware/analogue-pocket/#bios", "title": "BIOS", "text": "<p>Most Pocket updater utilities will download BIOS files required for each core for you automatically, so you shouldn't need to source &amp; sort them yourself.</p>"}, {"location": "usage/hardware/analogue-pocket/#roms", "title": "ROMs", "text": "<p>Igir has support for replaceable \"tokens\" in the <code>--output &lt;path&gt;</code> option. This makes it easier to sort ROMs on devices that have an expected directory structure. The <code>{pocket}</code> token exists to help sort ROMs on the Analogue pocket. See the replaceable tokens page for more information.</p> <p>This token can be used to reference each core's specific directory in the SD card's <code>Assets</code> directory. ROMs go in the <code>Assets/{pocket}/common</code> directory.</p>  Windows macOS Linux <p>Replace the <code>E:\\</code> drive letter with wherever your SD card is:</p> <pre><code>igir copy extract test clean ^\n  --dat \"No-Intro*.zip\" ^\n  --dat-name-regex-exclude \"/headerless/i\" ^\n  --input \"ROMs\" ^\n  --output \"E:\\Assets\\{pocket}\\common\" ^\n  --dir-letter ^\n  --dir-letter-limit 1000 ^\n  --clean-exclude \"E:\\Assets\\*\\common\\*.*\" ^\n  --no-bios\n</code></pre> <p>Replace the <code>/Volumes/POCKET</code> drive name with whatever your SD card is named:</p> <pre><code>igir copy extract test clean \\\n  --dat \"No-Intro*.zip\" \\\n  --dat-name-regex-exclude \"/headerless/i\" \\\n  --input \"ROMs/\" \\\n  --output \"/Volumes/POCKET/Assets/{pocket}/common/\" \\\n  --dir-letter \\\n  --dir-letter-limit 1000 \\\n  --clean-exclude \"/Volumes/POCKET/Assets/*/common/*.*\" \\\n  --no-bios\n</code></pre> <p>Replace the <code>/media/POCKET</code> path with wherever your SD card is mounted:</p> <pre><code>igir copy extract test clean \\\n  --dat \"No-Intro*.zip\" \\\n  --dat-name-regex-exclude \"/headerless/i\" \\\n  --input \"ROMs/\" \\\n  --output \"/media/POCKET/Assets/{pocket}/common/\" \\\n  --dir-letter \\\n  --dir-letter-limit 1000 \\\n  --clean-exclude \"/media/POCKET/Assets/*/common/*.*\" \\\n  --no-bios\n</code></pre> <p>Note</p> <p>The <code>--dat-name-regex-exclude \"/headerless/i\"</code> option in the above examples is to exclude any \"headered\" No-Intro DATs. Some consoles such as NES have separate \"headered\" and \"headerless\" DATs, and they have duplicated ROM filenames, so we want to avoid writing different input files to the same output location.</p> <p>Note</p> <p>The <code>--dir-letter-limit 1000</code> option in the above example is because some cores won't read more than a certain number of files in one directory. See output path options for other options available.</p> <p>Note</p> <p>The <code>--clean-exclude &lt;path&gt;</code> option in the above examples is so we don't accidentally \"clean\" (delete) the BIOS files for each core.</p> <p>Your SD card should look like this, likely with more cores:</p> <pre><code>\u251c\u2500\u2500 Assets\n\u2502   \u251c\u2500\u2500 genesis\n\u2502   \u2502   \u2514\u2500\u2500 common\n\u2502   \u2502       \u251c\u2500\u2500 ROM1.md\n\u2502   \u2502       \u251c\u2500\u2500 ROM2.md\n\u2502   \u2502       \u2514\u2500\u2500 ROM3.md\n\u2502   \u251c\u2500\u2500 nes\n\u2502   \u2502   \u2514\u2500\u2500 common\n\u2502   \u2502       \u251c\u2500\u2500 ROM1.nes\n\u2502   \u2502       \u251c\u2500\u2500 ROM2.nes\n\u2502   \u2502       \u2514\u2500\u2500 ROM3.nes\n\u2502   \u251c\u2500\u2500 sms\n\u2502   \u2502   \u2514\u2500\u2500 common\n\u2502   \u2502       \u251c\u2500\u2500 ROM1.sms\n\u2502   \u2502       \u251c\u2500\u2500 ROM2.sms\n\u2502   \u2502       \u2514\u2500\u2500 ROM3.sms\n\u2502   \u2514\u2500\u2500 snes\n\u2502       \u2514\u2500\u2500 common\n\u2502           \u251c\u2500\u2500 ROM1.snes\n\u2502           \u251c\u2500\u2500 ROM2.snes\n\u2502           \u2514\u2500\u2500 ROM3.snes\n\u251c\u2500\u2500 Cores\n\u251c\u2500\u2500 Platforms\n\u2514\u2500\u2500 Presets\n</code></pre>"}, {"location": "usage/hardware/everdrive/", "title": "EverDrive", "text": "<p>The EverDrive flash carts by Krikzz are some of the highest quality, highest rate of compatability, and most often recommended flash carts available on the market today.</p>"}, {"location": "usage/hardware/everdrive/#roms", "title": "ROMs", "text": "<p>Because flash carts are specific to a specific console, you can provide specific input directories and DATs when you run Igir. For example:</p>  Windows macOS Linux <p>Replace the <code>E:\\</code> drive letter with wherever your SD card is:</p> <pre><code>igir copy extract test clean ^\n  --dat \"Nintendo - Nintendo Entertainment System (Headered).dat\" ^\n  --input \"ROMs-Sorted\\Nintendo - Nintendo Entertainment System\" ^\n  --output E:\\ ^\n  --no-bios\n</code></pre> <p>Replace the <code>/Volumes/EverDrive</code> drive name with whatever your SD card is named:</p> <pre><code>igir copy extract test clean \\\n  --dat \"Nintendo - Nintendo Entertainment System (Headered).dat\" \\\n  --input \"ROMs-Sorted/Nintendo - Nintendo Entertainment System\" \\\n  --output /Volumes/EverDrive/ \\\n  --no-bios\n</code></pre> <p>Replace the <code>/media/EverDrive</code> path with wherever your SD card is mounted:</p> <pre><code>igir copy extract test clean \\\n  --dat \"Nintendo - Nintendo Entertainment System (Headered).dat\" \\\n  --input \"ROMs-Sorted/Nintendo - Nintendo Entertainment System\" \\\n  --output /media/EverDrive/ \\\n  --no-bios\n</code></pre> <p>you can then add some other output options such as the <code>--dir-letter</code> option, if desired.</p> <p>Alternatively, Igir supports Hardware Target Game Database SMDB files as DATs. Unlike typical DATs, Hardware Target Game Database SMDBs typically have an opinionated directory structure to help sort ROMs by language, category, genre, and more. Example usage:</p> <p>Tip</p> <p>You can achieve a result similar to the Hardware Target Game Database DATs with the following options:</p>  Windows macOS Linux <pre><code>igir [commands..] ^\n  [options] ^\n  --output \"{datName}\\{region}\" ^\n  --dir-letter ^\n  --dir-letter-group ^\n  --dir-letter-limit 200\n</code></pre> <pre><code>igir [commands..] \\\n  [options] \\\n  --output \"{datName}/{region}\" \\\n  --dir-letter \\\n  --dir-letter-group \\\n  --dir-letter-limit 200\n</code></pre> <pre><code>igir [commands..] \\\n  [options] \\\n  --output \"{datName}/{region}\" \\\n  --dir-letter \\\n  --dir-letter-group \\\n  --dir-letter-limit 200\n</code></pre>  Windows macOS Linux <p>Replace the <code>E:\\</code> drive letter with wherever your SD card is:</p> <pre><code>igir copy extract test clean ^\n  --dat \"https://raw.githubusercontent.com/frederic-mahe/Hardware-Target-Game-Database/master/EverDrive%20Pack%20SMDBs/NES2.0%20SMDB.txt\" ^\n  --input \"ROMs-Sorted\\Nintendo - Nintendo Entertainment System\" ^\n  --output E:\\\n</code></pre> <p>Replace the <code>/Volumes/EverDrive</code> drive name with whatever your SD card is named:</p> <pre><code>igir copy extract test clean \\\n  --dat \"https://raw.githubusercontent.com/frederic-mahe/Hardware-Target-Game-Database/master/EverDrive%20Pack%20SMDBs/NES2.0%20SMDB.txt\" \\\n  --input \"ROMs-Sorted/Nintendo - Nintendo Entertainment System\" \\\n  --output /Volumes/EverDrive/\n</code></pre> <p>Replace the <code>/media/EverDrive</code> path with wherever your SD card is mounted:</p> <pre><code>igir copy extract test clean \\\n  --dat \"https://raw.githubusercontent.com/frederic-mahe/Hardware-Target-Game-Database/master/EverDrive%20Pack%20SMDBs/NES2.0%20SMDB.txt\" \\\n  --input \"ROMs-Sorted/Nintendo - Nintendo Entertainment System\" \\\n  --output /media/EverDrive/\n</code></pre>"}, {"location": "usage/hardware/ezflash/", "title": "EZ-FLASH", "text": "<p>The EZ-FLASH flash carts for Nintendo handhelds are a cheaper alternative to other flash carts such as the EverDrive.</p>"}, {"location": "usage/hardware/ezflash/#roms", "title": "ROMs", "text": "<p>Because flash carts are specific to a specific console, you can provide specific input directories &amp; DATs when you run Igir. For example:</p>  Windows macOS Linux <p>Replace the <code>E:\\</code> drive letter with wherever your SD card is:</p> <pre><code>igir copy extract test clean ^\n  --dat \"Nintendo - Game Boy.dat\" ^\n  --input \"ROMs-Sorted\\Nintendo - Game Boy\" ^\n  --output E:\\ ^\n  --no-bios\n</code></pre> <p>Replace the <code>/Volumes/EZFLASH</code> drive name with whatever your SD card is named:</p> <pre><code>igir copy extract test clean \\\n  --dat \"Nintendo - Game Boy.dat\" \\\n  --input \"ROMs-Sorted/Nintendo - Game Boy\" \\\n  --output /Volumes/EZFLASH/ \\\n  --no-bios\n</code></pre> <p>Replace the <code>/media/EZFLASH</code> path with wherever your SD card is mounted:</p> <pre><code>igir copy extract test clean \\\n  --dat \"Nintendo - Game Boy.dat\" \\\n  --input \"ROMs-Sorted/Nintendo - Game Boy\" \\\n  --output /media/EZFLASH/ \\\n  --no-bios\n</code></pre> <p>you can then add some other output options such as the <code>--dir-letter</code> option, if desired.</p> <p>Warning</p> <p>The EZ-FLASH appears to have issues with fragmented files, in the same way that GameCube's Swiss and PS2's OPL does (igir#802).</p> <p>You may need to set the option <code>--writer-threads 1</code> to fix any issues with your specific model.</p> <p>Even though Hardware Target Game Database uses the word \"EverDrive\" in their database files, there is no reason you can't use them with other flash carts such as the EZ-FLASH. See an example usage of them in the EverDrive documentation.</p>"}, {"location": "usage/hardware/mister/", "title": "MiSTer FPGA", "text": "<p>The MiSTer FPGA is a set of software for field-programmable gate array (FPGA) development boards that simulates consoles &amp; handheld hardware. This means it can play games with perfect simulation.</p>"}, {"location": "usage/hardware/mister/#bios", "title": "BIOS", "text": "<p>The MiSTer <code>update_all.sh</code> script can download BIOS files required for each core automatically, so you shouldn't need to source &amp; sort them yourself.</p>"}, {"location": "usage/hardware/mister/#roms", "title": "ROMs", "text": "<p>Igir has support for replaceable \"tokens\" in the <code>--output &lt;path&gt;</code> option. This makes it easier to sort ROMs on devices that have an expected directory structure. The <code>{mister}</code> token exists to help sort ROMs on the MiSTer. See the replaceable tokens page for more information.</p> <p>This token can be used to reference each core's specific directory in the MiSTer's <code>games</code> directory.</p>  Windows macOS Linux <p>Replace the <code>E:\\</code> drive letter with wherever your SD card is:</p> <pre><code>igir copy extract test clean ^\n  --dat \"No-Intro*.zip\" ^\n  --input \"ROMs\" ^\n  --output \"E:\\games\\{mister}\" ^\n  --dir-letter ^\n  --no-bios\n</code></pre> <p>Replace the <code>/Volumes/MISTER</code> drive name with whatever your SD card is named:</p> <pre><code>igir copy extract test clean \\\n  --dat \"No-Intro*.zip\" \\\n  --input \"ROMs/\" \\\n  --output \"/Volumes/MISTER/games/{mister}/\" \\\n  --dir-letter \\\n  --no-bios\n</code></pre> <p>Replace the <code>/media/MISTER</code> path with wherever your SD card is mounted:</p> <pre><code>igir copy extract test clean \\\n  --dat \"No-Intro*.zip\" \\\n  --input \"ROMs/\" \\\n  --output \"/media/MISTER/games/{mister}/\" \\\n  --dir-letter \\\n  --no-bios\n</code></pre>"}]}